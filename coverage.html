
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>GoPDF2: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/VantageDataChat/GoPDF2/acroform_obj.go (100.0%)</option>
				
				<option value="file1">github.com/VantageDataChat/GoPDF2/annot_obj.go (95.5%)</option>
				
				<option value="file2">github.com/VantageDataChat/GoPDF2/annotation.go (100.0%)</option>
				
				<option value="file3">github.com/VantageDataChat/GoPDF2/annotation_modify.go (97.8%)</option>
				
				<option value="file4">github.com/VantageDataChat/GoPDF2/arabic_alphabet.go (100.0%)</option>
				
				<option value="file5">github.com/VantageDataChat/GoPDF2/arabic_helper.go (95.7%)</option>
				
				<option value="file6">github.com/VantageDataChat/GoPDF2/arc.go (100.0%)</option>
				
				<option value="file7">github.com/VantageDataChat/GoPDF2/bookmark.go (89.6%)</option>
				
				<option value="file8">github.com/VantageDataChat/GoPDF2/box.go (100.0%)</option>
				
				<option value="file9">github.com/VantageDataChat/GoPDF2/break_option.go (100.0%)</option>
				
				<option value="file10">github.com/VantageDataChat/GoPDF2/buff.go (100.0%)</option>
				
				<option value="file11">github.com/VantageDataChat/GoPDF2/buff_write.go (100.0%)</option>
				
				<option value="file12">github.com/VantageDataChat/GoPDF2/buffer_pool.go (100.0%)</option>
				
				<option value="file13">github.com/VantageDataChat/GoPDF2/cache_color_space.go (100.0%)</option>
				
				<option value="file14">github.com/VantageDataChat/GoPDF2/cache_contact_color_rgb.go (100.0%)</option>
				
				<option value="file15">github.com/VantageDataChat/GoPDF2/cache_content_clip.go (100.0%)</option>
				
				<option value="file16">github.com/VantageDataChat/GoPDF2/cache_content_color_cmyk.go (100.0%)</option>
				
				<option value="file17">github.com/VantageDataChat/GoPDF2/cache_content_custom_line_type.go (100.0%)</option>
				
				<option value="file18">github.com/VantageDataChat/GoPDF2/cache_content_graphics_state.go (100.0%)</option>
				
				<option value="file19">github.com/VantageDataChat/GoPDF2/cache_content_gray.go (100.0%)</option>
				
				<option value="file20">github.com/VantageDataChat/GoPDF2/cache_content_image.go (100.0%)</option>
				
				<option value="file21">github.com/VantageDataChat/GoPDF2/cache_content_imported_object.go (100.0%)</option>
				
				<option value="file22">github.com/VantageDataChat/GoPDF2/cache_content_line.go (100.0%)</option>
				
				<option value="file23">github.com/VantageDataChat/GoPDF2/cache_content_line_type.go (100.0%)</option>
				
				<option value="file24">github.com/VantageDataChat/GoPDF2/cache_content_line_width.go (100.0%)</option>
				
				<option value="file25">github.com/VantageDataChat/GoPDF2/cache_content_oval.go (100.0%)</option>
				
				<option value="file26">github.com/VantageDataChat/GoPDF2/cache_content_polygon.go (100.0%)</option>
				
				<option value="file27">github.com/VantageDataChat/GoPDF2/cache_content_polyline.go (100.0%)</option>
				
				<option value="file28">github.com/VantageDataChat/GoPDF2/cache_content_rectangle.go (100.0%)</option>
				
				<option value="file29">github.com/VantageDataChat/GoPDF2/cache_content_rotate.go (100.0%)</option>
				
				<option value="file30">github.com/VantageDataChat/GoPDF2/cache_content_sector.go (100.0%)</option>
				
				<option value="file31">github.com/VantageDataChat/GoPDF2/cache_content_text.go (97.3%)</option>
				
				<option value="file32">github.com/VantageDataChat/GoPDF2/cache_content_text_color_cmyk.go (100.0%)</option>
				
				<option value="file33">github.com/VantageDataChat/GoPDF2/cache_content_text_color_rgb.go (100.0%)</option>
				
				<option value="file34">github.com/VantageDataChat/GoPDF2/cache_contnent_curve.go (100.0%)</option>
				
				<option value="file35">github.com/VantageDataChat/GoPDF2/catalog_obj.go (100.0%)</option>
				
				<option value="file36">github.com/VantageDataChat/GoPDF2/cid_font_obj.go (100.0%)</option>
				
				<option value="file37">github.com/VantageDataChat/GoPDF2/clone.go (86.7%)</option>
				
				<option value="file38">github.com/VantageDataChat/GoPDF2/color_space_obj.go (100.0%)</option>
				
				<option value="file39">github.com/VantageDataChat/GoPDF2/colorspace_convert.go (97.5%)</option>
				
				<option value="file40">github.com/VantageDataChat/GoPDF2/config.go (100.0%)</option>
				
				<option value="file41">github.com/VantageDataChat/GoPDF2/content_element.go (98.1%)</option>
				
				<option value="file42">github.com/VantageDataChat/GoPDF2/content_obj.go (96.7%)</option>
				
				<option value="file43">github.com/VantageDataChat/GoPDF2/content_stream_clean.go (95.2%)</option>
				
				<option value="file44">github.com/VantageDataChat/GoPDF2/current.go (100.0%)</option>
				
				<option value="file45">github.com/VantageDataChat/GoPDF2/device_rgb_obj.go (93.8%)</option>
				
				<option value="file46">github.com/VantageDataChat/GoPDF2/digital_signature.go (87.9%)</option>
				
				<option value="file47">github.com/VantageDataChat/GoPDF2/doc_stats.go (88.2%)</option>
				
				<option value="file48">github.com/VantageDataChat/GoPDF2/embedded_file.go (94.2%)</option>
				
				<option value="file49">github.com/VantageDataChat/GoPDF2/embedfont_obj.go (90.9%)</option>
				
				<option value="file50">github.com/VantageDataChat/GoPDF2/encoding_obj.go (100.0%)</option>
				
				<option value="file51">github.com/VantageDataChat/GoPDF2/encryption_obj.go (100.0%)</option>
				
				<option value="file52">github.com/VantageDataChat/GoPDF2/ext_g_state_obj.go (95.8%)</option>
				
				<option value="file53">github.com/VantageDataChat/GoPDF2/font_container.go (87.9%)</option>
				
				<option value="file54">github.com/VantageDataChat/GoPDF2/font_extract.go (91.9%)</option>
				
				<option value="file55">github.com/VantageDataChat/GoPDF2/font_obj.go (100.0%)</option>
				
				<option value="file56">github.com/VantageDataChat/GoPDF2/font_option.go (100.0%)</option>
				
				<option value="file57">github.com/VantageDataChat/GoPDF2/fontconverthelper.go (100.0%)</option>
				
				<option value="file58">github.com/VantageDataChat/GoPDF2/fontdescriptor_obj.go (94.1%)</option>
				
				<option value="file59">github.com/VantageDataChat/GoPDF2/form_field.go (96.5%)</option>
				
				<option value="file60">github.com/VantageDataChat/GoPDF2/form_field_ops.go (98.1%)</option>
				
				<option value="file61">github.com/VantageDataChat/GoPDF2/gc.go (95.2%)</option>
				
				<option value="file62">github.com/VantageDataChat/GoPDF2/geometry.go (100.0%)</option>
				
				<option value="file63">github.com/VantageDataChat/GoPDF2/gopdf.go (92.3%)</option>
				
				<option value="file64">github.com/VantageDataChat/GoPDF2/html_insert.go (92.0%)</option>
				
				<option value="file65">github.com/VantageDataChat/GoPDF2/html_parser.go (96.8%)</option>
				
				<option value="file66">github.com/VantageDataChat/GoPDF2/ifont.go (100.0%)</option>
				
				<option value="file67">github.com/VantageDataChat/GoPDF2/image_delete.go (89.5%)</option>
				
				<option value="file68">github.com/VantageDataChat/GoPDF2/image_extract.go (94.1%)</option>
				
				<option value="file69">github.com/VantageDataChat/GoPDF2/image_holder.go (90.0%)</option>
				
				<option value="file70">github.com/VantageDataChat/GoPDF2/image_obj.go (87.2%)</option>
				
				<option value="file71">github.com/VantageDataChat/GoPDF2/image_obj_parse.go (87.9%)</option>
				
				<option value="file72">github.com/VantageDataChat/GoPDF2/image_recompress.go (89.4%)</option>
				
				<option value="file73">github.com/VantageDataChat/GoPDF2/imported_obj.go (100.0%)</option>
				
				<option value="file74">github.com/VantageDataChat/GoPDF2/incremental_save.go (92.3%)</option>
				
				<option value="file75">github.com/VantageDataChat/GoPDF2/journal.go (94.3%)</option>
				
				<option value="file76">github.com/VantageDataChat/GoPDF2/list_cache_content.go (96.8%)</option>
				
				<option value="file77">github.com/VantageDataChat/GoPDF2/map_of_character_To_glyph_index.go (100.0%)</option>
				
				<option value="file78">github.com/VantageDataChat/GoPDF2/margin.go (100.0%)</option>
				
				<option value="file79">github.com/VantageDataChat/GoPDF2/markinfo.go (94.6%)</option>
				
				<option value="file80">github.com/VantageDataChat/GoPDF2/names_obj.go (100.0%)</option>
				
				<option value="file81">github.com/VantageDataChat/GoPDF2/ocg.go (99.3%)</option>
				
				<option value="file82">github.com/VantageDataChat/GoPDF2/open_pdf.go (93.0%)</option>
				
				<option value="file83">github.com/VantageDataChat/GoPDF2/outlines_obj.go (100.0%)</option>
				
				<option value="file84">github.com/VantageDataChat/GoPDF2/page_batch_ops.go (96.1%)</option>
				
				<option value="file85">github.com/VantageDataChat/GoPDF2/page_cropbox.go (88.5%)</option>
				
				<option value="file86">github.com/VantageDataChat/GoPDF2/page_info.go (90.6%)</option>
				
				<option value="file87">github.com/VantageDataChat/GoPDF2/page_label.go (100.0%)</option>
				
				<option value="file88">github.com/VantageDataChat/GoPDF2/page_layout.go (100.0%)</option>
				
				<option value="file89">github.com/VantageDataChat/GoPDF2/page_manipulate.go (89.6%)</option>
				
				<option value="file90">github.com/VantageDataChat/GoPDF2/page_obj.go (97.8%)</option>
				
				<option value="file91">github.com/VantageDataChat/GoPDF2/page_option.go (100.0%)</option>
				
				<option value="file92">github.com/VantageDataChat/GoPDF2/page_rotate.go (88.9%)</option>
				
				<option value="file93">github.com/VantageDataChat/GoPDF2/pages_obj.go (100.0%)</option>
				
				<option value="file94">github.com/VantageDataChat/GoPDF2/paper_sizes.go (100.0%)</option>
				
				<option value="file95">github.com/VantageDataChat/GoPDF2/pdf_decrypt.go (91.5%)</option>
				
				<option value="file96">github.com/VantageDataChat/GoPDF2/pdf_dictionary_obj.go (90.6%)</option>
				
				<option value="file97">github.com/VantageDataChat/GoPDF2/pdf_lowlevel.go (91.0%)</option>
				
				<option value="file98">github.com/VantageDataChat/GoPDF2/pdf_obj_id.go (100.0%)</option>
				
				<option value="file99">github.com/VantageDataChat/GoPDF2/pdf_parser.go (91.7%)</option>
				
				<option value="file100">github.com/VantageDataChat/GoPDF2/pdf_protection.go (92.1%)</option>
				
				<option value="file101">github.com/VantageDataChat/GoPDF2/pdf_version.go (100.0%)</option>
				
				<option value="file102">github.com/VantageDataChat/GoPDF2/pixmap_render.go (92.4%)</option>
				
				<option value="file103">github.com/VantageDataChat/GoPDF2/procset_obj.go (100.0%)</option>
				
				<option value="file104">github.com/VantageDataChat/GoPDF2/rect.go (100.0%)</option>
				
				<option value="file105">github.com/VantageDataChat/GoPDF2/scrub.go (100.0%)</option>
				
				<option value="file106">github.com/VantageDataChat/GoPDF2/select_pages.go (87.9%)</option>
				
				<option value="file107">github.com/VantageDataChat/GoPDF2/signature_obj.go (98.4%)</option>
				
				<option value="file108">github.com/VantageDataChat/GoPDF2/smask_obj.go (95.6%)</option>
				
				<option value="file109">github.com/VantageDataChat/GoPDF2/strhelper.go (100.0%)</option>
				
				<option value="file110">github.com/VantageDataChat/GoPDF2/style.go (100.0%)</option>
				
				<option value="file111">github.com/VantageDataChat/GoPDF2/subfont_descriptor_obj.go (100.0%)</option>
				
				<option value="file112">github.com/VantageDataChat/GoPDF2/subset_font_obj.go (92.4%)</option>
				
				<option value="file113">github.com/VantageDataChat/GoPDF2/svg_insert.go (99.4%)</option>
				
				<option value="file114">github.com/VantageDataChat/GoPDF2/table.go (93.1%)</option>
				
				<option value="file115">github.com/VantageDataChat/GoPDF2/text_extract.go (97.6%)</option>
				
				<option value="file116">github.com/VantageDataChat/GoPDF2/text_search.go (93.8%)</option>
				
				<option value="file117">github.com/VantageDataChat/GoPDF2/toc.go (94.6%)</option>
				
				<option value="file118">github.com/VantageDataChat/GoPDF2/transparency.go (100.0%)</option>
				
				<option value="file119">github.com/VantageDataChat/GoPDF2/transparency_xobject_group.go (87.1%)</option>
				
				<option value="file120">github.com/VantageDataChat/GoPDF2/ttf_option.go (100.0%)</option>
				
				<option value="file121">github.com/VantageDataChat/GoPDF2/unicode_map.go (98.3%)</option>
				
				<option value="file122">github.com/VantageDataChat/GoPDF2/watermark.go (92.6%)</option>
				
				<option value="file123">github.com/VantageDataChat/GoPDF2/xmp_metadata.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// acroFormObj is the PDF AcroForm dictionary object.
type acroFormObj struct {
        fieldObjIDs []int  // 1-based object IDs of form field objects
        fontRefs    []acroFormFont // fonts used in form fields
        needAppearances bool
}

type acroFormFont struct {
        name  string // e.g. "F1"
        objID int    // 1-based
}

func (a acroFormObj) init(fn func() *GoPdf) {<span class="cov0" title="0">}</span>

func (a acroFormObj) getType() string <span class="cov8" title="1">{
        return "AcroForm"
}</span>

func (a acroFormObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")

        // Fields array
        io.WriteString(w, "/Fields [")
        for _, id := range a.fieldObjIDs </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%d 0 R ", id)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "]\n")

        // NeedAppearances â€” tells viewers to generate appearances
        io.WriteString(w, "/NeedAppearances true\n")

        // Default resources with fonts
        if len(a.fontRefs) &gt; 0 </span><span class="cov8" title="1">{
                io.WriteString(w, "/DR &lt;&lt; /Font &lt;&lt;")
                for _, f := range a.fontRefs </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, " /%s %d 0 R", f.name, f.objID)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, " &gt;&gt; &gt;&gt;\n")</span>
        }

        // Default appearance
        <span class="cov8" title="1">io.WriteString(w, "/DA (/Helv 12 Tf 0 0 0 rg)\n")

        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
)

type annotObj struct {
        linkOption
        GetRoot func() *GoPdf
}

func (o annotObj) init(f func() *GoPdf) {<span class="cov0" title="0">
}</span>

func (o annotObj) getType() string <span class="cov8" title="1">{
        return "Annot"
}</span>

func (o annotObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        if o.url != "" </span><span class="cov8" title="1">{
                return o.writeExternalLink(w, o.linkOption, objID)
        }</span> else<span class="cov8" title="1"> {
                return o.writeInternalLink(w, o.linkOption)
        }</span>
}

func (o annotObj) writeExternalLink(w io.Writer, l linkOption, objID int) error <span class="cov8" title="1">{
        protection := o.GetRoot().protection()
        url := l.url
        if protection != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(protection.objectkey(objID), []byte(url))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">url = string(tmp)</span>
        }
        <span class="cov8" title="1">url = strings.Replace(url, "\\", "\\\\", -1)
        url = strings.Replace(url, "(", "\\(", -1)
        url = strings.Replace(url, ")", "\\)", -1)
        url = strings.Replace(url, "\r", "\\r", -1)

        _, err := fmt.Fprintf(w, "&lt;&lt;/Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /A &lt;&lt;/S /URI /URI (%s)&gt;&gt;&gt;&gt;\n",
                l.x, l.y, l.x+l.w, l.y-l.h, url)
        return err</span>
}

func (o annotObj) writeInternalLink(w io.Writer, l linkOption) error <span class="cov8" title="1">{
        a, ok := o.GetRoot().anchors[l.anchor]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">_, err := fmt.Fprintf(w, "&lt;&lt;/Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /Dest [%d 0 R /XYZ 0 %.2f null]&gt;&gt;\n",
                l.x, l.y, l.x+l.w, l.y-l.h, a.page+1, a.y)
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
        "time"
)

// AnnotationType represents the type of PDF annotation.
type AnnotationType int

const (
        // AnnotText is a sticky note annotation (appears as an icon).
        AnnotText AnnotationType = iota
        // AnnotHighlight highlights existing text on the page.
        AnnotHighlight
        // AnnotUnderline underlines existing text on the page.
        AnnotUnderline
        // AnnotStrikeOut strikes out existing text on the page.
        AnnotStrikeOut
        // AnnotSquare draws a rectangle annotation.
        AnnotSquare
        // AnnotCircle draws a circle/ellipse annotation.
        AnnotCircle
        // AnnotFreeText places text directly on the page.
        AnnotFreeText
        // AnnotInk is a freehand drawing annotation (ink strokes).
        AnnotInk
        // AnnotPolyline draws connected line segments (open path).
        AnnotPolyline
        // AnnotPolygon draws a closed polygon shape.
        AnnotPolygon
        // AnnotLine draws a single line between two endpoints.
        AnnotLine
        // AnnotStamp places a predefined stamp (e.g. "Approved", "Draft").
        AnnotStamp
        // AnnotSquiggly applies a wavy underline to text.
        AnnotSquiggly
        // AnnotCaret marks an insertion point in text.
        AnnotCaret
        // AnnotFileAttachment attaches a file to the annotation.
        AnnotFileAttachment
        // AnnotRedact marks an area for redaction (content removal).
        AnnotRedact
)

// StampName represents predefined PDF stamp names.
type StampName string

const (
        StampApproved     StampName = "Approved"
        StampAsIs         StampName = "AsIs"
        StampConfidential StampName = "Confidential"
        StampDepartmental StampName = "Departmental"
        StampDraft        StampName = "Draft"
        StampExperimental StampName = "Experimental"
        StampExpired      StampName = "Expired"
        StampFinal        StampName = "Final"
        StampForComment   StampName = "ForComment"
        StampForPublicRelease StampName = "ForPublicRelease"
        StampNotApproved  StampName = "NotApproved"
        StampNotForPublicRelease StampName = "NotForPublicRelease"
        StampSold         StampName = "Sold"
        StampTopSecret    StampName = "TopSecret"
)

// LineEndingStyle represents PDF line ending styles.
type LineEndingStyle string

const (
        LineEndNone        LineEndingStyle = "None"
        LineEndSquare      LineEndingStyle = "Square"
        LineEndCircle      LineEndingStyle = "Circle"
        LineEndDiamond     LineEndingStyle = "Diamond"
        LineEndOpenArrow   LineEndingStyle = "OpenArrow"
        LineEndClosedArrow LineEndingStyle = "ClosedArrow"
        LineEndButt        LineEndingStyle = "Butt"
        LineEndROpenArrow  LineEndingStyle = "ROpenArrow"
        LineEndRClosedArrow LineEndingStyle = "RClosedArrow"
        LineEndSlash       LineEndingStyle = "Slash"
)

// AnnotationOption configures a PDF annotation.
type AnnotationOption struct {
        // Type is the annotation type.
        Type AnnotationType

        // Rect defines the annotation rectangle [x, y, w, h] in document units.
        // x, y is the top-left corner.
        X, Y, W, H float64

        // Title is the annotation title (author name for sticky notes).
        Title string

        // Content is the annotation text content.
        Content string

        // Color is the annotation color in RGB. Default: yellow (255, 255, 0).
        Color [3]uint8

        // Opacity is the annotation opacity (0.0 to 1.0). Default: 1.0.
        Opacity float64

        // Open determines if a text annotation popup is initially open.
        Open bool

        // CreationDate is the annotation creation date. Default: now.
        CreationDate time.Time

        // FontSize is used for FreeText annotations. Default: 12.
        FontSize float64

        // InkList contains stroke paths for Ink annotations.
        // Each element is a slice of Points representing one stroke.
        InkList [][]Point

        // Vertices contains points for Polyline and Polygon annotations.
        Vertices []Point

        // LineStart and LineEnd define endpoints for Line annotations.
        LineStart, LineEnd Point

        // LineEndingStyles defines the start and end styles for Line annotations.
        // Default: [None, None].
        LineEndingStyles [2]LineEndingStyle

        // Stamp is the stamp name for Stamp annotations. Default: "Draft".
        Stamp StampName

        // InteriorColor is the fill color for closed shapes (Square, Circle, Polygon).
        // If nil (zero value), no interior color is applied.
        InteriorColor *[3]uint8

        // BorderWidth is the annotation border width. Default: 1.
        BorderWidth float64

        // FileName is the file name for FileAttachment annotations.
        FileName string

        // FileData is the file content for FileAttachment annotations.
        FileData []byte

        // OverlayText is the text displayed over a Redact annotation area.
        OverlayText string
}

func (o *AnnotationOption) defaults() <span class="cov8" title="1">{
        if o.Color == [3]uint8{0, 0, 0} </span><span class="cov8" title="1">{
                o.Color = [3]uint8{255, 255, 0}
        }</span>
        <span class="cov8" title="1">if o.Opacity &lt;= 0 </span><span class="cov8" title="1">{
                o.Opacity = 1.0
        }</span>
        <span class="cov8" title="1">if o.CreationDate.IsZero() </span><span class="cov8" title="1">{
                o.CreationDate = time.Now()
        }</span>
        <span class="cov8" title="1">if o.FontSize &lt;= 0 </span><span class="cov8" title="1">{
                o.FontSize = 12
        }</span>
        <span class="cov8" title="1">if o.BorderWidth &lt;= 0 </span><span class="cov8" title="1">{
                o.BorderWidth = 1
        }</span>
        <span class="cov8" title="1">if o.Stamp == "" </span><span class="cov8" title="1">{
                o.Stamp = StampDraft
        }</span>
}

// AnnotationInfo holds information about an existing annotation on a page.
type AnnotationInfo struct {
        // Index is the position of this annotation in the page's annotation list.
        Index int
        // Type is the annotation type.
        Type AnnotationType
        // Option is the original annotation option (if available).
        Option AnnotationOption
}

// annotationObj represents a PDF annotation object.
type annotationObj struct {
        opt     AnnotationOption
        getRoot func() *GoPdf
}

func (a annotationObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (a annotationObj) getType() string <span class="cov8" title="1">{
        return "Annot"
}</span>

func (a annotationObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        a.opt.defaults()

        pageH := a.getRoot().config.PageSize.H

        // Convert from top-left origin to PDF bottom-left origin.
        x1 := a.opt.X
        y1 := pageH - a.opt.Y
        x2 := a.opt.X + a.opt.W
        y2 := pageH - (a.opt.Y + a.opt.H)

        // Escape content string.
        content := escapeAnnotString(a.opt.Content)
        title := escapeAnnotString(a.opt.Title)

        // Color components as floats (0-1).
        cr := float64(a.opt.Color[0]) / 255.0
        cg := float64(a.opt.Color[1]) / 255.0
        cb := float64(a.opt.Color[2]) / 255.0

        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /Annot\n")

        switch a.opt.Type </span>{
        case AnnotText:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Text\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/Contents (%s)\n", content)
                if title != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/T (%s)\n", title)
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if a.opt.Open </span><span class="cov8" title="1">{
                        io.WriteString(w, "/Open true\n")
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "/Name /Comment\n")</span>

        case AnnotHighlight:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Highlight\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/QuadPoints [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f]\n",
                        x1, y1, x2, y1, x1, y2, x2, y2)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotUnderline:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Underline\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/QuadPoints [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f]\n",
                        x1, y1, x2, y1, x1, y2, x2, y2)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)</span>

        case AnnotStrikeOut:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /StrikeOut\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/QuadPoints [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f]\n",
                        x1, y1, x2, y1, x1, y2, x2, y2)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)</span>

        case AnnotSquare:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Square\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if a.opt.InteriorColor != nil </span><span class="cov8" title="1">{
                        ic := a.opt.InteriorColor
                        fmt.Fprintf(w, "/IC [%.4f %.4f %.4f]\n",
                                float64(ic[0])/255.0, float64(ic[1])/255.0, float64(ic[2])/255.0)
                }</span>
                <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotCircle:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Circle\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if a.opt.InteriorColor != nil </span><span class="cov8" title="1">{
                        ic := a.opt.InteriorColor
                        fmt.Fprintf(w, "/IC [%.4f %.4f %.4f]\n",
                                float64(ic[0])/255.0, float64(ic[1])/255.0, float64(ic[2])/255.0)
                }</span>
                <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotFreeText:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /FreeText\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/Contents (%s)\n", content)
                fmt.Fprintf(w, "/DA (/Helv %.0f Tf %.4f %.4f %.4f rg)\n",
                        a.opt.FontSize, cr, cg, cb)
                io.WriteString(w, "/DS (font: Helvetica,sans-serif)\n")</span>

        case AnnotInk:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Ink\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
                // Write InkList array of stroke arrays.
                <span class="cov8" title="1">io.WriteString(w, "/InkList [")
                for _, stroke := range a.opt.InkList </span><span class="cov8" title="1">{
                        io.WriteString(w, "[")
                        for _, pt := range stroke </span><span class="cov8" title="1">{
                                px := pt.X
                                py := pageH - pt.Y
                                fmt.Fprintf(w, "%.2f %.2f ", px, py)
                        }</span>
                        <span class="cov8" title="1">io.WriteString(w, "]")</span>
                }
                <span class="cov8" title="1">io.WriteString(w, "]\n")</span>

        case AnnotPolyline:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /PolyLine\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "/Vertices [")
                for _, pt := range a.opt.Vertices </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%.2f %.2f ", pt.X, pageH-pt.Y)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "]\n")
                a.writeLineEndings(w)</span>

        case AnnotPolygon:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Polygon\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if a.opt.InteriorColor != nil </span><span class="cov8" title="1">{
                        ic := a.opt.InteriorColor
                        fmt.Fprintf(w, "/IC [%.4f %.4f %.4f]\n",
                                float64(ic[0])/255.0, float64(ic[1])/255.0, float64(ic[2])/255.0)
                }</span>
                <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "/Vertices [")
                for _, pt := range a.opt.Vertices </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "%.2f %.2f ", pt.X, pageH-pt.Y)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "]\n")</span>

        case AnnotLine:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Line\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
                <span class="cov8" title="1">lsx := a.opt.LineStart.X
                lsy := pageH - a.opt.LineStart.Y
                lex := a.opt.LineEnd.X
                ley := pageH - a.opt.LineEnd.Y
                fmt.Fprintf(w, "/L [%.2f %.2f %.2f %.2f]\n", lsx, lsy, lex, ley)
                a.writeLineEndings(w)</span>

        case AnnotStamp:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Stamp\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                fmt.Fprintf(w, "/Name /%s\n", a.opt.Stamp)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotSquiggly:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Squiggly\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/QuadPoints [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f]\n",
                        x1, y1, x2, y1, x1, y2, x2, y2)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotCaret:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Caret\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>

        case AnnotFileAttachment:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /FileAttachment\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/C [%.4f %.4f %.4f]\n", cr, cg, cb)
                if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
                <span class="cov8" title="1">if a.opt.FileName != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Name /PushPin\n")
                        fmt.Fprintf(w, "/FS &lt;&lt;/Type /Filespec /F (%s)&gt;&gt;\n",
                                escapeAnnotString(a.opt.FileName))
                }</span>

        case AnnotRedact:<span class="cov8" title="1">
                fmt.Fprintf(w, "/Subtype /Redact\n")
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y2, x2, y1)
                fmt.Fprintf(w, "/QuadPoints [%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f]\n",
                        x1, y1, x2, y1, x1, y2, x2, y2)
                // Redact annotations use IC for the fill color after redaction.
                if a.opt.InteriorColor != nil </span><span class="cov8" title="1">{
                        ic := a.opt.InteriorColor
                        fmt.Fprintf(w, "/IC [%.4f %.4f %.4f]\n",
                                float64(ic[0])/255.0, float64(ic[1])/255.0, float64(ic[2])/255.0)
                }</span>
                <span class="cov8" title="1">if a.opt.OverlayText != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/OverlayText (%s)\n", escapeAnnotString(a.opt.OverlayText))
                        fmt.Fprintf(w, "/DA (/Helv %.0f Tf %.4f %.4f %.4f rg)\n",
                                a.opt.FontSize, cr, cg, cb)
                }</span>
                <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Contents (%s)\n", content)
                }</span>
        }

        // Opacity via CA entry.
        <span class="cov8" title="1">if a.opt.Opacity &lt; 1.0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/CA %.4f\n", a.opt.Opacity)
        }</span>

        // Border.
        <span class="cov8" title="1">fmt.Fprintf(w, "/Border [0 0 %.0f]\n", a.opt.BorderWidth)

        // Flags: Print (bit 3).
        io.WriteString(w, "/F 4\n")

        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// writeLineEndings writes the /LE entry for Line and Polyline annotations.
func (a annotationObj) writeLineEndings(w io.Writer) <span class="cov8" title="1">{
        le0 := a.opt.LineEndingStyles[0]
        le1 := a.opt.LineEndingStyles[1]
        if le0 == "" </span><span class="cov8" title="1">{
                le0 = LineEndNone
        }</span>
        <span class="cov8" title="1">if le1 == "" </span><span class="cov8" title="1">{
                le1 = LineEndNone
        }</span>
        <span class="cov8" title="1">if le0 != LineEndNone || le1 != LineEndNone </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/LE [/%s /%s]\n", le0, le1)
        }</span>
}

// escapeAnnotString escapes special characters in PDF annotation strings.
func escapeAnnotString(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "\\", "\\\\")
        s = strings.ReplaceAll(s, "(", "\\(")
        s = strings.ReplaceAll(s, ")", "\\)")
        s = strings.ReplaceAll(s, "\r", "\\r")
        s = strings.ReplaceAll(s, "\n", "\\n")
        return s
}</span>

// AddAnnotation adds an annotation to the current page.
//
// Supported annotation types:
//   - AnnotText: Sticky note (comment icon)
//   - AnnotHighlight: Highlight markup
//   - AnnotUnderline: Underline markup
//   - AnnotStrikeOut: Strikeout markup
//   - AnnotSquare: Rectangle shape
//   - AnnotCircle: Circle/ellipse shape
//   - AnnotFreeText: Text directly on the page
//   - AnnotInk: Freehand drawing
//   - AnnotPolyline: Connected line segments
//   - AnnotPolygon: Closed polygon shape
//   - AnnotLine: Single line with endpoints
//   - AnnotStamp: Predefined stamp
//   - AnnotSquiggly: Wavy underline
//   - AnnotCaret: Insertion point marker
//   - AnnotFileAttachment: File attachment
//   - AnnotRedact: Redaction marker
//
// Example:
//
//        pdf.AddAnnotation(gopdf.AnnotationOption{
//            Type:    gopdf.AnnotText,
//            X:       100,
//            Y:       100,
//            W:       24,
//            H:       24,
//            Title:   "Reviewer",
//            Content: "Please check this section.",
//            Color:   [3]uint8{255, 255, 0},
//        })
func (gp *GoPdf) AddAnnotation(opt AnnotationOption) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;opt.X, &amp;opt.Y, &amp;opt.W, &amp;opt.H)

        // Convert points in InkList.
        for i := range opt.InkList </span><span class="cov8" title="1">{
                for j := range opt.InkList[i] </span><span class="cov8" title="1">{
                        gp.UnitsToPointsVar(&amp;opt.InkList[i][j].X, &amp;opt.InkList[i][j].Y)
                }</span>
        }
        // Convert Vertices.
        <span class="cov8" title="1">for i := range opt.Vertices </span><span class="cov8" title="1">{
                gp.UnitsToPointsVar(&amp;opt.Vertices[i].X, &amp;opt.Vertices[i].Y)
        }</span>
        // Convert Line endpoints.
        <span class="cov8" title="1">if opt.Type == AnnotLine </span><span class="cov8" title="1">{
                gp.UnitsToPointsVar(&amp;opt.LineStart.X, &amp;opt.LineStart.Y, &amp;opt.LineEnd.X, &amp;opt.LineEnd.Y)
        }</span>

        <span class="cov8" title="1">page := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)
        objIdx := gp.addObj(annotationObj{
                opt: opt,
                getRoot: func() *GoPdf </span><span class="cov8" title="1">{
                        return gp
                }</span>,
        })
        <span class="cov8" title="1">page.LinkObjIds = append(page.LinkObjIds, objIdx+1)</span>
}

// AddTextAnnotation is a convenience method for adding a sticky note annotation.
func (gp *GoPdf) AddTextAnnotation(x, y float64, title, content string) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:    AnnotText,
                X:       x,
                Y:       y,
                W:       24,
                H:       24,
                Title:   title,
                Content: content,
        })
}</span>

// AddHighlightAnnotation is a convenience method for highlighting a rectangular area.
func (gp *GoPdf) AddHighlightAnnotation(x, y, w, h float64, color [3]uint8) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:  AnnotHighlight,
                X:     x,
                Y:     y,
                W:     w,
                H:     h,
                Color: color,
        })
}</span>

// AddFreeTextAnnotation is a convenience method for adding text directly on the page.
func (gp *GoPdf) AddFreeTextAnnotation(x, y, w, h float64, text string, fontSize float64) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:     AnnotFreeText,
                X:        x,
                Y:        y,
                W:        w,
                H:        h,
                Content:  text,
                FontSize: fontSize,
        })
}</span>

// AddInkAnnotation adds a freehand ink annotation with one or more strokes.
func (gp *GoPdf) AddInkAnnotation(x, y, w, h float64, strokes [][]Point, color [3]uint8) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:    AnnotInk,
                X:       x,
                Y:       y,
                W:       w,
                H:       h,
                InkList: strokes,
                Color:   color,
        })
}</span>

// AddPolylineAnnotation adds a polyline (open path) annotation.
func (gp *GoPdf) AddPolylineAnnotation(x, y, w, h float64, vertices []Point, color [3]uint8) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:     AnnotPolyline,
                X:        x,
                Y:        y,
                W:        w,
                H:        h,
                Vertices: vertices,
                Color:    color,
        })
}</span>

// AddPolygonAnnotation adds a closed polygon annotation.
func (gp *GoPdf) AddPolygonAnnotation(x, y, w, h float64, vertices []Point, color [3]uint8) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:     AnnotPolygon,
                X:        x,
                Y:        y,
                W:        w,
                H:        h,
                Vertices: vertices,
                Color:    color,
        })
}</span>

// AddLineAnnotation adds a line annotation between two points.
func (gp *GoPdf) AddLineAnnotation(start, end Point, color [3]uint8) <span class="cov8" title="1">{
        // Compute bounding rect from the two endpoints.
        minX, maxX := start.X, end.X
        if end.X &lt; minX </span><span class="cov8" title="1">{
                minX = end.X
        }</span>
        <span class="cov8" title="1">if start.X &gt; maxX </span><span class="cov8" title="1">{
                maxX = start.X
        }</span>
        <span class="cov8" title="1">minY, maxY := start.Y, end.Y
        if end.Y &lt; minY </span><span class="cov8" title="1">{
                minY = end.Y
        }</span>
        <span class="cov8" title="1">if start.Y &gt; maxY </span><span class="cov8" title="1">{
                maxY = start.Y
        }</span>
        <span class="cov8" title="1">gp.AddAnnotation(AnnotationOption{
                Type:      AnnotLine,
                X:         minX,
                Y:         minY,
                W:         maxX - minX,
                H:         maxY - minY,
                LineStart: start,
                LineEnd:   end,
                Color:     color,
        })</span>
}

// AddStampAnnotation adds a stamp annotation (e.g. "Approved", "Draft").
func (gp *GoPdf) AddStampAnnotation(x, y, w, h float64, stamp StampName) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:  AnnotStamp,
                X:     x,
                Y:     y,
                W:     w,
                H:     h,
                Stamp: stamp,
        })
}</span>

// AddSquigglyAnnotation adds a wavy underline annotation.
func (gp *GoPdf) AddSquigglyAnnotation(x, y, w, h float64, color [3]uint8) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:  AnnotSquiggly,
                X:     x,
                Y:     y,
                W:     w,
                H:     h,
                Color: color,
        })
}</span>

// AddCaretAnnotation adds a caret (insertion point) annotation.
func (gp *GoPdf) AddCaretAnnotation(x, y, w, h float64, content string) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:    AnnotCaret,
                X:       x,
                Y:       y,
                W:       w,
                H:       h,
                Content: content,
        })
}</span>

// AddFileAttachmentAnnotation adds a file attachment annotation.
func (gp *GoPdf) AddFileAttachmentAnnotation(x, y float64, fileName string, fileData []byte, content string) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:     AnnotFileAttachment,
                X:        x,
                Y:        y,
                W:        24,
                H:        24,
                FileName: fileName,
                FileData: fileData,
                Content:  content,
        })
}</span>

// AddRedactAnnotation adds a redaction annotation marking an area for content removal.
// Call ApplyRedactions() to permanently remove the content.
func (gp *GoPdf) AddRedactAnnotation(x, y, w, h float64, overlayText string) <span class="cov8" title="1">{
        gp.AddAnnotation(AnnotationOption{
                Type:        AnnotRedact,
                X:           x,
                Y:           y,
                W:           w,
                H:           h,
                OverlayText: overlayText,
                Color:       [3]uint8{255, 0, 0},
        })
}</span>

// GetAnnotations returns all annotations on the current page.
func (gp *GoPdf) GetAnnotations() []AnnotationInfo <span class="cov8" title="1">{
        page := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)
        var result []AnnotationInfo
        for i, objID := range page.LinkObjIds </span><span class="cov8" title="1">{
                obj := gp.pdfObjs[objID-1]
                if aObj, ok := obj.(annotationObj); ok </span><span class="cov8" title="1">{
                        result = append(result, AnnotationInfo{
                                Index:  i,
                                Type:   aObj.opt.Type,
                                Option: aObj.opt,
                        })
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetAnnotationsOnPage returns all annotations on the specified page (1-indexed).
func (gp *GoPdf) GetAnnotationsOnPage(pageIndex int) []AnnotationInfo <span class="cov8" title="1">{
        page := gp.findPageObj(pageIndex)
        if page == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var result []AnnotationInfo
        for i, objID := range page.LinkObjIds </span><span class="cov8" title="1">{
                obj := gp.pdfObjs[objID-1]
                if aObj, ok := obj.(annotationObj); ok </span><span class="cov8" title="1">{
                        result = append(result, AnnotationInfo{
                                Index:  i,
                                Type:   aObj.opt.Type,
                                Option: aObj.opt,
                        })
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// DeleteAnnotation removes the annotation at the given index from the current page.
// Returns true if the annotation was removed.
func (gp *GoPdf) DeleteAnnotation(index int) bool <span class="cov8" title="1">{
        page := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)
        if index &lt; 0 || index &gt;= len(page.LinkObjIds) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">page.LinkObjIds = append(page.LinkObjIds[:index], page.LinkObjIds[index+1:]...)
        return true</span>
}

// DeleteAnnotationOnPage removes the annotation at the given index from the specified page (1-indexed).
// Returns true if the annotation was removed.
func (gp *GoPdf) DeleteAnnotationOnPage(pageIndex, annotIndex int) bool <span class="cov8" title="1">{
        page := gp.findPageObj(pageIndex)
        if page == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if annotIndex &lt; 0 || annotIndex &gt;= len(page.LinkObjIds) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">page.LinkObjIds = append(page.LinkObjIds[:annotIndex], page.LinkObjIds[annotIndex+1:]...)
        return true</span>
}

// ApplyRedactions removes all redaction annotations from the current page.
// In a full implementation this would also remove the underlying content;
// currently it removes the redact annotation markers so they no longer appear.
func (gp *GoPdf) ApplyRedactions() int <span class="cov8" title="1">{
        page := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)
        return applyRedactionsOnPage(gp, page)
}</span>

// ApplyRedactionsOnPage applies redactions on the specified page (1-indexed).
func (gp *GoPdf) ApplyRedactionsOnPage(pageIndex int) int <span class="cov8" title="1">{
        page := gp.findPageObj(pageIndex)
        if page == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return applyRedactionsOnPage(gp, page)</span>
}

func applyRedactionsOnPage(gp *GoPdf, page *PageObj) int <span class="cov8" title="1">{
        kept := make([]int, 0, len(page.LinkObjIds))
        removed := 0
        for _, objID := range page.LinkObjIds </span><span class="cov8" title="1">{
                obj := gp.pdfObjs[objID-1]
                if aObj, ok := obj.(annotationObj); ok &amp;&amp; aObj.opt.Type == AnnotRedact </span><span class="cov8" title="1">{
                        removed++
                        continue</span>
                }
                <span class="cov8" title="1">kept = append(kept, objID)</span>
        }
        <span class="cov8" title="1">page.LinkObjIds = kept
        return removed</span>
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package gopdf

import "errors"

var ErrAnnotationNotFound = errors.New("annotation not found at specified index")

// ModifyAnnotation modifies an existing annotation on the specified page.
// pageIndex is 0-based, annotIndex is the position in the page's annotation list.
// Only non-zero fields in the provided option are applied.
//
// Example:
//
//        pdf.ModifyAnnotation(0, 0, gopdf.AnnotationOption{
//            Content: "Updated note",
//            Color:   [3]uint8{255, 0, 0},
//        })
func (gp *GoPdf) ModifyAnnotation(pageIndex, annotIndex int, opt AnnotationOption) error <span class="cov8" title="1">{
        page := gp.getPageByIndex(pageIndex)
        if page == nil </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">if annotIndex &lt; 0 || annotIndex &gt;= len(page.LinkObjIds) </span><span class="cov8" title="1">{
                return ErrAnnotationNotFound
        }</span>

        <span class="cov8" title="1">objID := page.LinkObjIds[annotIndex]
        objIdx := objID - 1
        if objIdx &lt; 0 || objIdx &gt;= len(gp.pdfObjs) </span><span class="cov0" title="0">{
                return ErrAnnotationNotFound
        }</span>

        <span class="cov8" title="1">annot, ok := gp.pdfObjs[objIdx].(annotationObj)
        if !ok </span><span class="cov8" title="1">{
                return ErrAnnotationNotFound
        }</span>

        // Apply non-zero fields from opt.
        <span class="cov8" title="1">if opt.Content != "" </span><span class="cov8" title="1">{
                annot.opt.Content = opt.Content
        }</span>
        <span class="cov8" title="1">if opt.Title != "" </span><span class="cov8" title="1">{
                annot.opt.Title = opt.Title
        }</span>
        <span class="cov8" title="1">if opt.Color != [3]uint8{0, 0, 0} </span><span class="cov8" title="1">{
                annot.opt.Color = opt.Color
        }</span>
        <span class="cov8" title="1">if opt.Opacity &gt; 0 </span><span class="cov8" title="1">{
                annot.opt.Opacity = opt.Opacity
        }</span>
        <span class="cov8" title="1">if opt.FontSize &gt; 0 </span><span class="cov8" title="1">{
                annot.opt.FontSize = opt.FontSize
        }</span>
        <span class="cov8" title="1">if opt.BorderWidth &gt; 0 </span><span class="cov8" title="1">{
                annot.opt.BorderWidth = opt.BorderWidth
        }</span>
        <span class="cov8" title="1">if opt.X != 0 || opt.Y != 0 </span><span class="cov8" title="1">{
                if opt.X != 0 </span><span class="cov8" title="1">{
                        annot.opt.X = opt.X
                }</span>
                <span class="cov8" title="1">if opt.Y != 0 </span><span class="cov8" title="1">{
                        annot.opt.Y = opt.Y
                }</span>
        }
        <span class="cov8" title="1">if opt.W &gt; 0 </span><span class="cov8" title="1">{
                annot.opt.W = opt.W
        }</span>
        <span class="cov8" title="1">if opt.H &gt; 0 </span><span class="cov8" title="1">{
                annot.opt.H = opt.H
        }</span>
        <span class="cov8" title="1">if opt.InteriorColor != nil </span><span class="cov8" title="1">{
                annot.opt.InteriorColor = opt.InteriorColor
        }</span>
        <span class="cov8" title="1">if opt.OverlayText != "" </span><span class="cov8" title="1">{
                annot.opt.OverlayText = opt.OverlayText
        }</span>

        <span class="cov8" title="1">gp.pdfObjs[objIdx] = annot
        return nil</span>
}

// getPageByIndex returns the PageObj at the given 0-based page index.
func (gp *GoPdf) getPageByIndex(pageIndex int) *PageObj <span class="cov8" title="1">{
        pageCount := 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if p, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        if pageCount == pageIndex </span><span class="cov8" title="1">{
                                return p
                        }</span>
                        <span class="cov8" title="1">pageCount++</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gopdf

// Harf is the Arabic meaning of Letter, Harf holds the Arabic character with its different representation forms (glyphs).
type Harf struct {
        Unicode, Isolated, Beginning, Middle, Final rune
}

// Arabic Alphabet using the new Harf type.
var (
        ALEF_HAMZA_ABOVE = Harf{ // Ø£
                Unicode:   '\u0623',
                Isolated:  '\ufe83',
                Beginning: '\u0623',
                Middle:    '\ufe84',
                Final:     '\ufe84'}

        ALEF = Harf{ // Ø§
                Unicode:   '\u0627',
                Isolated:  '\ufe8d',
                Beginning: '\u0627',
                Middle:    '\ufe8e',
                Final:     '\ufe8e'}

        ALEF_MADDA_ABOVE = Harf{ // Ø¢
                Unicode:   '\u0622',
                Isolated:  '\ufe81',
                Beginning: '\u0622',
                Middle:    '\ufe82',
                Final:     '\ufe82'}

        HAMZA = Harf{ // Ø¡
                Unicode:   '\u0621',
                Isolated:  '\ufe80',
                Beginning: '\u0621',
                Middle:    '\u0621',
                Final:     '\u0621'}

        WAW_HAMZA_ABOVE = Harf{ // Ø¤
                Unicode:   '\u0624',
                Isolated:  '\ufe85',
                Beginning: '\u0624',
                Middle:    '\ufe86',
                Final:     '\ufe86'}

        ALEF_HAMZA_BELOW = Harf{ // Ø£
                Unicode:   '\u0625',
                Isolated:  '\ufe87',
                Beginning: '\u0625',
                Middle:    '\ufe88',
                Final:     '\ufe88'}

        YEH_HAMZA_ABOVE = Harf{ // Ø¦
                Unicode:   '\u0626',
                Isolated:  '\ufe89',
                Beginning: '\ufe8b',
                Middle:    '\ufe8c',
                Final:     '\ufe8a'}

        BEH = Harf{ // Ø¨
                Unicode:   '\u0628',
                Isolated:  '\ufe8f',
                Beginning: '\ufe91',
                Middle:    '\ufe92',
                Final:     '\ufe90'}

        PEH = Harf{ // Ù¾
                Unicode:   '\u067e',
                Isolated:  '\ufb56',
                Beginning: '\ufb58',
                Middle:    '\ufb59',
                Final:     '\ufb57'}

        TEH = Harf{ // Øª
                Unicode:   '\u062A',
                Isolated:  '\ufe95',
                Beginning: '\ufe97',
                Middle:    '\ufe98',
                Final:     '\ufe96'}

        TEH_MARBUTA = Harf{ // Ø©
                Unicode:   '\u0629',
                Isolated:  '\ufe93',
                Beginning: '\u0629',
                Middle:    '\u0629',
                Final:     '\ufe94'}

        THEH = Harf{ // Ø«
                Unicode:   '\u062b',
                Isolated:  '\ufe99',
                Beginning: '\ufe9b',
                Middle:    '\ufe9c',
                Final:     '\ufe9a'}

        JEEM = Harf{ // Ø¬
                Unicode:   '\u062c', // Ø¬
                Isolated:  '\ufe9d', // Ø¬
                Beginning: '\ufe9f', // Ø¬Ù€
                Middle:    '\ufea0', // Ù€Ø¬Ù€
                Final:     '\ufe9e'} // Ù€Ø¬

        TCHEH = Harf{ // Ú†
                Unicode:   '\u0686',
                Isolated:  '\ufb7a',
                Beginning: '\ufb7c',
                Middle:    '\ufb7d',
                Final:     '\ufb7b'}

        HAH = Harf{ // Ø­
                Unicode:   '\u062d',
                Isolated:  '\ufea1',
                Beginning: '\ufea3',
                Middle:    '\ufea4',
                Final:     '\ufea2'}

        KHAH = Harf{ // Ø®
                Unicode:   '\u062e',
                Isolated:  '\ufea5',
                Beginning: '\ufea7',
                Middle:    '\ufea8',
                Final:     '\ufea6'}

        DAL = Harf{ // Ø¯
                Unicode:   '\u062f',
                Isolated:  '\ufea9',
                Beginning: '\u062f',
                Middle:    '\ufeaa',
                Final:     '\ufeaa'}

        THAL = Harf{ // Ø°
                Unicode:   '\u0630',
                Isolated:  '\ufeab',
                Beginning: '\u0630',
                Middle:    '\ufeac',
                Final:     '\ufeac'}

        REH = Harf{ // Ø±
                Unicode:   '\u0631',
                Isolated:  '\ufead',
                Beginning: '\u0631',
                Middle:    '\ufeae',
                Final:     '\ufeae'}

        JEH = Harf{
                Unicode:   '\u0698',
                Isolated:  '\ufb8a',
                Beginning: '\u0698',
                Middle:    '\ufb8b',
                Final:     '\ufb8b',
        }

        ZAIN = Harf{ // Ø²
                Unicode:   '\u0632',
                Isolated:  '\ufeaf',
                Beginning: '\u0632',
                Middle:    '\ufeb0',
                Final:     '\ufeb0'}

        SEEN = Harf{ // Ø³
                Unicode:   '\u0633',
                Isolated:  '\ufeb1',
                Beginning: '\ufeb3',
                Middle:    '\ufeb4',
                Final:     '\ufeb2'}

        SHEEN = Harf{ // Ø´
                Unicode:   '\u0634',
                Isolated:  '\ufeb5',
                Beginning: '\ufeb7',
                Middle:    '\ufeb8',
                Final:     '\ufeb6'}

        SAD = Harf{ // Øµ
                Unicode:   '\u0635',
                Isolated:  '\ufeb9',
                Beginning: '\ufebb',
                Middle:    '\ufebc',
                Final:     '\ufeba'}

        DAD = Harf{ // Ø¶
                Unicode:   '\u0636',
                Isolated:  '\ufebd',
                Beginning: '\ufebf',
                Middle:    '\ufec0',
                Final:     '\ufebe'}

        TAH = Harf{ // Ø·
                Unicode:   '\u0637',
                Isolated:  '\ufec1',
                Beginning: '\ufec3',
                Middle:    '\ufec4',
                Final:     '\ufec2'}

        ZAH = Harf{ // Ø¸
                Unicode:   '\u0638',
                Isolated:  '\ufec5',
                Beginning: '\ufec7',
                Middle:    '\ufec8',
                Final:     '\ufec6'}

        AIN = Harf{ // Ø¹
                Unicode:   '\u0639',
                Isolated:  '\ufec9',
                Beginning: '\ufecb',
                Middle:    '\ufecc',
                Final:     '\ufeca'}

        GHAIN = Harf{ // Øº
                Unicode:   '\u063a',
                Isolated:  '\ufecd',
                Beginning: '\ufecf',
                Middle:    '\ufed0',
                Final:     '\ufece'}

        FEH = Harf{ // Ù
                Unicode:   '\u0641',
                Isolated:  '\ufed1',
                Beginning: '\ufed3',
                Middle:    '\ufed4',
                Final:     '\ufed2'}

        QAF = Harf{ // Ù‚
                Unicode:   '\u0642',
                Isolated:  '\ufed5',
                Beginning: '\ufed7',
                Middle:    '\ufed8',
                Final:     '\ufed6'}

        KAF = Harf{ // Ùƒ
                Unicode:   '\u0643',
                Isolated:  '\ufed9',
                Beginning: '\ufedb',
                Middle:    '\ufedc',
                Final:     '\ufeda'}

        KEHEH = Harf{ // Ú©
                Unicode:   '\u06a9',
                Isolated:  '\ufb8e',
                Beginning: '\ufb90',
                Middle:    '\ufb91',
                Final:     '\ufb8f',
        }

        GAF = Harf{ // Ú¯
                Unicode:   '\u06af',
                Isolated:  '\ufb92',
                Beginning: '\ufb94',
                Middle:    '\ufb95',
                Final:     '\ufb93'}

        LAM = Harf{ // Ù„
                Unicode:   '\u0644',
                Isolated:  '\ufedd',
                Beginning: '\ufedf',
                Middle:    '\ufee0',
                Final:     '\ufede'}

        MEEM = Harf{ // Ù…
                Unicode:   '\u0645',
                Isolated:  '\ufee1',
                Beginning: '\ufee3',
                Middle:    '\ufee4',
                Final:     '\ufee2'}

        NOON = Harf{ // Ù†
                Unicode:   '\u0646',
                Isolated:  '\ufee5',
                Beginning: '\ufee7',
                Middle:    '\ufee8',
                Final:     '\ufee6'}

        HEH = Harf{ // Ù‡
                Unicode:   '\u0647',
                Isolated:  '\ufee9',
                Beginning: '\ufeeb',
                Middle:    '\ufeec',
                Final:     '\ufeea'}

        WAW = Harf{ // Ùˆ
                Unicode:   '\u0648',
                Isolated:  '\ufeed',
                Beginning: '\u0648',
                Middle:    '\ufeee',
                Final:     '\ufeee'}

        YEH = Harf{ // ÛŒ
                Unicode:   '\u06cc',
                Isolated:  '\ufbfc',
                Beginning: '\ufbfe',
                Middle:    '\ufbff',
                Final:     '\ufbfd'}

        ARABICYEH = Harf{ // ÙŠ
                Unicode:   '\u064a',
                Isolated:  '\ufef1',
                Beginning: '\ufef3',
                Middle:    '\ufef4',
                Final:     '\ufef2'}

        ALEF_MAKSURA = Harf{ // Ù‰
                Unicode:   '\u0649',
                Isolated:  '\ufeef',
                Beginning: '\u0649',
                Middle:    '\ufef0',
                Final:     '\ufef0'}

        TATWEEL = Harf{ // Ù€
                Unicode:   '\u0640',
                Isolated:  '\u0640',
                Beginning: '\u0640',
                Middle:    '\u0640',
                Final:     '\u0640'}

        LAM_ALEF = Harf{ // Ù„Ø§
                Unicode:   '\ufefb',
                Isolated:  '\ufefb',
                Beginning: '\ufefb',
                Middle:    '\ufefc',
                Final:     '\ufefc'}

        LAM_ALEF_HAMZA_ABOVE = Harf{ // ï»·
                Unicode:   '\ufef7',
                Isolated:  '\ufef7',
                Beginning: '\ufef7',
                Middle:    '\ufef8',
                Final:     '\ufef8'}
)

var arabic_alphabet = map[rune]Harf{}

var arabicAlphabetCollection = []Harf{
        ALEF_HAMZA_ABOVE,
        ALEF,
        ALEF_MADDA_ABOVE,
        HAMZA,
        WAW_HAMZA_ABOVE,
        ALEF_HAMZA_BELOW,
        YEH_HAMZA_ABOVE,
        BEH,
        PEH,
        TEH,
        TEH_MARBUTA,
        THEH,
        JEEM,
        TCHEH,
        HAH,
        KHAH,
        DAL,
        THAL,
        REH,
        JEH,
        ZAIN,
        SEEN,
        SHEEN,
        SAD,
        DAD,
        TAH,
        ZAH,
        AIN,
        GHAIN,
        FEH,
        QAF,
        KAF,
        KEHEH,
        GAF,
        LAM,
        MEEM,
        NOON,
        HEH,
        WAW,
        YEH,
        ARABICYEH,
        ALEF_MAKSURA,
        TATWEEL,
        LAM_ALEF,
        LAM_ALEF_HAMZA_ABOVE,
}

func init() <span class="cov8" title="1">{
        for _, harf := range arabicAlphabetCollection </span><span class="cov8" title="1">{
                // Map all forms to the Harf struct
                arabic_alphabet[harf.Unicode] = harf
                arabic_alphabet[harf.Isolated] = harf
                arabic_alphabet[harf.Beginning] = harf
                arabic_alphabet[harf.Middle] = harf
                arabic_alphabet[harf.Final] = harf
        }</span>
}

// use map for faster lookups.
var rightJoiningOnlyLetters = map[Harf]bool{
        ALEF_HAMZA_ABOVE: true,
        ALEF_MADDA_ABOVE: true,
        ALEF:             true,
        HAMZA:            true,
        WAW_HAMZA_ABOVE:  true,
        ALEF_HAMZA_BELOW: true,
        TEH_MARBUTA:      true,
        DAL:              true,
        THAL:             true,
        REH:              true,
        ZAIN:             true,
        WAW:              true,
        ALEF_MAKSURA:     true}
</pre>
		
		<pre class="file" id="file5" style="display: none">package gopdf

func Reverse(s string) string <span class="cov8" title="1">{
        r := []rune(s)
        for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                r[i], r[j] = r[j], r[i]
        }</span>
        <span class="cov8" title="1">return string(r)</span>
}

func getHarf(char rune) Harf <span class="cov8" title="1">{
        for _, s := range arabic_alphabet </span><span class="cov8" title="1">{
                if s.equals(char) </span><span class="cov8" title="1">{
                        return s
                }</span>
        }
        <span class="cov8" title="1">return Harf{Unicode: char, Isolated: char, Middle: char, Final: char}</span>
}

// equals() return if true if the given Arabic char is alphabetically equal to
// the current Harf regardless its shape
func (c *Harf) equals(char rune) bool <span class="cov8" title="1">{
        switch char </span>{
        case c.Unicode:<span class="cov8" title="1">
                return true</span>
        case c.Beginning:<span class="cov8" title="1">
                return true</span>
        case c.Isolated:<span class="cov8" title="1">
                return true</span>
        case c.Middle:<span class="cov8" title="1">
                return true</span>
        case c.Final:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// This checks the Harf place as it decide how will be the Harf Shape
func getCharShape(previousChar, currentChar, nextChar rune) rune <span class="cov8" title="1">{
        shape := currentChar
        nextArabic := false
        previousArabic := false

        if _, ok := arabic_alphabet[previousChar]; ok </span><span class="cov8" title="1">{
                previousArabic = true
        }</span>

        <span class="cov8" title="1">if _, ok := arabic_alphabet[nextChar]; ok </span><span class="cov8" title="1">{
                nextArabic = true
        }</span>

        <span class="cov8" title="1">if _, ok := arabic_alphabet[currentChar]; !ok </span><span class="cov8" title="1">{
                return shape
        }</span>

        <span class="cov8" title="1">if previousArabic &amp;&amp; nextArabic </span><span class="cov8" title="1">{ // in middle
                for s := range rightJoiningOnlyLetters </span><span class="cov8" title="1">{ // if its an Harf which is must be separated
                        if s.equals(previousChar) </span><span class="cov8" title="1">{
                                return getHarf(currentChar).Beginning // return the default shape
                        }</span>
                }
                <span class="cov8" title="1">return getHarf(currentChar).Middle</span>
        }

        <span class="cov8" title="1">if nextArabic </span><span class="cov8" title="1">{ // first letter and in start of a word
                return getHarf(currentChar).Beginning
        }</span>

        <span class="cov8" title="1">if previousArabic </span><span class="cov8" title="1">{ // final letter as it's in the end of a word
                for s := range rightJoiningOnlyLetters </span><span class="cov8" title="1">{
                        if s.equals(previousChar) </span><span class="cov8" title="1">{
                                return getHarf(currentChar).Isolated
                        }</span>
                }
                <span class="cov8" title="1">return getHarf(currentChar).Final</span>
        }

        <span class="cov8" title="1">if !previousArabic &amp;&amp; !nextArabic </span><span class="cov8" title="1">{ // single isolated letter
                return getHarf(currentChar).Isolated
        }</span>

        <span class="cov0" title="0">return shape</span>
}

func ToArabic(text string) string <span class="cov8" title="1">{
        var nextHarf, previousHarf rune

        hrof := []rune(text)    // hrof is arabic letters
        hrofLength := len(hrof) // hrof length is the number of arabic letters

        arabicSentence := make([]rune, 0, hrofLength)
        for i := 0; i &lt; hrofLength; i++ </span><span class="cov8" title="1">{
                currentHarf := hrof[i]

                if i == 0 </span><span class="cov8" title="1">{
                        previousHarf = 0
                }</span> else<span class="cov8" title="1"> {
                        previousHarf = hrof[i-1]
                }</span>

                <span class="cov8" title="1">if i == hrofLength-1 </span><span class="cov8" title="1">{
                        nextHarf = 0
                }</span> else<span class="cov8" title="1"> {
                        nextHarf = hrof[i+1]
                }</span>

                // Lam-Alef Ligature Check
                <span class="cov8" title="1">if currentHarf == LAM.Unicode &amp;&amp; nextHarf != 0 </span><span class="cov8" title="1">{
                        var ligatureHarf rune
                        foundLigature := false
                        switch nextHarf </span>{
                        case ALEF.Unicode:<span class="cov8" title="1">
                                ligatureHarf = LAM_ALEF.Unicode
                                foundLigature = true</span>
                        case ALEF_HAMZA_ABOVE.Unicode:<span class="cov0" title="0">
                                ligatureHarf = LAM_ALEF_HAMZA_ABOVE.Unicode
                                foundLigature = true</span>
                        }
                        <span class="cov8" title="1">if foundLigature </span><span class="cov8" title="1">{
                                currentHarf = ligatureHarf
                                i++
                                // We need to update nextHarf to the one *after* the Alef for correct shaping of the ligature itself
                                if i == hrofLength-1 </span><span class="cov8" title="1">{
                                        nextHarf = 0
                                }</span> else<span class="cov8" title="1"> {
                                        nextHarf = hrof[i+1]
                                }</span>
                        }
                }

                <span class="cov8" title="1">harfShape := getCharShape(previousHarf, currentHarf, nextHarf)
                arabicSentence = append(arabicSentence, harfShape)</span>
        }
        <span class="cov8" title="1">arabicSentenceRTL := Reverse(string(arabicSentence))
        return arabicSentenceRTL</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "math"
)

// writeArcSegments approximates a circular arc using cubic BÃ©zier curves.
// Each segment covers at most 90 degrees. The arc goes from startRad to endRad
// counter-clockwise (in standard math coordinates; PDF y-axis is already handled
// by the caller flipping cy).
//
// cx, cy: center in PDF coordinates (y already flipped)
// r: radius
// startRad, endRad: angles in radians
func writeArcSegments(w io.Writer, cx, cy, r, startRad, endRad float64) <span class="cov8" title="1">{
        // Normalize so we always sweep in the positive direction
        sweep := endRad - startRad
        if sweep &lt; 0 </span><span class="cov8" title="1">{
                sweep += 2 * math.Pi
        }</span>
        <span class="cov8" title="1">if sweep == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Split into segments of at most 90 degrees (Ï€/2)
        <span class="cov8" title="1">maxSeg := math.Pi / 2
        nSegs := int(math.Ceil(sweep / maxSeg))
        segAngle := sweep / float64(nSegs)

        angle := startRad
        for i := 0; i &lt; nSegs; i++ </span><span class="cov8" title="1">{
                nextAngle := angle + segAngle
                writeArcBezier(w, cx, cy, r, angle, nextAngle)
                angle = nextAngle
        }</span>
}

// writeArcBezier writes a single cubic BÃ©zier curve approximating a circular arc
// from angle a1 to a2 (in radians). The arc must be &lt;= 90 degrees.
// Uses the standard BÃ©zier approximation for circular arcs.
func writeArcBezier(w io.Writer, cx, cy, r, a1, a2 float64) <span class="cov8" title="1">{
        // Half-angle
        halfAngle := (a2 - a1) / 2
        // BÃ©zier control point distance factor
        // k = (4/3) * tan(halfAngle)
        k := (4.0 / 3.0) * math.Tan(halfAngle)

        // Start point (already drawn to by moveto/lineto)
        // End point
        ex := cx + r*math.Cos(a2)
        ey := cy - r*math.Sin(a2)

        // Control point 1: perpendicular to radius at start
        cp1x := cx + r*(math.Cos(a1)-k*math.Sin(a1))
        cp1y := cy - r*(math.Sin(a1)+k*math.Cos(a1))

        // Control point 2: perpendicular to radius at end (opposite direction)
        cp2x := cx + r*(math.Cos(a2)+k*math.Sin(a2))
        cp2y := cy - r*(math.Sin(a2)-k*math.Cos(a2))

        fmt.Fprintf(w, "%.2f %.2f %.2f %.2f %.2f %.2f c\n",
                cp1x, cp1y, cp2x, cp2y, ex, ey)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package gopdf

import (
        "errors"
        "fmt"
)

var (
        ErrBookmarkNotFound = errors.New("bookmark not found")
        ErrBookmarkOutOfRange = errors.New("bookmark index out of range")
)

// BookmarkStyle defines visual styling for a bookmark entry.
type BookmarkStyle struct {
        // Bold makes the bookmark title bold.
        Bold bool
        // Italic makes the bookmark title italic.
        Italic bool
        // Color is the bookmark text color [R, G, B] (0.0-1.0). Zero value = default (black).
        Color [3]float64
        // Collapsed controls whether child bookmarks are initially hidden.
        Collapsed bool
}

// ModifyBookmark modifies the title of a bookmark at the given 0-based index
// in the flat TOC list (as returned by GetTOC).
//
// Example:
//
//        pdf.ModifyBookmark(0, "New Chapter Title")
func (gp *GoPdf) ModifyBookmark(index int, newTitle string) error <span class="cov8" title="1">{
        outlineObjs := gp.getOutlineObjList()
        if index &lt; 0 || index &gt;= len(outlineObjs) </span><span class="cov8" title="1">{
                return ErrBookmarkOutOfRange
        }</span>
        <span class="cov8" title="1">outlineObjs[index].title = newTitle
        return nil</span>
}

// DeleteBookmark removes a bookmark at the given 0-based index in the flat
// TOC list. Child bookmarks are also removed.
//
// Example:
//
//        pdf.DeleteBookmark(2) // remove the 3rd bookmark
func (gp *GoPdf) DeleteBookmark(index int) error <span class="cov8" title="1">{
        outlineObjs := gp.getOutlineObjList()
        if index &lt; 0 || index &gt;= len(outlineObjs) </span><span class="cov8" title="1">{
                return ErrBookmarkOutOfRange
        }</span>

        <span class="cov8" title="1">target := outlineObjs[index]

        // Fix linked list: connect prev to next.
        if target.prev &gt; 0 </span><span class="cov8" title="1">{
                for _, o := range outlineObjs </span><span class="cov8" title="1">{
                        if o.index == target.prev </span><span class="cov8" title="1">{
                                o.next = target.next
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if target.next &gt; 0 </span><span class="cov8" title="1">{
                for _, o := range outlineObjs </span><span class="cov8" title="1">{
                        if o.index == target.next </span><span class="cov8" title="1">{
                                o.prev = target.prev
                                break</span>
                        }
                }
        }

        // Update parent's first/last if needed.
        <span class="cov8" title="1">if target.prev &lt;= 0 </span><span class="cov8" title="1">{
                // This was the first child â€” update parent's first.
                if target.parent == gp.indexOfOutlinesObj+1 </span><span class="cov0" title="0">{
                        gp.outlines.first = target.next
                }</span> else<span class="cov8" title="1"> {
                        for _, o := range outlineObjs </span><span class="cov8" title="1">{
                                if o.index == target.parent </span><span class="cov0" title="0">{
                                        o.first = target.next
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">if target.next &lt;= 0 </span><span class="cov8" title="1">{
                // This was the last child â€” update parent's last.
                if target.parent == gp.indexOfOutlinesObj+1 </span><span class="cov0" title="0">{
                        gp.outlines.last = target.prev
                }</span> else<span class="cov8" title="1"> {
                        for _, o := range outlineObjs </span><span class="cov8" title="1">{
                                if o.index == target.parent </span><span class="cov0" title="0">{
                                        o.last = target.prev
                                        break</span>
                                }
                        }
                }
        }

        // Null out the object.
        <span class="cov8" title="1">objIdx := target.index - 1 // convert 1-based to 0-based
        if objIdx &gt;= 0 &amp;&amp; objIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                gp.pdfObjs[objIdx] = nullObj{}
        }</span>
        <span class="cov8" title="1">gp.outlines.count--

        return nil</span>
}

// SetBookmarkStyle sets the visual style (color, bold, italic, collapsed)
// for a bookmark at the given 0-based index.
//
// Example:
//
//        pdf.SetBookmarkStyle(0, gopdf.BookmarkStyle{
//            Bold:   true,
//            Color:  [3]float64{1, 0, 0}, // red
//            Collapsed: true,
//        })
func (gp *GoPdf) SetBookmarkStyle(index int, style BookmarkStyle) error <span class="cov8" title="1">{
        outlineObjs := gp.getOutlineObjList()
        if index &lt; 0 || index &gt;= len(outlineObjs) </span><span class="cov8" title="1">{
                return ErrBookmarkOutOfRange
        }</span>
        <span class="cov8" title="1">outlineObjs[index].color = style.Color
        outlineObjs[index].bold = style.Bold
        outlineObjs[index].italic = style.Italic
        outlineObjs[index].collapsed = style.Collapsed
        return nil</span>
}

// getOutlineObjList returns all OutlineObj instances in document order.
func (gp *GoPdf) getOutlineObjList() []*OutlineObj <span class="cov8" title="1">{
        if gp.outlines == nil || gp.outlines.Count() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">outlineMap := make(map[int]*OutlineObj)
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if o, ok := obj.(*OutlineObj); ok </span><span class="cov8" title="1">{
                        outlineMap[i+1] = o
                }</span>
        }

        // Traverse in linked-list order starting from first.
        <span class="cov8" title="1">var result []*OutlineObj
        visited := make(map[int]bool)
        gp.collectOutlineObjs(outlineMap, gp.outlines.first, &amp;result, visited)
        return result</span>
}

func (gp *GoPdf) collectOutlineObjs(m map[int]*OutlineObj, objID int, result *[]*OutlineObj, visited map[int]bool) <span class="cov8" title="1">{
        if objID &lt;= 0 || visited[objID] </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">visited[objID] = true
        o, ok := m[objID]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">*result = append(*result, o)
        if o.first &gt; 0 </span><span class="cov0" title="0">{
                gp.collectOutlineObjs(m, o.first, result, visited)
        }</span>
        <span class="cov8" title="1">if o.next &gt; 0 </span><span class="cov8" title="1">{
                gp.collectOutlineObjs(m, o.next, result, visited)
        }</span>
}

// Ensure fmt is used.
var _ = fmt.Sprintf
</pre>
		
		<pre class="file" id="file8" style="display: none">package gopdf

type Box struct {
        Left, Top, Right, Bottom float64
        unitOverride             defaultUnitConfig
}

// UnitsToPoints converts the box coordinates to Points. When this is called it is assumed the values of the box are in Units
func (box *Box) UnitsToPoints(t int) (b *Box) <span class="cov8" title="1">{
        if box == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">unitCfg := defaultUnitConfig{Unit: t}
        if box.unitOverride.getUnit() != UnitUnset </span><span class="cov8" title="1">{
                unitCfg = box.unitOverride
        }</span>

        <span class="cov8" title="1">b = &amp;Box{
                Left:   box.Left,
                Top:    box.Top,
                Right:  box.Right,
                Bottom: box.Bottom,
        }
        unitsToPointsVar(unitCfg, &amp;b.Left, &amp;b.Top, &amp;b.Right, &amp;b.Bottom)
        return</span>
}

func (box *Box) unitsToPoints(unitCfg unitConfigurator) (b *Box) <span class="cov8" title="1">{
        if box == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if box.unitOverride.getUnit() != UnitUnset </span><span class="cov8" title="1">{
                unitCfg = box.unitOverride
        }</span>

        <span class="cov8" title="1">b = &amp;Box{
                Left:   box.Left,
                Top:    box.Top,
                Right:  box.Right,
                Bottom: box.Bottom,
        }
        unitsToPointsVar(unitCfg, &amp;b.Left, &amp;b.Top, &amp;b.Right, &amp;b.Bottom)
        return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package gopdf

// BreakMode type for text break modes.
type BreakMode int

const (
        // BreakModeStrict causes the text-line to break immediately in case the current character would not fit into
        // the processed text-line. The separator (if provided) will be attached accordingly as a line suffix
        // to stay within the defined width.
        BreakModeStrict BreakMode = iota

        // BreakModeIndicatorSensitive will try to break the current line based on the last index of a provided
        // BreakIndicator. If no indicator sensitive break can be performed a strict break will be performed,
        // potentially working with the given separator as a suffix.
        BreakModeIndicatorSensitive
)

var (
        // DefaultBreakOption will cause the text to break mid-word without any separator suffixes.
        DefaultBreakOption = BreakOption{
                Mode:           BreakModeStrict,
                BreakIndicator: 0,
                Separator:      "",
        }
)

// BreakOption allows to configure the behavior of splitting or breaking larger texts via SplitTextWithOption.
type BreakOption struct {
        // Mode defines the mode which should be used
        Mode BreakMode
        // BreakIndicator is taken into account when using indicator sensitive mode to avoid mid-word line breaks
        BreakIndicator rune
        // Separator will act as a suffix for mid-word breaks when using strict mode
        Separator string
}

func (bo BreakOption) HasSeparator() bool <span class="cov8" title="1">{
        return bo.Separator != ""
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package gopdf

// Buff for pdf content
type Buff struct {
        position int
        datas    []byte
}

// Write : write []byte to buffer
func (b *Buff) Write(p []byte) (int, error) <span class="cov8" title="1">{
        needed := b.position + len(p)
        if needed &gt; len(b.datas) </span><span class="cov8" title="1">{
                if needed &gt; cap(b.datas) </span><span class="cov8" title="1">{
                        // grow with exponential strategy to avoid O(nÂ²) behavior
                        newCap := cap(b.datas) * 2
                        if newCap &lt; needed </span><span class="cov8" title="1">{
                                newCap = needed
                        }</span>
                        <span class="cov8" title="1">newData := make([]byte, needed, newCap)
                        copy(newData, b.datas)
                        b.datas = newData</span>
                } else<span class="cov8" title="1"> {
                        b.datas = b.datas[:needed]
                }</span>
        }
        <span class="cov8" title="1">copy(b.datas[b.position:], p)
        b.position += len(p)
        return len(p), nil</span>
}

// Len : len of buffer
func (b *Buff) Len() int <span class="cov8" title="1">{
        return len(b.datas)
}</span>

// Bytes : get bytes
func (b *Buff) Bytes() []byte <span class="cov8" title="1">{
        return b.datas
}</span>

// Position : get current position
func (b *Buff) Position() int <span class="cov8" title="1">{
        return b.position
}</span>

// SetPosition : set current position
func (b *Buff) SetPosition(pos int) <span class="cov8" title="1">{
        b.position = pos
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package gopdf

import "io"

// WriteUInt32  writes a 32-bit unsigned integer value to w io.Writer
func WriteUInt32(w io.Writer, v uint) error <span class="cov8" title="1">{
        var buf [4]byte
        buf[0] = byte(v &gt;&gt; 24)
        buf[1] = byte(v &gt;&gt; 16)
        buf[2] = byte(v &gt;&gt; 8)
        buf[3] = byte(v)
        _, err := w.Write(buf[:])
        return err
}</span>

// WriteUInt16 writes a 16-bit unsigned integer value to w io.Writer
func WriteUInt16(w io.Writer, v uint) error <span class="cov8" title="1">{
        var buf [2]byte
        buf[0] = byte(v &gt;&gt; 8)
        buf[1] = byte(v)
        _, err := w.Write(buf[:])
        return err
}</span>

// WriteTag writes string value to w io.Writer
func WriteTag(w io.Writer, tag string) error <span class="cov8" title="1">{
        _, err := io.WriteString(w, tag)
        return err
}</span>

// WriteBytes writes []byte value to w io.Writer
func WriteBytes(w io.Writer, data []byte, offset int, count int) error <span class="cov8" title="1">{
        _, err := w.Write(data[offset : offset+count])
        return err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package gopdf

import (
        "bytes"
        "sync"
)

// buffer pool to reduce GC
var buffers = sync.Pool{
        // New is called when a new instance is needed
        New: func() interface{} <span class="cov8" title="1">{
                return new(bytes.Buffer)
        }</span>,
}

// GetBuffer fetches a buffer from the pool
func GetBuffer() *bytes.Buffer <span class="cov8" title="1">{
        return buffers.Get().(*bytes.Buffer)
}</span>

// PutBuffer returns a buffer to the pool
func PutBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.Reset()
        buffers.Put(buf)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheColorSpace struct {
        countOfSpaceColor int
}

func (c *cacheColorSpace) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "/CS%d CS 1.0000 SCN\n", c.countOfSpaceColor+1)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

const colorTypeStrokeRGB = "RG"

const colorTypeFillRGB = "rg"

type cacheContentColorRGB struct {
        colorType string
        r, g, b   uint8
}

func (c *cacheContentColorRGB) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.3f %.3f %.3f %s\n", float64(c.r)/255, float64(c.g)/255, float64(c.b)/255, c.colorType)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentClipPolygon struct {
        pageHeight float64
        points     []Point
}

func (c *cacheContentClipPolygon) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        for i, p := range c.points </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%.2f %.2f", p.X, c.pageHeight-p.Y)
                if i == 0 </span><span class="cov8" title="1">{ // first point
                        fmt.Fprint(w, " m ") // moveto: start new path
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprint(w, " l ") // lineto: draw line from current point
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprint(w, "h W n\n") // h=close path, W=clip, n=end path
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

const colorTypeStrokeCMYK = "K"

const colorTypeFillCMYK = "k"

type cacheContentColorCMYK struct {
        colorType  string
        c, m, y, k uint8
}

func (c *cacheContentColorCMYK) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.2f %.2f %.2f %.2f %s\n", float64(c.c)/100, float64(c.m)/100, float64(c.y)/100, float64(c.k)/100, c.colorType)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentCustomLineType struct {
        dashArray []float64
        dashPhase float64
}

func (c *cacheContentCustomLineType) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%0.2f %0.2f d\n", c.dashArray, c.dashPhase)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentSaveGraphicsState struct{}

func (c *cacheContentSaveGraphicsState) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprint(w, "q\n")
        return nil
}</span>

type cacheContentRestoreGraphicsState struct{}

func (c *cacheContentRestoreGraphicsState) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprint(w, "Q\n")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

const grayTypeFill = "g"
const grayTypeStroke = "G"

type cacheContentGray struct {
        grayType string
        scale    float64
}

func (c *cacheContentGray) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.2f %s\n", c.scale, c.grayType)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentImage struct {
        withMask         bool
        maskAngle        float64
        imageAngle       float64
        verticalFlip     bool
        horizontalFlip   bool
        index            int
        x                float64
        y                float64
        pageHeight       float64
        rect             Rect
        crop             *CropOptions
        extGStateIndexes []int
}

func (c *cacheContentImage) openImageRotateTrMt(writer io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        w := c.rect.W
        h := c.rect.H

        if c.crop != nil </span><span class="cov8" title="1">{
                w = c.crop.Width
                h = c.crop.Height
        }</span>

        <span class="cov8" title="1">x := c.x + w/2
        y := c.y + h/2

        cacheRotate := cacheContentRotate{
                x:          x,
                y:          y,
                pageHeight: c.pageHeight,
                angle:      c.imageAngle,
        }
        if err := cacheRotate.write(writer, protection); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *cacheContentImage) closeImageRotateTrMt(writer io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        resetCacheRotate := cacheContentRotate{isReset: true}

        return resetCacheRotate.write(writer, protection)
}</span>

func (c *cacheContentImage) computeMaskImageRotateTrMt() string <span class="cov8" title="1">{
        angle := c.maskAngle + c.imageAngle
        if angle == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">x := c.x + c.rect.W/2
        y := c.y + c.rect.H/2

        rotateMat := computeRotateTransformationMatrix(x, y, angle, c.pageHeight)

        return rotateMat</span>
}

func (c *cacheContentImage) write(writer io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        width := c.rect.W
        height := c.rect.H

        if !c.withMask </span><span class="cov8" title="1">{
                if err := c.openImageRotateTrMt(writer, protection); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">defer c.closeImageRotateTrMt(writer, protection)</span>
        }

        <span class="cov8" title="1">contentStream := "q\n"

        for _, extGStateIndex := range c.extGStateIndexes </span><span class="cov8" title="1">{
                contentStream += fmt.Sprintf("/GS%d gs\n", extGStateIndex)
        }</span>

        <span class="cov8" title="1">if c.horizontalFlip || c.verticalFlip </span><span class="cov8" title="1">{
                fh := "1"
                if c.horizontalFlip </span><span class="cov8" title="1">{
                        fh = "-1"
                }</span>

                <span class="cov8" title="1">fv := "1"
                if c.verticalFlip </span><span class="cov8" title="1">{
                        fv = "-1"
                }</span>

                <span class="cov8" title="1">contentStream += fmt.Sprintf("%s 0 0 %s 0 0 cm\n", fh, fv)</span>
        }

        <span class="cov8" title="1">x := c.x
        y := c.pageHeight - c.y

        if c.crop != nil </span><span class="cov8" title="1">{
                clippingX := x
                if c.horizontalFlip </span><span class="cov8" title="1">{
                        clippingX = -clippingX - c.crop.Width
                }</span>

                <span class="cov8" title="1">clippingY := y - c.crop.Height
                if c.verticalFlip </span><span class="cov8" title="1">{
                        clippingY = -clippingY - c.crop.Height
                }</span>

                <span class="cov8" title="1">contentStream += fmt.Sprintf("%0.2f %0.2f %0.2f %0.2f re W* n\n", clippingX, clippingY, c.crop.Width, c.crop.Height)

                x -= c.crop.X
                if c.horizontalFlip </span><span class="cov8" title="1">{
                        x = -x - width
                }</span>

                <span class="cov8" title="1">y += c.crop.Y - height
                if c.verticalFlip </span><span class="cov8" title="1">{
                        y = -y - height
                }</span>
        } else<span class="cov8" title="1"> {
                y -= height

                if c.horizontalFlip </span><span class="cov8" title="1">{
                        x = -x - width
                }</span>

                <span class="cov8" title="1">if c.verticalFlip </span><span class="cov8" title="1">{
                        y = -y - height
                }</span>
        }

        <span class="cov8" title="1">var maskImageRotateMat string
        if c.withMask </span><span class="cov8" title="1">{
                maskImageRotateMat = c.computeMaskImageRotateTrMt()
        }</span>

        <span class="cov8" title="1">contentStream += fmt.Sprintf("q\n %s %0.2f 0 0\n %0.2f %0.2f %0.2f cm /I%d Do \nQ\n", maskImageRotateMat, width, height, x, y, c.index+1)

        contentStream += "Q\n"

        if _, err := io.WriteString(writer, contentStream); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentImportedTemplate struct {
        pageHeight float64
        tplName    string
        scaleX     float64
        scaleY     float64
        tX         float64
        tY         float64
}

func (c *cacheContentImportedTemplate) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        c.tY += c.pageHeight
        fmt.Fprintf(w, "q 0 J 1 w 0 j 0 G 0 g q %.4F 0 0 %.4F %.4F %.4F cm %s Do Q Q\n", c.scaleX, c.scaleY, c.tX, c.tY, c.tplName)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentLine struct {
        pageHeight float64
        x1         float64
        y1         float64
        x2         float64
        y2         float64
        opts       lineOptions
}

func (c *cacheContentLine) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "q\n")
        for _, extGStateIndex := range c.opts.extGStateIndexes </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/GS%d gs\n", extGStateIndex)
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "%0.2f %0.2f m %0.2f %0.2f l S\n", c.x1, c.pageHeight-c.y1, c.x2, c.pageHeight-c.y2)
        fmt.Fprintf(w, "Q\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentLineType struct {
        lineType string
}

func (c *cacheContentLineType) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        switch c.lineType </span>{
        case "dashed":<span class="cov8" title="1">
                fmt.Fprint(w, "[5] 2 d\n")</span>
        case "dotted":<span class="cov8" title="1">
                fmt.Fprint(w, "[2 3] 11 d\n")</span>
        default:<span class="cov8" title="1">
                fmt.Fprint(w, "[] 0 d\n")</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentLineWidth struct {
        width float64
}

func (c *cacheContentLineWidth) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.2f w\n", c.width)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentOval struct {
        pageHeight float64
        x1         float64
        y1         float64
        x2         float64
        y2         float64
}

func (c *cacheContentOval) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{

        h := c.pageHeight
        x1 := c.x1
        y1 := c.y1
        x2 := c.x2
        y2 := c.y2

        cp := 0.55228                              // Magnification of the control point
        v1 := [2]float64{x1 + (x2-x1)/2, h - y2}   // Vertex of the lower
        v2 := [2]float64{x2, h - (y1 + (y2-y1)/2)} // .. Right
        v3 := [2]float64{x1 + (x2-x1)/2, h - y1}   // .. Upper
        v4 := [2]float64{x1, h - (y1 + (y2-y1)/2)} // .. Left

        fmt.Fprintf(w, "%0.2f %0.2f m\n", v1[0], v1[1])
        fmt.Fprintf(w,
                "%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\n",
                v1[0]+(x2-x1)/2*cp, v1[1], v2[0], v2[1]-(y2-y1)/2*cp, v2[0], v2[1],
        )
        fmt.Fprintf(w,
                "%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\n",
                v2[0], v2[1]+(y2-y1)/2*cp, v3[0]+(x2-x1)/2*cp, v3[1], v3[0], v3[1],
        )
        fmt.Fprintf(w,
                "%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\n",
                v3[0]-(x2-x1)/2*cp, v3[1], v4[0], v4[1]+(y2-y1)/2*cp, v4[0], v4[1],
        )
        fmt.Fprintf(w,
                "%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c S\n",
                v4[0], v4[1]-(y2-y1)/2*cp, v1[0]-(x2-x1)/2*cp, v1[1], v1[0], v1[1],
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentPolygon struct {
        pageHeight float64
        style      string
        points     []Point
        opts       polygonOptions
}

func (c *cacheContentPolygon) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{

        fmt.Fprintf(w, "q\n")
        for _, extGStateIndex := range c.opts.extGStateIndexes </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/GS%d gs\n", extGStateIndex)
        }</span>

        <span class="cov8" title="1">for i, point := range c.points </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%.2f %.2f", point.X, c.pageHeight-point.Y)
                if i == 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, " m ")
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(w, " l ")
                }</span>

        }

        <span class="cov8" title="1">if c.style == "F" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " f\n")
        }</span> else<span class="cov8" title="1"> if c.style == "FD" || c.style == "DF" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " b\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(w, " s\n")
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w, "Q\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentPolyline struct {
        pageHeight float64
        points     []Point
        opts       polylineOptions
}

type polylineOptions struct {
        extGStateIndexes []int
}

func (c *cacheContentPolyline) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        if len(c.points) &lt; 2 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w, "q\n")
        for _, extGStateIndex := range c.opts.extGStateIndexes </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/GS%d gs\n", extGStateIndex)
        }</span>

        <span class="cov8" title="1">for i, point := range c.points </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%.2f %.2f", point.X, c.pageHeight-point.Y)
                if i == 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, " m ")
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(w, " l ")
                }</span>
        }

        // Stroke only, no close path (unlike polygon which uses s/f/b)
        <span class="cov8" title="1">fmt.Fprintf(w, "S\n")
        fmt.Fprintf(w, "Q\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentRectangle struct {
        pageHeight       float64
        x                float64
        y                float64
        width            float64
        height           float64
        style            PaintStyle
        extGStateIndexes []int
}

func NewCacheContentRectangle(pageHeight float64, rectOpts DrawableRectOptions) ICacheContent <span class="cov8" title="1">{
        if rectOpts.PaintStyle == "" </span><span class="cov8" title="1">{
                rectOpts.PaintStyle = DrawPaintStyle
        }</span>

        <span class="cov8" title="1">return cacheContentRectangle{
                x:                rectOpts.X,
                y:                rectOpts.Y,
                width:            rectOpts.W,
                height:           rectOpts.H,
                pageHeight:       pageHeight,
                style:            rectOpts.PaintStyle,
                extGStateIndexes: rectOpts.extGStateIndexes,
        }</span>
}

func (c cacheContentRectangle) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        stream := "q\n"

        for _, extGStateIndex := range c.extGStateIndexes </span><span class="cov8" title="1">{
                stream += fmt.Sprintf("/GS%d gs\n", extGStateIndex)
        }</span>

        <span class="cov8" title="1">stream += fmt.Sprintf("%0.2f %0.2f %0.2f %0.2f re %s\n", c.x, c.pageHeight-c.y, c.width, c.height, c.style)

        stream += "Q\n"

        if _, err := io.WriteString(w, stream); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "math"
)

type cacheContentRotate struct {
        isReset     bool
        pageHeight  float64
        angle, x, y float64
}

func (cc *cacheContentRotate) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        if cc.isReset == true </span><span class="cov8" title="1">{
                if _, err := io.WriteString(w, "Q\n"); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">matrix := computeRotateTransformationMatrix(cc.x, cc.y, cc.angle, cc.pageHeight)
        contentStream := fmt.Sprintf("q\n %s", matrix)

        if _, err := io.WriteString(w, contentStream); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func computeRotateTransformationMatrix(x, y, degreeAngle, pageHeight float64) string <span class="cov8" title="1">{
        radianAngle := degreeAngle * (math.Pi / 180)

        c := math.Cos(radianAngle)
        s := math.Sin(radianAngle)
        cy := pageHeight - y

        return fmt.Sprintf("%.5f %.5f %.5f\n %.5f %.2f %.2f cm\n 1 0 0\n 1 %.2f %.2f cm\n", c, s, -s, c, x, cy, -x, -cy)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "math"
)

type cacheContentSector struct {
        pageHeight float64
        cx         float64 // center X
        cy         float64 // center Y
        r          float64 // radius
        startDeg   float64 // start angle in degrees
        endDeg     float64 // end angle in degrees
        style      string
        opts       sectorOptions
}

type sectorOptions struct {
        extGStateIndexes []int
}

func (c *cacheContentSector) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        h := c.pageHeight
        cx := c.cx
        cy := h - c.cy
        r := c.r

        fmt.Fprintf(w, "q\n")
        for _, extGStateIndex := range c.opts.extGStateIndexes </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/GS%d gs\n", extGStateIndex)
        }</span>

        // Move to center
        <span class="cov8" title="1">fmt.Fprintf(w, "%.2f %.2f m\n", cx, cy)

        // Line to arc start point
        startRad := c.startDeg * math.Pi / 180
        endRad := c.endDeg * math.Pi / 180
        sx := cx + r*math.Cos(startRad)
        sy := cy - r*math.Sin(startRad) // PDF y-axis is inverted
        fmt.Fprintf(w, "%.2f %.2f l\n", sx, sy)

        // Draw arc using BÃ©zier curve segments (max 90 degrees each)
        writeArcSegments(w, cx, cy, r, startRad, endRad)

        // Close path back to center
        fmt.Fprintf(w, "%.2f %.2f l\n", cx, cy)

        if c.style == "F" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "f\n")
        }</span> else<span class="cov8" title="1"> if c.style == "FD" || c.style == "DF" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "b\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(w, "s\n")
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w, "Q\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package gopdf

import (
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
)

const defaultCoefLineHeight = float64(1)
const defaultCoefUnderlinePosition = float64(1)
const defaultcoefUnderlineThickness = float64(1)

// ContentTypeCell cell
const ContentTypeCell = 0

// ContentTypeText text
const ContentTypeText = 1

var ErrContentTypeNotFound = errors.New("contentType not found")

type cacheContentText struct {
        //---setup---
        rectangle      *Rect
        textColor      ICacheColorText
        grayFill       float64
        txtColorMode   string
        fontCountIndex int //Curr.FontFontCount+1
        fontSize       float64
        fontStyle      int
        charSpacing    float64
        setXCount      int //à¸ˆà¸³à¸™à¸§à¸™à¸„à¸£à¸±à¹‰à¸‡à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰ setX
        x, y           float64
        fontSubset     *SubsetFontObj
        pageheight     float64
        contentType    int
        cellOpt        CellOption
        lineWidth      float64
        text           string
        //---result---
        cellWidthPdfUnit, textWidthPdfUnit float64
        cellHeightPdfUnit                  float64
        isPlaceHolder                      bool
}

func (c *cacheContentText) isSame(cache cacheContentText) bool <span class="cov8" title="1">{
        if c.rectangle != nil </span><span class="cov8" title="1">{
                //if rectangle != nil we assume this is not same content
                return false
        }</span>

        // if both colors are nil we assume them equal
        <span class="cov8" title="1">if ((c.textColor == nil &amp;&amp; cache.textColor == nil) ||
                (c.textColor != nil &amp;&amp; c.textColor.equal(cache.textColor))) &amp;&amp;
                c.grayFill == cache.grayFill &amp;&amp;
                c.fontCountIndex == cache.fontCountIndex &amp;&amp;
                c.fontSize == cache.fontSize &amp;&amp;
                c.fontStyle == cache.fontStyle &amp;&amp;
                c.charSpacing == cache.charSpacing &amp;&amp;
                c.setXCount == cache.setXCount &amp;&amp;
                c.y == cache.y &amp;&amp;
                c.isPlaceHolder == cache.isPlaceHolder </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (c *cacheContentText) setPageHeight(pageheight float64) <span class="cov8" title="1">{
        c.pageheight = pageheight
}</span>

func (c *cacheContentText) pageHeight() float64 <span class="cov8" title="1">{
        return c.pageheight //841.89
}</span>

func convertTypoUnit(val float64, unitsPerEm uint, fontSize float64) float64 <span class="cov8" title="1">{
        val = val * 1000.00 / float64(unitsPerEm)
        return val * fontSize / 1000.0
}</span>

func (c *cacheContentText) calTypoAscender() float64 <span class="cov8" title="1">{
        return convertTypoUnit(float64(c.fontSubset.ttfp.TypoAscender()), c.fontSubset.ttfp.UnitsPerEm(), float64(c.fontSize))
}</span>

func (c *cacheContentText) calTypoDescender() float64 <span class="cov8" title="1">{
        return convertTypoUnit(float64(c.fontSubset.ttfp.TypoDescender()), c.fontSubset.ttfp.UnitsPerEm(), float64(c.fontSize))
}</span>

func (c *cacheContentText) calY() (float64, error) <span class="cov8" title="1">{
        pageHeight := c.pageHeight()
        if c.contentType == ContentTypeText </span><span class="cov8" title="1">{
                return pageHeight - c.y, nil
        }</span> else<span class="cov8" title="1"> if c.contentType == ContentTypeCell </span><span class="cov8" title="1">{
                y := float64(0.0)
                if c.cellOpt.Align&amp;Bottom == Bottom </span><span class="cov8" title="1">{
                        y = pageHeight - c.y - c.cellHeightPdfUnit - c.calTypoDescender()
                }</span> else<span class="cov8" title="1"> if c.cellOpt.Align&amp;Middle == Middle </span><span class="cov8" title="1">{
                        y = pageHeight - c.y - c.cellHeightPdfUnit*0.5 - (c.calTypoDescender()+c.calTypoAscender())*0.5
                }</span> else<span class="cov8" title="1"> {
                        //top
                        y = pageHeight - c.y - c.calTypoAscender()
                }</span>

                <span class="cov8" title="1">return y, nil</span>
        }
        <span class="cov8" title="1">return 0.0, ErrContentTypeNotFound</span>
}

func (c *cacheContentText) calX() (float64, error) <span class="cov8" title="1">{
        if c.contentType == ContentTypeText </span><span class="cov8" title="1">{
                return c.x, nil
        }</span> else<span class="cov8" title="1"> if c.contentType == ContentTypeCell </span><span class="cov8" title="1">{
                x := float64(0.0)
                if c.cellOpt.Align&amp;Right == Right </span><span class="cov8" title="1">{
                        x = c.x + c.cellWidthPdfUnit - c.textWidthPdfUnit
                }</span> else<span class="cov8" title="1"> if c.cellOpt.Align&amp;Center == Center </span><span class="cov8" title="1">{
                        x = c.x + c.cellWidthPdfUnit*0.5 - c.textWidthPdfUnit*0.5
                }</span> else<span class="cov8" title="1"> {
                        x = c.x
                }</span>
                <span class="cov8" title="1">return x, nil</span>
        }
        <span class="cov8" title="1">return 0.0, ErrContentTypeNotFound</span>
}

// FormatFloatTrim converts a float64 into a string, like Sprintf("%.3f")
// but with trailing zeroes (and possibly ".") removed
func FormatFloatTrim(floatval float64) (formatted string) <span class="cov8" title="1">{
        const precisionFactor = 1000.0
        roundedFontSize := math.Round(precisionFactor*floatval) / precisionFactor
        return strconv.FormatFloat(roundedFontSize, 'f', -1, 64)
}</span>

func (c *cacheContentText) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        x, err := c.calX()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">y, err := c.calY()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, extGStateIndex := range c.cellOpt.extGStateIndexes </span><span class="cov8" title="1">{
                linkToGSObj := fmt.Sprintf("/GS%d gs\n", extGStateIndex)
                if _, err := io.WriteString(w, linkToGSObj); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if _, err := io.WriteString(w, "BT\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w, "%0.2f %0.2f TD\n", x, y)
        fmt.Fprintf(w, "/F%d %s Tf %s Tc\n", c.fontCountIndex, FormatFloatTrim(c.fontSize), FormatFloatTrim(c.charSpacing))

        if c.txtColorMode == "color" </span><span class="cov8" title="1">{
                c.textColor.write(w, protection)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "[&lt;")

        unitsPerEm := int(c.fontSubset.ttfp.UnitsPerEm())
        var leftRune rune
        var leftRuneIndex uint
        for i, r := range c.text </span><span class="cov8" title="1">{

                glyphindex, err := c.fontSubset.CharIndex(r)
                if err == ErrCharNotFound </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">pairvalPdfUnit := 0
                if i &gt; 0 &amp;&amp; c.fontSubset.ttfFontOption.UseKerning </span><span class="cov8" title="1">{ //kerning
                        pairval := kern(c.fontSubset, leftRune, r, leftRuneIndex, glyphindex)
                        pairvalPdfUnit = convertTTFUnit2PDFUnit(int(pairval), unitsPerEm)
                        if pairvalPdfUnit != 0 </span><span class="cov8" title="1">{
                                fmt.Fprintf(w, "&gt;%d&lt;", (-1)*pairvalPdfUnit)
                        }</span>
                }

                <span class="cov8" title="1">fmt.Fprintf(w, "%04X", glyphindex)
                leftRune = r
                leftRuneIndex = glyphindex</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&gt;] TJ\n")
        io.WriteString(w, "ET\n")

        if c.fontStyle&amp;Underline == Underline </span><span class="cov8" title="1">{
                if err := c.underline(w); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">c.drawBorder(w)

        return nil</span>
}

func (c *cacheContentText) drawBorder(w io.Writer) error <span class="cov8" title="1">{

        //stream.WriteString(fmt.Sprintf("%.2f w\n", 0.1))
        lineOffset := c.lineWidth * 0.5

        if c.cellOpt.Border&amp;Top == Top </span><span class="cov8" title="1">{

                startX := c.x - lineOffset
                startY := c.pageHeight() - c.y
                endX := c.x + c.cellWidthPdfUnit + lineOffset
                endY := startY
                _, err := fmt.Fprintf(w, "%0.2f %0.2f m %0.2f %0.2f l s\n", startX, startY, endX, endY)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if c.cellOpt.Border&amp;Left == Left </span><span class="cov8" title="1">{
                startX := c.x
                startY := c.pageHeight() - c.y
                endX := c.x
                endY := startY - c.cellHeightPdfUnit
                _, err := fmt.Fprintf(w, "%0.2f %0.2f m %0.2f %0.2f l s\n", startX, startY, endX, endY)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if c.cellOpt.Border&amp;Right == Right </span><span class="cov8" title="1">{
                startX := c.x + c.cellWidthPdfUnit
                startY := c.pageHeight() - c.y
                endX := c.x + c.cellWidthPdfUnit
                endY := startY - c.cellHeightPdfUnit
                _, err := fmt.Fprintf(w, "%0.2f %0.2f m %0.2f %0.2f l s\n", startX, startY, endX, endY)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if c.cellOpt.Border&amp;Bottom == Bottom </span><span class="cov8" title="1">{
                startX := c.x - lineOffset
                startY := c.pageHeight() - c.y - c.cellHeightPdfUnit
                endX := c.x + c.cellWidthPdfUnit + lineOffset
                endY := startY
                _, err := fmt.Fprintf(w, "%0.2f %0.2f m %0.2f %0.2f l s\n", startX, startY, endX, endY)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *cacheContentText) underline(w io.Writer) error <span class="cov8" title="1">{
        if c.fontSubset == nil </span><span class="cov8" title="1">{
                return errors.New("error AppendUnderline not found font")
        }</span>

        <span class="cov8" title="1">coefLineHeight := defaultCoefLineHeight
        if c.cellOpt.CoefLineHeight != 0 </span><span class="cov8" title="1">{
                coefLineHeight = c.cellOpt.CoefLineHeight
        }</span>

        <span class="cov8" title="1">coefUnderlinePosition := defaultCoefUnderlinePosition
        if c.cellOpt.CoefUnderlinePosition != 0 </span><span class="cov8" title="1">{
                coefUnderlinePosition = c.cellOpt.CoefUnderlinePosition
        }</span>

        <span class="cov8" title="1">coefUnderlineThickness := defaultcoefUnderlineThickness
        if c.cellOpt.CoefUnderlineThickness != 0 </span><span class="cov8" title="1">{
                coefUnderlineThickness = c.cellOpt.CoefUnderlineThickness
        }</span>

        <span class="cov8" title="1">ascenderPx := c.fontSubset.GetAscenderPx(c.fontSize)
        descenderPx := -c.fontSubset.GetDescenderPx(c.fontSize)

        contentHeight := ascenderPx + descenderPx
        virtualHeight := coefLineHeight * float64(c.fontSize)
        leading := (contentHeight - virtualHeight) / 2

        baseline := ascenderPx + leading

        underlinePositionPx := c.fontSubset.GetUnderlinePositionPx(c.fontSize) * coefUnderlinePosition
        underlineThicknessPx := c.fontSubset.GetUnderlineThicknessPx(c.fontSize) * coefUnderlineThickness

        yUnderlinePosition := c.pageHeight() - c.y + underlinePositionPx - baseline
        if _, err := fmt.Fprintf(w, "%0.2f %0.2f %0.2f %0.2f re f\n", c.x, yUnderlinePosition, c.cellWidthPdfUnit, underlineThicknessPx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *cacheContentText) createContent() (float64, float64, error) <span class="cov8" title="1">{

        cellWidthPdfUnit, cellHeightPdfUnit, textWidthPdfUnit, err := createContent(c.fontSubset, c.text, c.fontSize, c.charSpacing, c.rectangle)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">c.cellWidthPdfUnit = cellWidthPdfUnit
        c.cellHeightPdfUnit = cellHeightPdfUnit
        c.textWidthPdfUnit = textWidthPdfUnit
        return cellWidthPdfUnit, cellHeightPdfUnit, nil</span>
}

func createContent(f *SubsetFontObj, text string, fontSize float64, charSpacing float64, rectangle *Rect) (float64, float64, float64, error) <span class="cov8" title="1">{

        unitsPerEm := int(f.ttfp.UnitsPerEm())
        var leftRune rune
        var leftRuneIndex uint
        sumWidth := int(0)
        //fmt.Printf("unitsPerEm = %d", unitsPerEm)
        for i, r := range text </span><span class="cov8" title="1">{

                glyphindex, err := f.CharIndex(r)
                if err == ErrCharNotFound </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, 0, err
                }</span>

                <span class="cov8" title="1">pairvalPdfUnit := 0
                if i &gt; 0 &amp;&amp; f.ttfFontOption.UseKerning </span><span class="cov8" title="1">{ //kerning
                        pairval := kern(f, leftRune, r, leftRuneIndex, glyphindex)
                        pairvalPdfUnit = convertTTFUnit2PDFUnit(int(pairval), unitsPerEm)
                }</span>

                <span class="cov8" title="1">width, err := f.CharWidth(r)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, 0, err
                }</span>

                <span class="cov8" title="1">unitsPerPt := float64(unitsPerEm) / fontSize
                spaceWidthInPt := unitsPerPt * charSpacing
                spaceWidthPdfUnit := convertTTFUnit2PDFUnit(int(spaceWidthInPt), unitsPerEm)

                sumWidth += int(width) + int(pairvalPdfUnit) + spaceWidthPdfUnit
                leftRune = r
                leftRuneIndex = glyphindex</span>
        }

        <span class="cov8" title="1">cellWidthPdfUnit := float64(0)
        cellHeightPdfUnit := float64(0)
        if rectangle == nil </span><span class="cov8" title="1">{
                cellWidthPdfUnit = float64(sumWidth) * (float64(fontSize) / 1000.0)
                typoAscender := convertTypoUnit(float64(f.ttfp.TypoAscender()), f.ttfp.UnitsPerEm(), float64(fontSize))
                typoDescender := convertTypoUnit(float64(f.ttfp.TypoDescender()), f.ttfp.UnitsPerEm(), float64(fontSize))
                cellHeightPdfUnit = typoAscender - typoDescender
        }</span> else<span class="cov8" title="1"> {
                cellWidthPdfUnit = rectangle.W
                cellHeightPdfUnit = rectangle.H
        }</span>
        <span class="cov8" title="1">textWidthPdfUnit := float64(sumWidth) * (float64(fontSize) / 1000.0)
        return cellWidthPdfUnit, cellHeightPdfUnit, textWidthPdfUnit, nil</span>
}

func kern(f *SubsetFontObj, leftRune rune, rightRune rune, leftIndex uint, rightIndex uint) int16 <span class="cov8" title="1">{

        pairVal := int16(0)
        if haveKerning, kval := f.KernValueByLeft(leftIndex); haveKerning </span><span class="cov8" title="1">{
                if ok, v := kval.ValueByRight(rightIndex); ok </span><span class="cov8" title="1">{
                        pairVal = v
                }</span>
        }

        <span class="cov8" title="1">if f.funcKernOverride != nil </span><span class="cov8" title="1">{
                pairVal = f.funcKernOverride(
                        leftRune,
                        rightRune,
                        leftIndex,
                        rightIndex,
                        pairVal,
                )
        }</span>
        <span class="cov8" title="1">return pairVal</span>
}

// CacheContent Export cacheContent
type CacheContent struct {
        cacheContentText
}

// Setup setup all information for cacheContent
func (c *CacheContent) Setup(rectangle *Rect,
        textColor ICacheColorText,
        grayFill float64,
        fontCountIndex int, //Curr.FontFontCount+1
        fontSize float64,
        fontStyle int,
        charSpacing float64,
        setXCount int, //à¸ˆà¸³à¸™à¸§à¸™à¸„à¸£à¸±à¹‰à¸‡à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰ setX
        x, y float64,
        fontSubset *SubsetFontObj,
        pageheight float64,
        contentType int,
        cellOpt CellOption,
        lineWidth float64,
) <span class="cov8" title="1">{
        c.cacheContentText = cacheContentText{
                fontSubset:     fontSubset,
                rectangle:      rectangle,
                textColor:      textColor,
                grayFill:       grayFill,
                fontCountIndex: fontCountIndex,
                fontSize:       fontSize,
                fontStyle:      fontStyle,
                charSpacing:    charSpacing,
                setXCount:      setXCount,
                x:              x,
                y:              y,
                pageheight:     pageheight,
                contentType:    ContentTypeCell,
                cellOpt:        cellOpt,
                lineWidth:      lineWidth,
        }
}</span>

// WriteTextToContent write text to content
func (c *CacheContent) WriteTextToContent(text string) <span class="cov8" title="1">{
        c.cacheContentText.text += text
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentTextColorCMYK struct {
        c, m, y, k uint8
}

func (c cacheContentTextColorCMYK) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.2f %.2f %.2f %.2f %s\n", float64(c.c)/100, float64(c.m)/100, float64(c.y)/100, float64(c.k)/100, colorTypeFillCMYK)
        return nil
}</span>

func (c cacheContentTextColorCMYK) equal(obj ICacheColorText) bool <span class="cov8" title="1">{
        cmyk, ok := obj.(cacheContentTextColorCMYK)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return c.c == cmyk.c &amp;&amp; c.m == cmyk.m &amp;&amp; c.y == cmyk.y &amp;&amp; c.k == cmyk.k</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentTextColorRGB struct {
        r, g, b uint8
}

func (c cacheContentTextColorRGB) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "%.3f %.3f %.3f %s\n", float64(c.r)/255, float64(c.g)/255, float64(c.b)/255, colorTypeFillRGB)
        return nil
}</span>

func (c cacheContentTextColorRGB) equal(obj ICacheColorText) bool <span class="cov8" title="1">{
        rgb, ok := obj.(cacheContentTextColorRGB)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return c.r == rgb.r &amp;&amp; c.g == rgb.g &amp;&amp; c.b == rgb.b</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type cacheContentCurve struct {
        pageHeight float64
        x0         float64
        y0         float64
        x1         float64
        y1         float64
        x2         float64
        y2         float64
        x3         float64
        y3         float64
        style      string
}

func (c *cacheContentCurve) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{

        h := c.pageHeight
        x0 := c.x0
        y0 := c.y0
        x1 := c.x1
        y1 := c.y1
        x2 := c.x2
        y2 := c.y2
        x3 := c.x3
        y3 := c.y3
        style := c.style

        //cp := 0.55228
        fmt.Fprintf(w, "%0.2f %0.2f m\n", x0, h-y0)
        fmt.Fprintf(w,
                "%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c",
                x1, h-y1, x2, h-y2, x3, h-y3,
        )
        op := "S"
        if style == "F" </span><span class="cov8" title="1">{
                op = "f"
        }</span> else<span class="cov8" title="1"> if style == "FD" || style == "DF" </span><span class="cov8" title="1">{
                op = "B"
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, " %s\n", op)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// CatalogObj : catalog dictionary
type CatalogObj struct { //impl IObj
        outlinesObjID      int
        namesObjID         int // index of Names dictionary object (-1 = none)
        pageLabelsObjID    int // index of PageLabels object (-1 = none)
        metadataObjID      int // index of XMP Metadata stream object (-1 = none)
        ocPropertiesObjID  int // index of OCProperties object (-1 = none)
        acroFormObjID      int // index of AcroForm object (-1 = none)
        markInfoObjID      int // index of MarkInfo object (-1 = none)
        pageLayout         string
        pageMode           string
}

func (c *CatalogObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        c.outlinesObjID = -1
        c.namesObjID = -1
        c.pageLabelsObjID = -1
        c.metadataObjID = -1
        c.ocPropertiesObjID = -1
        c.acroFormObjID = -1
        c.markInfoObjID = -1
}</span>

func (c *CatalogObj) getType() string <span class="cov8" title="1">{
        return "Catalog"
}</span>

func (c *CatalogObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "  /Type /%s\n", c.getType())
        io.WriteString(w, "  /Pages 2 0 R\n")
        if c.outlinesObjID &gt;= 0 </span><span class="cov8" title="1">{
                io.WriteString(w, "  /PageMode /UseOutlines\n")
                fmt.Fprintf(w, "  /Outlines %d 0 R\n", c.outlinesObjID)
        }</span>
        <span class="cov8" title="1">if c.namesObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Names %d 0 R\n", c.namesObjID)
        }</span>
        <span class="cov8" title="1">if c.pageLabelsObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /PageLabels %d 0 R\n", c.pageLabelsObjID)
        }</span>
        <span class="cov8" title="1">if c.metadataObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Metadata %d 0 R\n", c.metadataObjID)
        }</span>
        <span class="cov8" title="1">if c.ocPropertiesObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /OCProperties %d 0 R\n", c.ocPropertiesObjID)
        }</span>
        <span class="cov8" title="1">if c.acroFormObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /AcroForm %d 0 R\n", c.acroFormObjID)
        }</span>
        <span class="cov8" title="1">if c.markInfoObjID &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /MarkInfo %d 0 R\n", c.markInfoObjID)
        }</span>
        <span class="cov8" title="1">if c.pageLayout != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /PageLayout /%s\n", c.pageLayout)
        }</span>
        <span class="cov8" title="1">if c.pageMode != "" &amp;&amp; c.outlinesObjID &lt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /PageMode /%s\n", c.pageMode)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

func (c *CatalogObj) SetIndexObjOutlines(index int) <span class="cov8" title="1">{
        c.outlinesObjID = index + 1
}</span>

// SetIndexObjNames sets the Names dictionary object reference.
func (c *CatalogObj) SetIndexObjNames(index int) <span class="cov8" title="1">{
        c.namesObjID = index + 1
}</span>

// SetIndexObjPageLabels sets the PageLabels object reference.
func (c *CatalogObj) SetIndexObjPageLabels(index int) <span class="cov8" title="1">{
        c.pageLabelsObjID = index + 1
}</span>

// SetIndexObjMetadata sets the XMP Metadata stream object reference.
func (c *CatalogObj) SetIndexObjMetadata(index int) <span class="cov8" title="1">{
        c.metadataObjID = index + 1
}</span>

// SetIndexObjOCProperties sets the OCProperties object reference.
func (c *CatalogObj) SetIndexObjOCProperties(index int) <span class="cov8" title="1">{
        c.ocPropertiesObjID = index + 1
}</span>

// SetIndexObjAcroForm sets the AcroForm object reference.
func (c *CatalogObj) SetIndexObjAcroForm(index int) <span class="cov8" title="1">{
        c.acroFormObjID = index + 1
}</span>

// SetIndexObjMarkInfo sets the MarkInfo object reference.
func (c *CatalogObj) SetIndexObjMarkInfo(index int) <span class="cov8" title="1">{
        c.markInfoObjID = index + 1
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// CIDFontObj is a CID-keyed font.
// cf. https://www.adobe.com/content/dam/acom/en/devnet/font/pdfs/5014.CIDFont_Spec.pdf
type CIDFontObj struct {
        PtrToSubsetFontObj        *SubsetFontObj
        indexObjSubfontDescriptor int
}

func (ci *CIDFontObj) init(funcGetRoot func() *GoPdf) {<span class="cov8" title="1">
}</span>

// SetIndexObjSubfontDescriptor set  indexObjSubfontDescriptor
func (ci *CIDFontObj) SetIndexObjSubfontDescriptor(index int) <span class="cov8" title="1">{
        ci.indexObjSubfontDescriptor = index
}</span>

func (ci *CIDFontObj) getType() string <span class="cov8" title="1">{
        return "CIDFont"
}</span>

func (ci *CIDFontObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/BaseFont /%s\n", CreateEmbeddedFontSubsetName(ci.PtrToSubsetFontObj.GetFamily()))
        io.WriteString(w, "/CIDSystemInfo\n")
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "  /Ordering (Identity)\n")
        io.WriteString(w, "  /Registry (Adobe)\n")
        io.WriteString(w, "  /Supplement 0\n")
        io.WriteString(w, "&gt;&gt;\n")
        fmt.Fprintf(w, "/FontDescriptor %d 0 R\n", ci.indexObjSubfontDescriptor+1) //TODO fix
        io.WriteString(w, "/Subtype /CIDFontType2\n")
        io.WriteString(w, "/Type /Font\n")
        glyphIndexs := ci.PtrToSubsetFontObj.CharacterToGlyphIndex.AllVals()
        io.WriteString(w, "/W [")
        for _, v := range glyphIndexs </span><span class="cov8" title="1">{
                width := ci.PtrToSubsetFontObj.GlyphIndexToPdfWidth(v)
                fmt.Fprintf(w, "%d[%d]", v, width)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "]\n")
        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// SetPtrToSubsetFontObj set PtrToSubsetFontObj
func (ci *CIDFontObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) <span class="cov8" title="1">{
        ci.PtrToSubsetFontObj = ptr
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package gopdf

// Clone creates a deep copy of the GoPdf instance by serializing and
// re-importing the document. The cloned document is independent â€” changes
// to the clone do not affect the original, and vice versa.
//
// This is useful for creating variants of a document (e.g. different
// watermarks or stamps) without re-generating from scratch.
//
// Note: Header/footer callback functions are NOT cloned (they are set to nil).
// Font data, images, and all page content are fully duplicated.
//
// Example:
//
//        original := &amp;gopdf.GoPdf{}
//        original.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})
//        original.AddPage()
//        // ... build document ...
//
//        clone, err := original.Clone()
//        if err != nil { log.Fatal(err) }
//        // clone is a fully independent copy
//        clone.SetPage(1)
//        clone.SetXY(100, 100)
//        clone.Text("Only in clone")
//        clone.WritePdf("clone.pdf")
func (gp *GoPdf) Clone() (*GoPdf, error) <span class="cov8" title="1">{
        // Serialize the current document to bytes.
        data, err := gp.GetBytesPdfReturnErr()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Re-import into a new GoPdf instance.
        <span class="cov8" title="1">clone := &amp;GoPdf{}
        err = clone.OpenPDFFromBytes(data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Copy metadata that isn't part of the PDF stream.
        <span class="cov8" title="1">clone.pdfVersion = gp.pdfVersion
        if gp.xmpMetadata != nil </span><span class="cov8" title="1">{
                metaCopy := *gp.xmpMetadata
                clone.xmpMetadata = &amp;metaCopy
        }</span>
        <span class="cov8" title="1">if len(gp.pageLabels) &gt; 0 </span><span class="cov8" title="1">{
                clone.pageLabels = make([]PageLabel, len(gp.pageLabels))
                copy(clone.pageLabels, gp.pageLabels)
        }</span>

        <span class="cov8" title="1">return clone, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type ColorSpaceObj struct {
        CountOfSpaceColor int
        Name              string
        spaceName         string
        colorString0      string
        colorString1      string
        space             string
}

func (cs *ColorSpaceObj) init(func() *GoPdf) {<span class="cov8" title="1">}</span>

func (cs *ColorSpaceObj) getType() string <span class="cov8" title="1">{
        return "ColorSpace"
}</span>

func (cs *ColorSpaceObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{

        fmt.Fprintf(w, "[ /Separation %s %s\n", cs.spaceName, cs.space)
        io.WriteString(w, "                &lt;&lt; \n")
        io.WriteString(w, "                        /FunctionType 2\n")
        io.WriteString(w, "                        /Domain [0 1]\n")
        fmt.Fprintf(w, "                        /C0 [%s]\n", cs.colorString0)
        fmt.Fprintf(w, "                        /C1 [%s]\n", cs.colorString1)
        io.WriteString(w, "                        /N 1\n")
        io.WriteString(w, "                &gt;&gt;\n")
        io.WriteString(w, "]\n")

        return nil
}</span>

func (cs *ColorSpaceObj) SetColorRBG(r, g, b uint8) <span class="cov8" title="1">{
        cs.colorString0 = "0.0 0.0 0.0"
        cs.colorString1 = fmt.Sprintf("%.3f %.3f %.3f", float64(r)/255.0, float64(g)/255.0, float64(b)/255.0)
        cs.space = "/DeviceRGB"
        cs.spaceName = fmt.Sprintf("/%s", cs.Name)
}</span>

func (cs *ColorSpaceObj) SetColorCMYK(c, m, y, k uint8) <span class="cov8" title="1">{
        cs.colorString0 = "0.0 0.0 0.0 0.0"
        cs.colorString1 = fmt.Sprintf("%.3f %.3f %.3f %.3f", float64(c)/100.0, float64(m)/100.0, float64(y)/100.0, float64(k)/100.0)
        cs.space = "/DeviceCMYK"
        cs.spaceName = fmt.Sprintf("/%s", cs.Name)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package gopdf

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "math"
        "strconv"
        "strings"
)

// ColorspaceTarget specifies the target colorspace for conversion.
type ColorspaceTarget int

const (
        // ColorspaceGray converts to DeviceGray.
        ColorspaceGray ColorspaceTarget = iota
        // ColorspaceCMYK converts to DeviceCMYK.
        ColorspaceCMYK
        // ColorspaceRGB converts to DeviceRGB.
        ColorspaceRGB
)

// ConvertColorspaceOption configures colorspace conversion.
type ConvertColorspaceOption struct {
        // Target is the target colorspace.
        Target ColorspaceTarget
}

// ConvertColorspace converts all color operators in the PDF content streams
// to the specified target colorspace. Returns the modified PDF data.
//
// This converts color-setting operators (rg, RG, k, K, g, G) in content
// streams. It does NOT convert image colorspaces â€” use RecompressImages
// for that.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        gray, err := gopdf.ConvertColorspace(data, gopdf.ConvertColorspaceOption{
//            Target: gopdf.ColorspaceGray,
//        })
//        os.WriteFile("grayscale.pdf", gray, 0644)
func ConvertColorspace(pdfData []byte, opt ConvertColorspaceOption) ([]byte, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF: %w", err)
        }</span>

        <span class="cov8" title="1">result := make([]byte, len(pdfData))
        copy(result, pdfData)

        modified := false
        for _, page := range parser.pages </span><span class="cov8" title="1">{
                for _, contentRef := range page.contents </span><span class="cov8" title="1">{
                        obj, ok := parser.objects[contentRef]
                        if !ok || obj.stream == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">converted := convertStreamColorspace(obj.stream, opt.Target)
                        if bytes.Equal(converted, obj.stream) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Compress the converted stream.
                        <span class="cov8" title="1">var compressed bytes.Buffer
                        w, err := zlib.NewWriterLevel(&amp;compressed, zlib.DefaultCompression)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">w.Write(converted)
                        w.Close()

                        newDict := buildCleanedDict(obj.dict, compressed.Len())
                        result = replaceObjectStream(result, contentRef, newDict, compressed.Bytes())
                        modified = true</span>
                }
        }

        <span class="cov8" title="1">if !modified </span><span class="cov8" title="1">{
                return pdfData, nil
        }</span>

        <span class="cov8" title="1">result = rebuildXref(result)
        return result, nil</span>
}

// convertStreamColorspace converts color operators in a content stream.
func convertStreamColorspace(stream []byte, target ColorspaceTarget) []byte <span class="cov8" title="1">{
        lines := strings.Split(string(stream), "\n")
        var result []string

        for _, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if trimmed == "" </span><span class="cov8" title="1">{
                        result = append(result, line)
                        continue</span>
                }
                <span class="cov8" title="1">converted := convertColorLine(trimmed, target)
                result = append(result, converted)</span>
        }

        <span class="cov8" title="1">return []byte(strings.Join(result, "\n"))</span>
}

// convertColorLine converts a single content stream line's color operators.
func convertColorLine(line string, target ColorspaceTarget) string <span class="cov8" title="1">{
        parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return line
        }</span>
        <span class="cov8" title="1">op := parts[len(parts)-1]

        switch op </span>{
        case "rg":<span class="cov8" title="1"> // RGB non-stroking
                if len(parts) &gt;= 4 </span><span class="cov8" title="1">{
                        r := parseColorFloat(parts[len(parts)-4])
                        g := parseColorFloat(parts[len(parts)-3])
                        b := parseColorFloat(parts[len(parts)-2])
                        return convertRGBOp(r, g, b, false, target)
                }</span>
        case "RG":<span class="cov8" title="1"> // RGB stroking
                if len(parts) &gt;= 4 </span><span class="cov8" title="1">{
                        r := parseColorFloat(parts[len(parts)-4])
                        g := parseColorFloat(parts[len(parts)-3])
                        b := parseColorFloat(parts[len(parts)-2])
                        return convertRGBOp(r, g, b, true, target)
                }</span>
        case "k":<span class="cov8" title="1"> // CMYK non-stroking
                if len(parts) &gt;= 5 </span><span class="cov8" title="1">{
                        c := parseColorFloat(parts[len(parts)-5])
                        m := parseColorFloat(parts[len(parts)-4])
                        y := parseColorFloat(parts[len(parts)-3])
                        k := parseColorFloat(parts[len(parts)-2])
                        return convertCMYKOp(c, m, y, k, false, target)
                }</span>
        case "K":<span class="cov8" title="1"> // CMYK stroking
                if len(parts) &gt;= 5 </span><span class="cov8" title="1">{
                        c := parseColorFloat(parts[len(parts)-5])
                        m := parseColorFloat(parts[len(parts)-4])
                        y := parseColorFloat(parts[len(parts)-3])
                        k := parseColorFloat(parts[len(parts)-2])
                        return convertCMYKOp(c, m, y, k, true, target)
                }</span>
        case "g":<span class="cov8" title="1"> // Gray non-stroking
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        gray := parseColorFloat(parts[len(parts)-2])
                        return convertGrayOp(gray, false, target)
                }</span>
        case "G":<span class="cov8" title="1"> // Gray stroking
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        gray := parseColorFloat(parts[len(parts)-2])
                        return convertGrayOp(gray, true, target)
                }</span>
        }

        <span class="cov8" title="1">return line</span>
}

// convertRGBOp converts an RGB color operation to the target colorspace.
func convertRGBOp(r, g, b float64, stroking bool, target ColorspaceTarget) string <span class="cov8" title="1">{
        switch target </span>{
        case ColorspaceGray:<span class="cov8" title="1">
                gray := rgbToGray(r, g, b)
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f G", gray)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f g", gray)</span>
        case ColorspaceCMYK:<span class="cov8" title="1">
                c, m, y, k := rgbToCMYK(r, g, b)
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f %.4f %.4f %.4f K", c, m, y, k)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f %.4f %.4f %.4f k", c, m, y, k)</span>
        default:<span class="cov8" title="1">
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f %.4f %.4f RG", r, g, b)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f %.4f %.4f rg", r, g, b)</span>
        }
}

// convertCMYKOp converts a CMYK color operation to the target colorspace.
func convertCMYKOp(c, m, y, k float64, stroking bool, target ColorspaceTarget) string <span class="cov8" title="1">{
        switch target </span>{
        case ColorspaceGray:<span class="cov8" title="1">
                r, g, b := cmykToRGB(c, m, y, k)
                gray := rgbToGray(r, g, b)
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f G", gray)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f g", gray)</span>
        case ColorspaceRGB:<span class="cov8" title="1">
                r, g, b := cmykToRGB(c, m, y, k)
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f %.4f %.4f RG", r, g, b)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f %.4f %.4f rg", r, g, b)</span>
        default:<span class="cov8" title="1">
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f %.4f %.4f %.4f K", c, m, y, k)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f %.4f %.4f %.4f k", c, m, y, k)</span>
        }
}

// convertGrayOp converts a gray color operation to the target colorspace.
func convertGrayOp(gray float64, stroking bool, target ColorspaceTarget) string <span class="cov8" title="1">{
        switch target </span>{
        case ColorspaceRGB:<span class="cov8" title="1">
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f %.4f %.4f RG", gray, gray, gray)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f %.4f %.4f rg", gray, gray, gray)</span>
        case ColorspaceCMYK:<span class="cov8" title="1">
                k := 1.0 - gray
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("0.0000 0.0000 0.0000 %.4f K", k)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("0.0000 0.0000 0.0000 %.4f k", k)</span>
        default:<span class="cov8" title="1">
                if stroking </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%.4f G", gray)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%.4f g", gray)</span>
        }
}

// rgbToGray converts RGB to grayscale using the luminance formula.
func rgbToGray(r, g, b float64) float64 <span class="cov8" title="1">{
        return 0.299*r + 0.587*g + 0.114*b
}</span>

// rgbToCMYK converts RGB to CMYK.
func rgbToCMYK(r, g, b float64) (c, m, y, k float64) <span class="cov8" title="1">{
        k = 1.0 - math.Max(r, math.Max(g, b))
        if k &gt;= 1.0 </span><span class="cov8" title="1">{
                return 0, 0, 0, 1
        }</span>
        <span class="cov8" title="1">c = (1.0 - r - k) / (1.0 - k)
        m = (1.0 - g - k) / (1.0 - k)
        y = (1.0 - b - k) / (1.0 - k)
        return</span>
}

// cmykToRGB converts CMYK to RGB.
func cmykToRGB(c, m, y, k float64) (r, g, b float64) <span class="cov8" title="1">{
        r = (1.0 - c) * (1.0 - k)
        g = (1.0 - m) * (1.0 - k)
        b = (1.0 - y) * (1.0 - k)
        return
}</span>

// parseColorFloat parses a float from a string, returning 0 on error.
func parseColorFloat(s string) float64 <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        v, _ := strconv.ParseFloat(s, 64)
        return v
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package gopdf

// The units that can be used in the document
const (
        UnitUnset = iota // No units were set, when conversion is called on nothing will happen
        UnitPT           // Points
        UnitMM           // Millimeters
        UnitCM           // Centimeters
        UnitIN           // Inches
        UnitPX           // Pixels

        // The math needed to convert units to points
        conversionUnitPT = 1.0
        conversionUnitMM = 72.0 / 25.4
        conversionUnitCM = 72.0 / 2.54
        conversionUnitIN = 72.0
        //We use a dpi of 96 dpi as the default, so we get a conversionUnitPX = 3.0 / 4.0, which comes from 72.0 / 96.0.
        //If you want to change this value, you can change it at Config.ConversionForUnit
        //example: If you use dpi at 300.0
        //pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4, ConversionForUnit: 72.0 / 300.0 })
        conversionUnitPX = 3.0 / 4.0
)

// The units that can be used in the document (for backward compatibility)
// Deprecated: Use UnitUnset,UnitPT,UnitMM,UnitCM,UnitIN  instead
const (
        Unit_Unset = UnitUnset // No units were set, when conversion is called on nothing will happen
        Unit_PT    = UnitPT    // Points
        Unit_MM    = UnitMM    // Millimeters
        Unit_CM    = UnitCM    // Centimeters
        Unit_IN    = UnitIN    // Inches
        Unit_PX    = UnitPX    // Pixels
)

// Config static config
type Config struct {
        Unit int // The unit type to use when composing the document.
        //Value that use to convert units to points.
        //If this variable is not 0. This value will be used to calculate the unit conversion instead of the existing const value in the system.
        //And if this variable is not 0. Value â€‹â€‹in Config.Unit will not be used.
        ConversionForUnit float64
        TrimBox           Box                 // The default trim box for all pages in the document
        PageSize          Rect                // The default page size for all pages in the document
        K                 float64             // Not sure
        Protection        PDFProtectionConfig // Protection settings
}

func (c Config) getUnit() int <span class="cov8" title="1">{
        return c.Unit
}</span>
func (c Config) getConversionForUnit() float64 <span class="cov8" title="1">{
        return c.ConversionForUnit
}</span>

// PDFProtectionConfig config of pdf protection
type PDFProtectionConfig struct {
        UseProtection bool
        Permissions   int
        UserPass      []byte
        OwnerPass     []byte
}

// UnitsToPoints converts units of the provided type to points
func UnitsToPoints(t int, u float64) float64 <span class="cov8" title="1">{
        return unitsToPoints(defaultUnitConfig{Unit: t}, u)
}</span>

func unitsToPoints(unitCfg unitConfigurator, u float64) float64 <span class="cov8" title="1">{
        if unitCfg.getConversionForUnit() != 0 </span><span class="cov8" title="1">{
                return u * unitCfg.getConversionForUnit()
        }</span>
        <span class="cov8" title="1">switch unitCfg.getUnit() </span>{
        case UnitPT:<span class="cov8" title="1">
                return u * conversionUnitPT</span>
        case UnitMM:<span class="cov8" title="1">
                return u * conversionUnitMM</span>
        case UnitCM:<span class="cov8" title="1">
                return u * conversionUnitCM</span>
        case UnitIN:<span class="cov8" title="1">
                return u * conversionUnitIN</span>
        case UnitPX:<span class="cov8" title="1">
                return u * conversionUnitPX</span>
        default:<span class="cov8" title="1">
                return u</span>
        }
}

// PointsToUnits converts points to the provided units
func PointsToUnits(t int, u float64) float64 <span class="cov8" title="1">{
        return pointsToUnits(defaultUnitConfig{Unit: t}, u)
}</span>

func pointsToUnits(unitCfg unitConfigurator, u float64) float64 <span class="cov8" title="1">{
        if unitCfg.getConversionForUnit() != 0 </span><span class="cov8" title="1">{
                return u / unitCfg.getConversionForUnit()
        }</span>
        <span class="cov8" title="1">switch unitCfg.getUnit() </span>{
        case UnitPT:<span class="cov8" title="1">
                return u / conversionUnitPT</span>
        case UnitMM:<span class="cov8" title="1">
                return u / conversionUnitMM</span>
        case UnitCM:<span class="cov8" title="1">
                return u / conversionUnitCM</span>
        case UnitIN:<span class="cov8" title="1">
                return u / conversionUnitIN</span>
        case UnitPX:<span class="cov8" title="1">
                return u / conversionUnitPX</span>
        default:<span class="cov8" title="1">
                return u</span>
        }
}

// UnitsToPointsVar converts units of the provided type to points for all variables supplied
func UnitsToPointsVar(t int, u ...*float64) <span class="cov8" title="1">{
        unitsToPointsVar(defaultUnitConfig{Unit: t}, u...)
}</span>

func unitsToPointsVar(unitCfg unitConfigurator, u ...*float64) <span class="cov8" title="1">{
        for x := 0; x &lt; len(u); x++ </span><span class="cov8" title="1">{
                *u[x] = unitsToPoints(unitCfg, *u[x])
        }</span>
}

// PointsToUnitsVar converts points to the provided units for all variables supplied
func PointsToUnitsVar(t int, u ...*float64) <span class="cov8" title="1">{
        pointsToUnitsVar(defaultUnitConfig{Unit: t}, u...)
}</span>

func pointsToUnitsVar(unitCfg unitConfigurator, u ...*float64) <span class="cov8" title="1">{
        for x := 0; x &lt; len(u); x++ </span><span class="cov8" title="1">{
                *u[x] = pointsToUnits(unitCfg, *u[x])
        }</span>
}

type unitConfigurator interface {
        getUnit() int
        getConversionForUnit() float64
}

type defaultUnitConfig struct {
        Unit              int
        ConversionForUnit float64
}

func (d defaultUnitConfig) getUnit() int <span class="cov8" title="1">{
        return d.Unit
}</span>
func (d defaultUnitConfig) getConversionForUnit() float64 <span class="cov8" title="1">{
        return d.ConversionForUnit
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package gopdf

import (
        "errors"
        "fmt"
)

// ContentElementType identifies the type of a content element.
type ContentElementType int

const (
        // ElementText represents a text element.
        ElementText ContentElementType = iota
        // ElementImage represents an image element.
        ElementImage
        // ElementLine represents a line element.
        ElementLine
        // ElementRectangle represents a rectangle element.
        ElementRectangle
        // ElementOval represents an oval/ellipse element.
        ElementOval
        // ElementPolygon represents a polygon element.
        ElementPolygon
        // ElementCurve represents a BÃ©zier curve element.
        ElementCurve
        // ElementPolyline represents a polyline (open path) element.
        ElementPolyline
        // ElementSector represents a sector (pie/fan shape) element.
        ElementSector
        // ElementImportedTemplate represents an imported PDF template.
        ElementImportedTemplate
        // ElementLineWidth represents a line width setting.
        ElementLineWidth
        // ElementLineType represents a line type setting.
        ElementLineType
        // ElementCustomLineType represents a custom dash pattern.
        ElementCustomLineType
        // ElementGray represents a grayscale fill/stroke setting.
        ElementGray
        // ElementColorRGB represents an RGB color setting.
        ElementColorRGB
        // ElementColorCMYK represents a CMYK color setting.
        ElementColorCMYK
        // ElementColorSpace represents a color space setting.
        ElementColorSpace
        // ElementRotate represents a rotation transform.
        ElementRotate
        // ElementClipPolygon represents a clipping path.
        ElementClipPolygon
        // ElementSaveGState represents a graphics state save (q).
        ElementSaveGState
        // ElementRestoreGState represents a graphics state restore (Q).
        ElementRestoreGState
        // ElementUnknown represents an unrecognized element type.
        ElementUnknown
)

// String returns a human-readable name for the element type.
func (t ContentElementType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case ElementText:<span class="cov8" title="1">
                return "Text"</span>
        case ElementImage:<span class="cov8" title="1">
                return "Image"</span>
        case ElementLine:<span class="cov8" title="1">
                return "Line"</span>
        case ElementRectangle:<span class="cov8" title="1">
                return "Rectangle"</span>
        case ElementOval:<span class="cov8" title="1">
                return "Oval"</span>
        case ElementPolygon:<span class="cov8" title="1">
                return "Polygon"</span>
        case ElementCurve:<span class="cov8" title="1">
                return "Curve"</span>
        case ElementPolyline:<span class="cov8" title="1">
                return "Polyline"</span>
        case ElementSector:<span class="cov8" title="1">
                return "Sector"</span>
        case ElementImportedTemplate:<span class="cov8" title="1">
                return "ImportedTemplate"</span>
        case ElementLineWidth:<span class="cov8" title="1">
                return "LineWidth"</span>
        case ElementLineType:<span class="cov8" title="1">
                return "LineType"</span>
        case ElementCustomLineType:<span class="cov8" title="1">
                return "CustomLineType"</span>
        case ElementGray:<span class="cov8" title="1">
                return "Gray"</span>
        case ElementColorRGB:<span class="cov8" title="1">
                return "ColorRGB"</span>
        case ElementColorCMYK:<span class="cov8" title="1">
                return "ColorCMYK"</span>
        case ElementColorSpace:<span class="cov8" title="1">
                return "ColorSpace"</span>
        case ElementRotate:<span class="cov8" title="1">
                return "Rotate"</span>
        case ElementClipPolygon:<span class="cov8" title="1">
                return "ClipPolygon"</span>
        case ElementSaveGState:<span class="cov8" title="1">
                return "SaveGState"</span>
        case ElementRestoreGState:<span class="cov8" title="1">
                return "RestoreGState"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// ContentElement is a public descriptor for a single content element on a page.
// It exposes the element's type, position, dimensions, and (for text) the string content.
// The Index field is the 0-based position in the page's content stream cache.
type ContentElement struct {
        // Index is the 0-based position in the page's content cache array.
        Index int
        // Type is the element type.
        Type ContentElementType
        // X is the X coordinate (for elements that have one).
        X float64
        // Y is the Y coordinate (for elements that have one).
        Y float64
        // X2 is the second X coordinate (for lines, ovals).
        X2 float64
        // Y2 is the second Y coordinate (for lines, ovals).
        Y2 float64
        // Width is the width (for rectangles, images).
        Width float64
        // Height is the height (for rectangles, images).
        Height float64
        // Text is the text content (for text elements only).
        Text string
        // FontSize is the font size (for text elements only).
        FontSize float64
}

var (
        ErrElementIndexOutOfRange = errors.New("element index out of range")
        ErrElementTypeMismatch    = errors.New("element type mismatch")
        ErrContentObjNotFound     = errors.New("content object not found for page")
)

// classifyElement returns the ContentElementType for an ICacheContent.
func classifyElement(c ICacheContent) ContentElementType <span class="cov8" title="1">{
        switch c.(type) </span>{
        case *cacheContentText:<span class="cov8" title="1">
                return ElementText</span>
        case *cacheContentImage:<span class="cov8" title="1">
                return ElementImage</span>
        case *cacheContentLine:<span class="cov8" title="1">
                return ElementLine</span>
        case cacheContentRectangle:<span class="cov8" title="1">
                return ElementRectangle</span>
        case *cacheContentOval:<span class="cov8" title="1">
                return ElementOval</span>
        case *cacheContentPolygon:<span class="cov8" title="1">
                return ElementPolygon</span>
        case *cacheContentCurve:<span class="cov8" title="1">
                return ElementCurve</span>
        case *cacheContentPolyline:<span class="cov8" title="1">
                return ElementPolyline</span>
        case *cacheContentSector:<span class="cov8" title="1">
                return ElementSector</span>
        case *cacheContentImportedTemplate:<span class="cov8" title="1">
                return ElementImportedTemplate</span>
        case *cacheContentLineWidth:<span class="cov8" title="1">
                return ElementLineWidth</span>
        case *cacheContentLineType:<span class="cov8" title="1">
                return ElementLineType</span>
        case *cacheContentCustomLineType:<span class="cov8" title="1">
                return ElementCustomLineType</span>
        case *cacheContentGray:<span class="cov8" title="1">
                return ElementGray</span>
        case *cacheContentColorRGB:<span class="cov8" title="1">
                return ElementColorRGB</span>
        case *cacheContentColorCMYK:<span class="cov8" title="1">
                return ElementColorCMYK</span>
        case *cacheColorSpace:<span class="cov8" title="1">
                return ElementColorSpace</span>
        case *cacheContentRotate:<span class="cov8" title="1">
                return ElementRotate</span>
        case *cacheContentClipPolygon:<span class="cov8" title="1">
                return ElementClipPolygon</span>
        case *cacheContentSaveGraphicsState:<span class="cov8" title="1">
                return ElementSaveGState</span>
        case *cacheContentRestoreGraphicsState:<span class="cov8" title="1">
                return ElementRestoreGState</span>
        default:<span class="cov0" title="0">
                return ElementUnknown</span>
        }
}

// buildElement creates a ContentElement descriptor from an ICacheContent at the given index.
func buildElement(index int, c ICacheContent) ContentElement <span class="cov8" title="1">{
        elem := ContentElement{
                Index: index,
                Type:  classifyElement(c),
        }
        switch v := c.(type) </span>{
        case *cacheContentText:<span class="cov8" title="1">
                elem.X = v.x
                elem.Y = v.y
                elem.Text = v.text
                elem.FontSize = v.fontSize</span>
        case *cacheContentImage:<span class="cov8" title="1">
                elem.X = v.x
                elem.Y = v.y
                elem.Width = v.rect.W
                elem.Height = v.rect.H</span>
        case *cacheContentLine:<span class="cov8" title="1">
                elem.X = v.x1
                elem.Y = v.y1
                elem.X2 = v.x2
                elem.Y2 = v.y2</span>
        case cacheContentRectangle:<span class="cov8" title="1">
                elem.X = v.x
                elem.Y = v.y
                elem.Width = v.width
                elem.Height = v.height</span>
        case *cacheContentOval:<span class="cov8" title="1">
                elem.X = v.x1
                elem.Y = v.y1
                elem.X2 = v.x2
                elem.Y2 = v.y2</span>
        case *cacheContentPolygon:<span class="cov8" title="1">
                if len(v.points) &gt; 0 </span><span class="cov8" title="1">{
                        elem.X = v.points[0].X
                        elem.Y = v.points[0].Y
                }</span>
        case *cacheContentCurve:<span class="cov8" title="1">
                elem.X = v.x0
                elem.Y = v.y0
                elem.X2 = v.x3
                elem.Y2 = v.y3</span>
        case *cacheContentPolyline:<span class="cov8" title="1">
                if len(v.points) &gt; 0 </span><span class="cov8" title="1">{
                        elem.X = v.points[0].X
                        elem.Y = v.points[0].Y
                }</span>
        case *cacheContentSector:<span class="cov8" title="1">
                elem.X = v.cx
                elem.Y = v.cy
                elem.Width = v.r</span>
        case *cacheContentImportedTemplate:<span class="cov8" title="1">
                elem.X = v.tX
                elem.Y = v.tY</span>
        case *cacheContentLineWidth:<span class="cov8" title="1">
                elem.Width = v.width</span>
        }
        <span class="cov8" title="1">return elem</span>
}

// findContentObj finds the ContentObj for the given 1-based page number.
// This mirrors SetPage logic: iterate pdfObjs counting ContentObj instances.
func (gp *GoPdf) findContentObj(pageNo int) *ContentObj <span class="cov8" title="1">{
        count := 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if c, ok := obj.(*ContentObj); ok </span><span class="cov8" title="1">{
                        count++
                        if count == pageNo </span><span class="cov8" title="1">{
                                return c
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPageElements returns all content elements on the specified page (1-based).
// Each element includes its type, position, dimensions, and index for further operations.
//
// Example:
//
//        elements := pdf.GetPageElements(1)
//        for _, e := range elements {
//            fmt.Printf("[%d] %s at (%.1f, %.1f)\n", e.Index, e.Type, e.X, e.Y)
//        }
func (gp *GoPdf) GetPageElements(pageNo int) ([]ContentElement, error) <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">caches := content.listCache.caches
        elements := make([]ContentElement, len(caches))
        for i, c := range caches </span><span class="cov8" title="1">{
                elements[i] = buildElement(i, c)
        }</span>
        <span class="cov8" title="1">return elements, nil</span>
}

// GetPageElementsByType returns only elements of the specified type on a page.
func (gp *GoPdf) GetPageElementsByType(pageNo int, elemType ContentElementType) ([]ContentElement, error) <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">var result []ContentElement
        for i, c := range content.listCache.caches </span><span class="cov8" title="1">{
                if classifyElement(c) == elemType </span><span class="cov8" title="1">{
                        result = append(result, buildElement(i, c))
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetPageElementCount returns the number of content elements on a page.
func (gp *GoPdf) GetPageElementCount(pageNo int) (int, error) <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">return len(content.listCache.caches), nil</span>
}

// DeleteElement removes a single content element by its 0-based index on the given page.
//
// Example:
//
//        pdf.DeleteElement(1, 0) // remove first element on page 1
func (gp *GoPdf) DeleteElement(pageNo int, elementIndex int) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">if elementIndex &lt; 0 || elementIndex &gt;= len(content.listCache.caches) </span><span class="cov8" title="1">{
                return ErrElementIndexOutOfRange
        }</span>
        <span class="cov8" title="1">content.listCache.caches = append(
                content.listCache.caches[:elementIndex],
                content.listCache.caches[elementIndex+1:]...,
        )
        return nil</span>
}

// DeleteElementsByType removes all elements of the specified type from a page.
// Returns the number of elements removed.
//
// Example:
//
//        n := pdf.DeleteElementsByType(1, gopdf.ElementLine) // remove all lines from page 1
func (gp *GoPdf) DeleteElementsByType(pageNo int, elemType ContentElementType) (int, error) <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">original := len(content.listCache.caches)
        filtered := make([]ICacheContent, 0, original)
        for _, c := range content.listCache.caches </span><span class="cov8" title="1">{
                if classifyElement(c) != elemType </span><span class="cov8" title="1">{
                        filtered = append(filtered, c)
                }</span>
        }
        <span class="cov8" title="1">content.listCache.caches = filtered
        return original - len(filtered), nil</span>
}

// DeleteElementsInRect removes all elements whose primary position (X, Y)
// falls within the given rectangle. Returns the number removed.
//
// Example:
//
//        n := pdf.DeleteElementsInRect(1, 0, 0, 100, 100) // remove elements in top-left 100x100 area
func (gp *GoPdf) DeleteElementsInRect(pageNo int, rx, ry, rw, rh float64) (int, error) <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">original := len(content.listCache.caches)
        filtered := make([]ICacheContent, 0, original)
        for _, c := range content.listCache.caches </span><span class="cov8" title="1">{
                elem := buildElement(0, c)
                if elem.X &gt;= rx &amp;&amp; elem.X &lt;= rx+rw &amp;&amp; elem.Y &gt;= ry &amp;&amp; elem.Y &lt;= ry+rh </span><span class="cov8" title="1">{
                        continue</span> // inside rect, remove
                }
                <span class="cov8" title="1">filtered = append(filtered, c)</span>
        }
        <span class="cov8" title="1">content.listCache.caches = filtered
        return original - len(filtered), nil</span>
}

// ClearPage removes all content elements from a page, leaving it blank.
//
// Example:
//
//        pdf.ClearPage(1) // clear all content from page 1
func (gp *GoPdf) ClearPage(pageNo int) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">content.listCache.caches = nil
        return nil</span>
}

// ModifyTextElement changes the text content of a text element at the given index.
// Returns an error if the element is not a text element.
//
// Example:
//
//        pdf.ModifyTextElement(1, 0, "New text content")
func (gp *GoPdf) ModifyTextElement(pageNo int, elementIndex int, newText string) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">if elementIndex &lt; 0 || elementIndex &gt;= len(content.listCache.caches) </span><span class="cov8" title="1">{
                return ErrElementIndexOutOfRange
        }</span>
        <span class="cov8" title="1">textElem, ok := content.listCache.caches[elementIndex].(*cacheContentText)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: element %d is %T, not text", ErrElementTypeMismatch, elementIndex, content.listCache.caches[elementIndex])
        }</span>
        <span class="cov8" title="1">textElem.text = newText
        // Recalculate content dimensions if font subset is available.
        if textElem.fontSubset != nil </span><span class="cov8" title="1">{
                textElem.createContent()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ModifyElementPosition moves an element to a new (x, y) position.
// Works for text, image, line (moves start point), rectangle, oval, and polygon elements.
//
// Example:
//
//        pdf.ModifyElementPosition(1, 0, 100, 200) // move element to (100, 200)
func (gp *GoPdf) ModifyElementPosition(pageNo int, elementIndex int, x, y float64) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">if elementIndex &lt; 0 || elementIndex &gt;= len(content.listCache.caches) </span><span class="cov8" title="1">{
                return ErrElementIndexOutOfRange
        }</span>
        <span class="cov8" title="1">c := content.listCache.caches[elementIndex]
        switch v := c.(type) </span>{
        case *cacheContentText:<span class="cov8" title="1">
                v.x = x
                v.y = y</span>
        case *cacheContentImage:<span class="cov8" title="1">
                v.x = x
                v.y = y</span>
        case *cacheContentLine:<span class="cov8" title="1">
                // Shift both endpoints by the delta.
                dx := x - v.x1
                dy := y - v.y1
                v.x1 = x
                v.y1 = y
                v.x2 += dx
                v.y2 += dy</span>
        case cacheContentRectangle:<span class="cov8" title="1">
                v.x = x
                v.y = y
                content.listCache.caches[elementIndex] = v</span> // value type, must reassign
        case *cacheContentOval:<span class="cov8" title="1">
                dx := x - v.x1
                dy := y - v.y1
                v.x1 = x
                v.y1 = y
                v.x2 += dx
                v.y2 += dy</span>
        case *cacheContentPolygon:<span class="cov8" title="1">
                if len(v.points) &gt; 0 </span><span class="cov8" title="1">{
                        dx := x - v.points[0].X
                        dy := y - v.points[0].Y
                        for i := range v.points </span><span class="cov8" title="1">{
                                v.points[i].X += dx
                                v.points[i].Y += dy
                        }</span>
                }
        case *cacheContentPolyline:<span class="cov8" title="1">
                if len(v.points) &gt; 0 </span><span class="cov8" title="1">{
                        dx := x - v.points[0].X
                        dy := y - v.points[0].Y
                        for i := range v.points </span><span class="cov8" title="1">{
                                v.points[i].X += dx
                                v.points[i].Y += dy
                        }</span>
                }
        case *cacheContentSector:<span class="cov8" title="1">
                v.cx = x
                v.cy = y</span>
        case *cacheContentCurve:<span class="cov8" title="1">
                dx := x - v.x0
                dy := y - v.y0
                v.x0 = x
                v.y0 = y
                v.x1 += dx
                v.y1 += dy
                v.x2 += dx
                v.y2 += dy
                v.x3 += dx
                v.y3 += dy</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: cannot reposition element type %T", ErrElementTypeMismatch, c)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// InsertLineElement adds a line to an existing page's content stream.
// Coordinates are in the same units as Line().
//
// Example:
//
//        pdf.InsertLineElement(1, 10, 10, 200, 10) // horizontal line on page 1
func (gp *GoPdf) InsertLineElement(pageNo int, x1, y1, x2, y2 float64) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        pageHeight := gp.config.PageSize.H
        if page != nil &amp;&amp; !page.pageOption.isEmpty() </span><span class="cov0" title="0">{
                pageHeight = page.pageOption.PageSize.H
        }</span>
        <span class="cov8" title="1">cache := &amp;cacheContentLine{
                pageHeight: pageHeight,
                x1:         x1,
                y1:         y1,
                x2:         x2,
                y2:         y2,
        }
        content.listCache.append(cache)
        return nil</span>
}

// InsertRectElement adds a rectangle to an existing page's content stream.
// style: "D" (draw/stroke), "F" (fill), "DF"/"FD" (draw and fill).
//
// Example:
//
//        pdf.InsertRectElement(1, 50, 50, 100, 80, "D")
func (gp *GoPdf) InsertRectElement(pageNo int, x, y, w, h float64, style string) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        pageHeight := gp.config.PageSize.H
        if page != nil &amp;&amp; !page.pageOption.isEmpty() </span><span class="cov0" title="0">{
                pageHeight = page.pageOption.PageSize.H
        }</span>
        <span class="cov8" title="1">ps := PaintStyle(style)
        if ps == "" </span><span class="cov8" title="1">{
                ps = DrawPaintStyle
        }</span>
        <span class="cov8" title="1">cache := cacheContentRectangle{
                pageHeight: pageHeight,
                x:          x,
                y:          y,
                width:      w,
                height:     h,
                style:      ps,
        }
        content.listCache.append(cache)
        return nil</span>
}

// InsertOvalElement adds an oval/ellipse to an existing page's content stream.
//
// Example:
//
//        pdf.InsertOvalElement(1, 50, 50, 150, 100)
func (gp *GoPdf) InsertOvalElement(pageNo int, x1, y1, x2, y2 float64) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        pageHeight := gp.config.PageSize.H
        if page != nil &amp;&amp; !page.pageOption.isEmpty() </span><span class="cov0" title="0">{
                pageHeight = page.pageOption.PageSize.H
        }</span>
        <span class="cov8" title="1">cache := &amp;cacheContentOval{
                pageHeight: pageHeight,
                x1:         x1,
                y1:         y1,
                x2:         x2,
                y2:         y2,
        }
        content.listCache.append(cache)
        return nil</span>
}

// ReplaceElement replaces the content element at the given index with a new ICacheContent.
// This is a low-level method for advanced use cases.
func (gp *GoPdf) ReplaceElement(pageNo int, elementIndex int, newElement ICacheContent) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">if elementIndex &lt; 0 || elementIndex &gt;= len(content.listCache.caches) </span><span class="cov8" title="1">{
                return ErrElementIndexOutOfRange
        }</span>
        <span class="cov8" title="1">content.listCache.caches[elementIndex] = newElement
        return nil</span>
}

// InsertElementAt inserts a new ICacheContent at the specified index position.
// Elements at and after the index are shifted right.
func (gp *GoPdf) InsertElementAt(pageNo int, elementIndex int, newElement ICacheContent) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>
        <span class="cov8" title="1">caches := content.listCache.caches
        if elementIndex &lt; 0 || elementIndex &gt; len(caches) </span><span class="cov0" title="0">{
                return ErrElementIndexOutOfRange
        }</span>
        // Insert at position.
        <span class="cov8" title="1">content.listCache.caches = append(caches[:elementIndex], append([]ICacheContent{newElement}, caches[elementIndex:]...)...)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package gopdf

import (
        "compress/zlib"
        "fmt"
        "io"
        "strings"
)

// ContentObj content object
type ContentObj struct { //impl IObj
        listCache listCacheContent
        //text bytes.Buffer
        getRoot func() *GoPdf
}

func (c *ContentObj) protection() *PDFProtection <span class="cov8" title="1">{
        return c.getRoot().protection()
}</span>

func (c *ContentObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        c.getRoot = funcGetRoot
}</span>

func (c *ContentObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        buff := GetBuffer()
        defer PutBuffer(buff)

        isFlate := (c.getRoot().compressLevel != zlib.NoCompression)
        if isFlate </span><span class="cov8" title="1">{
                ww, err := zlib.NewWriterLevel(buff, c.getRoot().compressLevel)
                if err != nil </span><span class="cov0" title="0">{
                        // should never happen...
                        return err
                }</span>
                <span class="cov8" title="1">if err := c.listCache.write(ww, c.protection()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := ww.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := c.listCache.write(buff, c.protection()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if _, err := io.WriteString(w, "&lt;&lt;\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if isFlate </span><span class="cov8" title="1">{
                if _, err := io.WriteString(w, "/Filter/FlateDecode"); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "/Length %d\n", buff.Len()); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(w, "&gt;&gt;\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := io.WriteString(w, "stream\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if c.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(c.protection().objectkey(objID), buff.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if _, err := w.Write(tmp); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if _, err := buff.WriteTo(w); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if isFlate </span><span class="cov8" title="1">{
                        if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">if _, err := io.WriteString(w, "endstream\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *ContentObj) getType() string <span class="cov8" title="1">{
        return "Content"
}</span>

// AppendStreamText append text
func (c *ContentObj) appendStreamPlaceHolderText(placeHolderWidth float64) error <span class="cov8" title="1">{

        //support only CURRENT_FONT_TYPE_SUBSET
        textColor := c.getRoot().curr.textColor()
        grayFill := c.getRoot().curr.grayFill
        fontCountIndex := c.getRoot().curr.FontFontCount + 1
        fontSize := c.getRoot().curr.FontSize
        fontStyle := c.getRoot().curr.FontStyle
        charSpacing := c.getRoot().curr.CharSpacing
        x := c.getRoot().curr.X
        y := c.getRoot().curr.Y
        setXCount := c.getRoot().curr.setXCount
        fontSubset := c.getRoot().curr.FontISubset

        cellOption := CellOption{Transparency: c.getRoot().curr.transparency}

        cache := cacheContentText{
                fontSubset:     fontSubset,
                rectangle:      nil,
                textColor:      textColor,
                grayFill:       grayFill,
                fontCountIndex: fontCountIndex,
                fontSize:       fontSize,
                fontStyle:      fontStyle,
                charSpacing:    charSpacing,
                setXCount:      setXCount,
                x:              x,
                y:              y,
                cellOpt:        cellOption,
                pageheight:     c.getRoot().curr.pageSize.H,
                contentType:    ContentTypeText,
                lineWidth:      c.getRoot().curr.lineWidth,
                txtColorMode:   c.getRoot().curr.txtColorMode,
                isPlaceHolder:  true,
        }

        //var err error
        //c.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, "")
        //if err != nil {
        //        return err
        //}
        c.listCache.append(&amp;cache)
        c.getRoot().curr.X += placeHolderWidth

        return nil
}</span>

// AppendStreamText append text
func (c *ContentObj) AppendStreamText(text string) error <span class="cov8" title="1">{

        //support only CURRENT_FONT_TYPE_SUBSET
        textColor := c.getRoot().curr.textColor()
        grayFill := c.getRoot().curr.grayFill
        fontCountIndex := c.getRoot().curr.FontFontCount + 1
        fontSize := c.getRoot().curr.FontSize
        fontStyle := c.getRoot().curr.FontStyle
        charSpacing := c.getRoot().curr.CharSpacing
        x := c.getRoot().curr.X
        y := c.getRoot().curr.Y
        setXCount := c.getRoot().curr.setXCount
        fontSubset := c.getRoot().curr.FontISubset

        cellOption := CellOption{Transparency: c.getRoot().curr.transparency}

        cache := cacheContentText{
                fontSubset:     fontSubset,
                rectangle:      nil,
                textColor:      textColor,
                grayFill:       grayFill,
                fontCountIndex: fontCountIndex,
                fontSize:       fontSize,
                fontStyle:      fontStyle,
                charSpacing:    charSpacing,
                setXCount:      setXCount,
                x:              x,
                y:              y,
                cellOpt:        cellOption,
                pageheight:     c.getRoot().curr.pageSize.H,
                contentType:    ContentTypeText,
                lineWidth:      c.getRoot().curr.lineWidth,
                txtColorMode:   c.getRoot().curr.txtColorMode,
        }

        var err error
        c.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AppendStreamSubsetFont add stream of text
func (c *ContentObj) AppendStreamSubsetFont(rectangle *Rect, text string, cellOpt CellOption) error <span class="cov8" title="1">{

        textColor := c.getRoot().curr.textColor()
        grayFill := c.getRoot().curr.grayFill
        fontCountIndex := c.getRoot().curr.FontFontCount + 1
        fontSize := c.getRoot().curr.FontSize
        fontStyle := c.getRoot().curr.FontStyle
        charSpacing := c.getRoot().curr.CharSpacing
        x := c.getRoot().curr.X
        y := c.getRoot().curr.Y
        setXCount := c.getRoot().curr.setXCount
        fontSubset := c.getRoot().curr.FontISubset

        cache := cacheContentText{
                fontSubset:     fontSubset,
                rectangle:      rectangle,
                textColor:      textColor,
                grayFill:       grayFill,
                fontCountIndex: fontCountIndex,
                fontSize:       fontSize,
                fontStyle:      fontStyle,
                charSpacing:    charSpacing,
                setXCount:      setXCount,
                x:              x,
                y:              y,
                pageheight:     c.getRoot().curr.pageSize.H,
                contentType:    ContentTypeCell,
                cellOpt:        cellOpt,
                lineWidth:      c.getRoot().curr.lineWidth,
                txtColorMode:   c.getRoot().curr.txtColorMode,
        }
        var err error
        c.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AppendStreamLine append line
func (c *ContentObj) AppendStreamLine(x1 float64, y1 float64, x2 float64, y2 float64, lineOpts lineOptions) <span class="cov8" title="1">{
        //h := c.getRoot().config.PageSize.H
        //c.stream.WriteString(fmt.Sprintf("%0.2f %0.2f m %0.2f %0.2f l s\n", x1, h-y1, x2, h-y2))
        var cache cacheContentLine
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.x1 = x1
        cache.y1 = y1
        cache.x2 = x2
        cache.y2 = y2
        cache.opts = lineOpts
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamImportedTemplate append imported template
func (c *ContentObj) AppendStreamImportedTemplate(tplName string, scaleX float64, scaleY float64, tX float64, tY float64) <span class="cov8" title="1">{
        var cache cacheContentImportedTemplate
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.tplName = tplName
        cache.scaleX = scaleX
        cache.scaleY = scaleY
        cache.tX = tX
        cache.tY = tY
        c.listCache.append(&amp;cache)
}</span>

func (c *ContentObj) AppendStreamRectangle(opts DrawableRectOptions) <span class="cov8" title="1">{
        cache := NewCacheContentRectangle(c.getRoot().curr.pageSize.H, opts)
        c.listCache.append(cache)
}</span>

// AppendStreamOval append oval
func (c *ContentObj) AppendStreamOval(x1 float64, y1 float64, x2 float64, y2 float64) <span class="cov8" title="1">{
        var cache cacheContentOval
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.x1 = x1
        cache.y1 = y1
        cache.x2 = x2
        cache.y2 = y2
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamCurve draw curve
//   - x0, y0: Start point
//   - x1, y1: Control point 1
//   - x2, y2: Control point 2
//   - x3, y3: End point
//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw. This is the default value.
//     F: fill
//     DF or FD: draw and fill
func (c *ContentObj) AppendStreamCurve(x0 float64, y0 float64, x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64, style string) <span class="cov8" title="1">{
        var cache cacheContentCurve
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.x0 = x0
        cache.y0 = y0
        cache.x1 = x1
        cache.y1 = y1
        cache.x2 = x2
        cache.y2 = y2
        cache.x3 = x3
        cache.y3 = y3
        cache.style = strings.ToUpper(strings.TrimSpace(style))
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetLineWidth : set line width
func (c *ContentObj) AppendStreamSetLineWidth(w float64) <span class="cov8" title="1">{
        var cache cacheContentLineWidth
        cache.width = w
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetLineType : Set linetype [solid, dashed, dotted]
func (c *ContentObj) AppendStreamSetLineType(t string) <span class="cov8" title="1">{
        var cache cacheContentLineType
        cache.lineType = t
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetCustomLineType : set a custom line type
func (c *ContentObj) AppendStreamSetCustomLineType(a []float64, p float64) <span class="cov8" title="1">{
        var cache cacheContentCustomLineType
        cache.dashArray = a
        cache.dashPhase = p
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetGrayFill  set the grayscale fills
func (c *ContentObj) AppendStreamSetGrayFill(w float64) <span class="cov8" title="1">{
        w = fixRange10(w)
        var cache cacheContentGray
        cache.grayType = grayTypeFill
        cache.scale = w
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetGrayStroke  set the grayscale stroke
func (c *ContentObj) AppendStreamSetGrayStroke(w float64) <span class="cov8" title="1">{
        w = fixRange10(w)
        var cache cacheContentGray
        cache.grayType = grayTypeStroke
        cache.scale = w
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetColorStroke  set the color stroke
func (c *ContentObj) AppendStreamSetColorStroke(r uint8, g uint8, b uint8) <span class="cov8" title="1">{
        var cache cacheContentColorRGB
        cache.colorType = colorTypeStrokeRGB
        cache.r = r
        cache.g = g
        cache.b = b
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetColorFill  set the color fill
func (c *ContentObj) AppendStreamSetColorFill(r uint8, g uint8, b uint8) <span class="cov8" title="1">{
        var cache cacheContentColorRGB
        cache.colorType = colorTypeFillRGB
        cache.r = r
        cache.g = g
        cache.b = b
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetColorStrokeCMYK  set the color stroke in CMYK color mode
func (c *ContentObj) AppendStreamSetColorStrokeCMYK(cy, m, y, k uint8) <span class="cov8" title="1">{
        var cache cacheContentColorCMYK
        cache.colorType = colorTypeStrokeCMYK
        cache.c = cy
        cache.m = m
        cache.y = y
        cache.k = k
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSetColorFillCMYK  set the color fill in CMYK color mode
func (c *ContentObj) AppendStreamSetColorFillCMYK(cy, m, y, k uint8) <span class="cov8" title="1">{
        var cache cacheContentColorCMYK
        cache.colorType = colorTypeFillCMYK
        cache.c = cy
        cache.m = m
        cache.y = y
        cache.k = k
        c.listCache.append(&amp;cache)
}</span>

func (c *ContentObj) GetCacheContentImage(index int, opts ImageOptions) *cacheContentImage <span class="cov8" title="1">{
        h := c.getRoot().curr.pageSize.H

        withMask := false
        maskAngle := float64(0)

        if opts.Mask != nil </span><span class="cov8" title="1">{
                withMask = true
                maskAngle = opts.Mask.DegreeAngle
        }</span>

        <span class="cov8" title="1">return &amp;cacheContentImage{
                withMask:         withMask,
                imageAngle:       opts.DegreeAngle,
                maskAngle:        maskAngle,
                pageHeight:       h,
                index:            index,
                x:                opts.X,
                y:                opts.Y,
                rect:             *opts.Rect,
                crop:             opts.Crop,
                verticalFlip:     opts.VerticalFlip,
                horizontalFlip:   opts.HorizontalFlip,
                extGStateIndexes: opts.extGStateIndexes,
        }</span>
}

// AppendStreamImage append image
func (c *ContentObj) AppendStreamImage(index int, opts ImageOptions) <span class="cov8" title="1">{
        cache := c.GetCacheContentImage(index, opts)
        c.listCache.append(cache)
}</span>

// AppendStreamPolygon append polygon
func (c *ContentObj) AppendStreamPolygon(points []Point, style string, opts polygonOptions) <span class="cov8" title="1">{
        var cache cacheContentPolygon
        cache.points = points
        cache.style = style
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.opts = opts
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamPolyline appends a polyline (open path, stroke only).
func (c *ContentObj) AppendStreamPolyline(points []Point, opts polylineOptions) <span class="cov8" title="1">{
        var cache cacheContentPolyline
        cache.points = points
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.opts = opts
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSector appends a sector (pie/fan shape).
func (c *ContentObj) AppendStreamSector(cx, cy, r, startDeg, endDeg float64, style string, opts sectorOptions) <span class="cov8" title="1">{
        var cache cacheContentSector
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.cx = cx
        cache.cy = cy
        cache.r = r
        cache.startDeg = startDeg
        cache.endDeg = endDeg
        cache.style = style
        cache.opts = opts
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamClipPolygon sets a clipping path from polygon points.
func (c *ContentObj) AppendStreamClipPolygon(points []Point) <span class="cov8" title="1">{
        var cache cacheContentClipPolygon
        cache.points = points
        cache.pageHeight = c.getRoot().curr.pageSize.H
        c.listCache.append(&amp;cache)
}</span>

// AppendStreamSaveGraphicsState saves the current graphics state (q operator).
func (c *ContentObj) AppendStreamSaveGraphicsState() <span class="cov8" title="1">{
        c.listCache.append(&amp;cacheContentSaveGraphicsState{})
}</span>

// AppendStreamRestoreGraphicsState restores the graphics state (Q operator).
func (c *ContentObj) AppendStreamRestoreGraphicsState() <span class="cov8" title="1">{
        c.listCache.append(&amp;cacheContentRestoreGraphicsState{})
}</span>

func (c *ContentObj) appendRotate(angle, x, y float64) <span class="cov8" title="1">{
        var cache cacheContentRotate
        cache.isReset = false
        cache.pageHeight = c.getRoot().curr.pageSize.H
        cache.angle = angle
        cache.x = x
        cache.y = y
        c.listCache.append(&amp;cache)
}</span>

func (c *ContentObj) appendRotateReset() <span class="cov8" title="1">{
        var cache cacheContentRotate
        cache.isReset = true
        c.listCache.append(&amp;cache)
}</span>

func (c *ContentObj) appendColorSpace(countOfSpaceColor int) <span class="cov8" title="1">{
        var cache cacheColorSpace
        cache.countOfSpaceColor = countOfSpaceColor
        c.listCache.append(&amp;cache)
}</span>

// ContentObjCalTextHeight : calculates height of text.
func ContentObjCalTextHeight(fontsize int) float64 <span class="cov8" title="1">{
        return ContentObjCalTextHeightPrecise(float64(fontsize))
}</span>

// ContentObjCalTextHeightPrecise : like ContentObjCalTextHeight,
// but fontsize float64
func ContentObjCalTextHeightPrecise(fontsize float64) float64 <span class="cov8" title="1">{
        return (float64(fontsize) * 0.7)
}</span>

// When setting colour and grayscales the value has to be between 0.00 and 1.00
// This function takes a float64 and returns 0.0 if it is less than 0.0 and 1.0 if it
// is more than 1.0
func fixRange10(val float64) float64 <span class="cov8" title="1">{
        if val &lt; 0.0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">if val &gt; 1.0 </span><span class="cov8" title="1">{
                return 1.0
        }</span>
        <span class="cov8" title="1">return val</span>
}

func convertTTFUnit2PDFUnit(n int, upem int) int <span class="cov8" title="1">{
        var ret int
        if n &lt; 0 </span><span class="cov8" title="1">{
                rest1 := n % upem
                storrest := 1000 * rest1
                //ledd2 := (storrest != 0 ? rest1 / storrest : 0);
                ledd2 := 0
                if storrest != 0 </span><span class="cov8" title="1">{
                        ledd2 = rest1 / storrest
                }</span> else<span class="cov0" title="0"> {
                        ledd2 = 0
                }</span>
                <span class="cov8" title="1">ret = -((-1000*n)/upem - int(ledd2))</span>
        } else<span class="cov8" title="1"> {
                ret = (n/upem)*1000 + ((n%upem)*1000)/upem
        }</span>
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package gopdf

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "regexp"
        "strings"
)

// Pre-compiled regexes for content stream cleaning.
var (
        reMultiSpace = regexp.MustCompile(`\s+`)
        reDictLength = regexp.MustCompile(`/Length\s+\d+`)
)

// CleanContentStreams optimizes all content streams in the given PDF data
// by removing redundant operators, consolidating state changes, and
// normalizing whitespace. Returns the cleaned PDF data.
//
// This is a standalone function that operates on raw PDF bytes, similar
// to RecompressImages.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        cleaned, err := gopdf.CleanContentStreams(data)
//        os.WriteFile("output.pdf", cleaned, 0644)
func CleanContentStreams(pdfData []byte) ([]byte, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF: %w", err)
        }</span>

        <span class="cov8" title="1">result := make([]byte, len(pdfData))
        copy(result, pdfData)

        modified := false
        for _, page := range parser.pages </span><span class="cov8" title="1">{
                for _, contentRef := range page.contents </span><span class="cov8" title="1">{
                        obj, ok := parser.objects[contentRef]
                        if !ok || obj.stream == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">cleaned := cleanContentStream(obj.stream)
                        if len(cleaned) &gt;= len(obj.stream) </span><span class="cov8" title="1">{
                                continue</span> // no improvement
                        }

                        // Compress the cleaned stream.
                        <span class="cov8" title="1">var compressed bytes.Buffer
                        w, err := zlib.NewWriterLevel(&amp;compressed, zlib.DefaultCompression)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">w.Write(cleaned)
                        w.Close()

                        newDict := buildCleanedDict(obj.dict, compressed.Len())
                        result = replaceObjectStream(result, contentRef, newDict, compressed.Bytes())
                        modified = true</span>
                }
        }

        <span class="cov8" title="1">if !modified </span><span class="cov8" title="1">{
                return pdfData, nil
        }</span>

        <span class="cov8" title="1">result = rebuildXref(result)
        return result, nil</span>
}

// cleanContentStream optimizes a single content stream by removing
// redundant operators and normalizing whitespace.
func cleanContentStream(stream []byte) []byte <span class="cov8" title="1">{
        lines := splitContentLines(stream)
        lines = removeRedundantStateChanges(lines)
        lines = removeEmptyQBlocks(lines)
        lines = normalizeWhitespace(lines)
        return joinContentLines(lines)
}</span>

// splitContentLines splits a content stream into logical operator lines.
func splitContentLines(stream []byte) []string <span class="cov8" title="1">{
        text := string(stream)
        // Split on newlines, keeping each operator on its own line.
        raw := strings.Split(text, "\n")
        var lines []string
        for _, line := range raw </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if trimmed != "" </span><span class="cov8" title="1">{
                        lines = append(lines, trimmed)
                }</span>
        }
        <span class="cov8" title="1">return lines</span>
}

// removeRedundantStateChanges removes consecutive duplicate state-setting
// operators where only the last one matters.
func removeRedundantStateChanges(lines []string) []string <span class="cov8" title="1">{
        if len(lines) == 0 </span><span class="cov8" title="1">{
                return lines
        }</span>

        // Operators where consecutive duplicates can be collapsed.
        <span class="cov8" title="1">stateOps := map[string]bool{
                "w":  true, // line width
                "J":  true, // line cap
                "j":  true, // line join
                "M":  true, // miter limit
                "d":  true, // dash pattern
                "ri": true, // rendering intent
                "i":  true, // flatness
                "Tc": true, // character spacing
                "Tw": true, // word spacing
                "Tz": true, // horizontal scaling
                "TL": true, // text leading
                "Tr": true, // text rendering mode
                "Ts": true, // text rise
        }

        result := make([]string, 0, len(lines))
        for i, line := range lines </span><span class="cov8" title="1">{
                op := extractOperator(line)
                if !stateOps[op] </span><span class="cov8" title="1">{
                        result = append(result, line)
                        continue</span>
                }
                // Check if the next line has the same operator.
                <span class="cov8" title="1">if i+1 &lt; len(lines) &amp;&amp; extractOperator(lines[i+1]) == op </span><span class="cov8" title="1">{
                        continue</span> // skip this one, the next one overrides it
                }
                <span class="cov8" title="1">result = append(result, line)</span>
        }
        <span class="cov8" title="1">return result</span>
}

// removeEmptyQBlocks removes q/Q pairs that contain no drawing operations.
func removeEmptyQBlocks(lines []string) []string <span class="cov8" title="1">{
        changed := true
        for changed </span><span class="cov8" title="1">{
                changed = false
                result := make([]string, 0, len(lines))
                i := 0
                for i &lt; len(lines) </span><span class="cov8" title="1">{
                        if lines[i] == "q" &amp;&amp; i+1 &lt; len(lines) &amp;&amp; lines[i+1] == "Q" </span><span class="cov8" title="1">{
                                // Empty save/restore block â€” skip both.
                                i += 2
                                changed = true
                                continue</span>
                        }
                        <span class="cov8" title="1">result = append(result, lines[i])
                        i++</span>
                }
                <span class="cov8" title="1">lines = result</span>
        }
        <span class="cov8" title="1">return lines</span>
}

// normalizeWhitespace trims excess whitespace from each line.
func normalizeWhitespace(lines []string) []string <span class="cov8" title="1">{
        result := make([]string, len(lines))
        for i, line := range lines </span><span class="cov8" title="1">{
                result[i] = reMultiSpace.ReplaceAllString(strings.TrimSpace(line), " ")
        }</span>
        <span class="cov8" title="1">return result</span>
}

// joinContentLines joins cleaned lines back into a content stream.
func joinContentLines(lines []string) []byte <span class="cov8" title="1">{
        return []byte(strings.Join(lines, "\n") + "\n")
}</span>

// extractOperator extracts the PDF operator from a content stream line.
// PDF operators are the last token on the line (e.g., "1.0 0 0 1 0 0 cm" -&gt; "cm").
func extractOperator(line string) string <span class="cov8" title="1">{
        line = strings.TrimSpace(line)
        if line == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        // Handle special cases for operators that are single characters.
        <span class="cov8" title="1">parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return parts[len(parts)-1]</span>
}

// buildCleanedDict updates the /Length in a dictionary and ensures /FlateDecode filter.
func buildCleanedDict(origDict string, newLen int) string <span class="cov8" title="1">{
        // Replace /Length value.
        dict := reDictLength.ReplaceAllString(origDict, fmt.Sprintf("/Length %d", newLen))

        // Ensure /Filter /FlateDecode is present.
        if !strings.Contains(dict, "/FlateDecode") </span><span class="cov8" title="1">{
                dict = strings.Replace(dict, "&gt;&gt;", "/Filter /FlateDecode\n&gt;&gt;", 1)
        }</span>

        <span class="cov8" title="1">return dict</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package gopdf

// Current current state
type Current struct {
        setXCount int //many times we go func SetX()
        X         float64
        Y         float64

        //font
        IndexOfFontObj int
        CountOfFont    int
        CountOfL       int

        FontSize      float64
        FontStyle     int // Regular|Bold|Italic|Underline
        FontFontCount int
        FontType      int // CURRENT_FONT_TYPE_IFONT or  CURRENT_FONT_TYPE_SUBSET

        IndexOfColorSpaceObj int
        CountOfColorSpace    int

        CharSpacing float64

        FontISubset *SubsetFontObj // FontType == CURRENT_FONT_TYPE_SUBSET

        //page
        IndexOfPageObj int

        //img
        CountOfImg int
        //cache of image in pdf file
        ImgCaches map[int]ImageCache

        //text color mode
        txtColorMode string //color, gray

        //text color
        txtColor ICacheColorText

        //text grayscale
        grayFill float64
        //draw grayscale
        grayStroke float64

        lineWidth float64

        //current page size
        pageSize *Rect

        //current trim box
        trimBox *Box

        sMasksMap       SMaskMap
        extGStatesMap   ExtGStatesMap
        transparency    *Transparency
        transparencyMap TransparencyMap
}

func (c *Current) setTextColor(color ICacheColorText) <span class="cov8" title="1">{
        c.txtColor = color
}</span>

func (c *Current) textColor() ICacheColorText <span class="cov8" title="1">{
        return c.txtColor
}</span>

// ImageCache is metadata for caching images.
type ImageCache struct {
        Path  string //ID or Path
        Index int
        Rect  *Rect
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// DeviceRGBObj  DeviceRGB
type DeviceRGBObj struct {
        data    []byte
        getRoot func() *GoPdf
}

func (d *DeviceRGBObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        d.getRoot = funcGetRoot
}</span>

func (d *DeviceRGBObj) protection() *PDFProtection <span class="cov8" title="1">{
        return d.getRoot().protection()
}</span>

func (d *DeviceRGBObj) getType() string <span class="cov8" title="1">{
        return "devicergb"
}</span>

// à¸ªà¸£à¹‰à¸²à¸‡ à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™ pdf
func (d *DeviceRGBObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{

        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/Length %d\n", len(d.data))
        io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "stream\n")
        if d.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(d.protection().objectkey(objID), d.data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.Write(tmp)
                io.WriteString(w, "\n")</span>
        } else<span class="cov8" title="1"> {
                w.Write(d.data)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "endstream\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package gopdf

import (
        "bytes"
        "crypto"
        "crypto/ecdsa"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "io"
        "os"
        "time"

        "go.mozilla.org/pkcs7"
)

// SignatureConfig holds the configuration for digitally signing a PDF.
type SignatureConfig struct {
        // Certificate is the X.509 signing certificate.
        Certificate *x509.Certificate
        // CertificateChain is the optional intermediate certificate chain.
        CertificateChain []*x509.Certificate
        // PrivateKey is the signer's private key (must be *rsa.PrivateKey or *ecdsa.PrivateKey).
        PrivateKey crypto.Signer

        // Reason is the reason for signing (e.g. "Approved").
        Reason string
        // Location is the signing location (e.g. "Beijing").
        Location string
        // ContactInfo is the signer's contact information.
        ContactInfo string
        // Name is the signer's name. If empty, the certificate's CN is used.
        Name string

        // SignTime is the signing time. Defaults to time.Now().
        SignTime time.Time

        // SignatureFieldName is the name of the signature form field.
        // If empty, defaults to "Signature1".
        SignatureFieldName string

        // Visible controls whether the signature has a visible appearance.
        Visible bool
        // X, Y, W, H define the visible signature rectangle (only used when Visible is true).
        X, Y, W, H float64
        // PageNo is the 1-based page number for the visible signature. Default: 1.
        PageNo int
}

func (cfg *SignatureConfig) defaults() <span class="cov8" title="1">{
        if cfg.SignTime.IsZero() </span><span class="cov8" title="1">{
                cfg.SignTime = time.Now()
        }</span>
        <span class="cov8" title="1">if cfg.SignatureFieldName == "" </span><span class="cov8" title="1">{
                cfg.SignatureFieldName = "Signature1"
        }</span>
        <span class="cov8" title="1">if cfg.Name == "" &amp;&amp; cfg.Certificate != nil </span><span class="cov8" title="1">{
                cfg.Name = cfg.Certificate.Subject.CommonName
        }</span>
        <span class="cov8" title="1">if cfg.PageNo &lt;= 0 </span><span class="cov8" title="1">{
                cfg.PageNo = 1
        }</span>
}

// LoadCertificateFromPEM loads an X.509 certificate from a PEM file.
func LoadCertificateFromPEM(certPath string) (*x509.Certificate, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(certPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read certificate file: %w", err)
        }</span>
        <span class="cov0" title="0">return ParseCertificatePEM(data)</span>
}

// ParseCertificatePEM parses an X.509 certificate from PEM-encoded data.
func ParseCertificatePEM(data []byte) (*x509.Certificate, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(data)
        if block == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no PEM block found in certificate data")
        }</span>
        <span class="cov8" title="1">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse certificate: %w", err)
        }</span>
        <span class="cov8" title="1">return cert, nil</span>
}

// LoadPrivateKeyFromPEM loads a private key (RSA or ECDSA) from a PEM file.
func LoadPrivateKeyFromPEM(keyPath string) (crypto.Signer, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(keyPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read key file: %w", err)
        }</span>
        <span class="cov0" title="0">return ParsePrivateKeyPEM(data)</span>
}

// ParsePrivateKeyPEM parses a private key from PEM-encoded data.
// Supports RSA, ECDSA, and PKCS#8 encoded keys.
func ParsePrivateKeyPEM(data []byte) (crypto.Signer, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(data)
        if block == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no PEM block found in key data")
        }</span>

        <span class="cov8" title="1">switch block.Type </span>{
        case "RSA PRIVATE KEY":<span class="cov8" title="1">
                return x509.ParsePKCS1PrivateKey(block.Bytes)</span>
        case "EC PRIVATE KEY":<span class="cov8" title="1">
                return x509.ParseECPrivateKey(block.Bytes)</span>
        case "PRIVATE KEY":<span class="cov8" title="1">
                key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse PKCS8 key: %w", err)
                }</span>
                <span class="cov8" title="1">if signer, ok := key.(crypto.Signer); ok </span><span class="cov8" title="1">{
                        return signer, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("PKCS8 key does not implement crypto.Signer")</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported PEM block type: %s", block.Type)</span>
        }
}

// LoadCertificateChainFromPEM loads a chain of certificates from a PEM file.
func LoadCertificateChainFromPEM(chainPath string) ([]*x509.Certificate, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(chainPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read chain file: %w", err)
        }</span>
        <span class="cov0" title="0">return ParseCertificateChainPEM(data)</span>
}

// ParseCertificateChainPEM parses a chain of certificates from PEM-encoded data.
func ParseCertificateChainPEM(data []byte) ([]*x509.Certificate, error) <span class="cov8" title="1">{
        var certs []*x509.Certificate
        rest := data
        for </span><span class="cov8" title="1">{
                var block *pem.Block
                block, rest = pem.Decode(rest)
                if block == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if block.Type != "CERTIFICATE" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">cert, err := x509.ParseCertificate(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse certificate in chain: %w", err)
                }</span>
                <span class="cov8" title="1">certs = append(certs, cert)</span>
        }
        <span class="cov8" title="1">if len(certs) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no certificates found in chain data")
        }</span>
        <span class="cov8" title="1">return certs, nil</span>
}

// signatureByteRangeSize is the reserved space for the ByteRange value.
// Format: [0 offset1 offset2 length] â€” we reserve enough digits.
const signatureByteRangeSize = 60

// signatureContentsSize is the reserved hex-encoded signature space (8KB).
// PKCS#7 signatures are typically 2-6KB; 8KB provides ample room.
const signatureContentsSize = 8192

// SignPDF digitally signs the PDF document and writes the signed output.
//
// This creates a PKCS#7 detached signature (adbe.pkcs7.detached) embedded
// in the PDF, compatible with Adobe Reader and other PDF viewers.
//
// The signing process:
//  1. Builds the PDF with a placeholder signature dictionary
//  2. Computes the byte ranges excluding the signature contents
//  3. Signs the byte ranges using PKCS#7
//  4. Patches the signature contents into the final output
//
// Example:
//
//        cert, _ := gopdf.LoadCertificateFromPEM("cert.pem")
//        key, _ := gopdf.LoadPrivateKeyFromPEM("key.pem")
//        pdf.SignPDF(gopdf.SignatureConfig{
//            Certificate: cert,
//            PrivateKey:  key,
//            Reason:      "Document Approval",
//            Location:    "Beijing",
//        }, w)
func (gp *GoPdf) SignPDF(cfg SignatureConfig, w io.Writer) error <span class="cov8" title="1">{
        cfg.defaults()

        if cfg.Certificate == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("gopdf: SignatureConfig.Certificate is required")
        }</span>
        <span class="cov8" title="1">if cfg.PrivateKey == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("gopdf: SignatureConfig.PrivateKey is required")
        }</span>

        // Validate key type
        <span class="cov8" title="1">switch cfg.PrivateKey.(type) </span>{
        case *rsa.PrivateKey, *ecdsa.PrivateKey:<span class="cov8" title="1"></span>
                // OK
        default:<span class="cov0" title="0">
                return fmt.Errorf("gopdf: unsupported private key type %T", cfg.PrivateKey)</span>
        }

        // Create the signature value object (placeholder).
        <span class="cov8" title="1">sigValObj := &amp;signatureValueObj{
                cfg:          &amp;cfg,
                contentsSize: signatureContentsSize,
        }
        sigValIdx := gp.addObj(sigValObj)
        sigValObjID := sigValIdx + 1

        // Create the signature field widget.
        sigFieldObj := &amp;signatureFieldObj{
                cfg:         &amp;cfg,
                sigValueRef: sigValObjID,
                getRoot:     func() *GoPdf </span><span class="cov8" title="1">{ return gp }</span>,
        }
        <span class="cov8" title="1">sigFieldIdx := gp.addObj(sigFieldObj)

        // Register the signature field in the form fields list so AcroForm picks it up.
        gp.formFields = append(gp.formFields, formFieldRef{
                field: FormField{
                        Type: FormFieldSignature,
                        Name: cfg.SignatureFieldName,
                },
                objIdx: sigFieldIdx,
        })

        // Add the widget annotation to the target page.
        if cfg.Visible </span><span class="cov8" title="1">{
                pageObj := gp.findPageObjByNumber(cfg.PageNo)
                if pageObj != nil </span><span class="cov8" title="1">{
                        pageObj.LinkObjIds = append(pageObj.LinkObjIds, sigFieldIdx+1)
                }</span>
        }

        // Render the PDF into a buffer.
        <span class="cov8" title="1">var buf bytes.Buffer
        if _, err := gp.compilePdf(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: compile PDF for signing: %w", err)
        }</span>
        <span class="cov8" title="1">pdfBytes := buf.Bytes()

        // Locate the signature contents placeholder to compute byte ranges.
        contentsStart, contentsEnd, err := sigValObj.findContentsPlaceholder(pdfBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: %w", err)
        }</span>

        // Byte ranges: [0, contentsStart, contentsEnd, totalLen-contentsEnd]
        <span class="cov8" title="1">totalLen := len(pdfBytes)
        byteRange := [4]int{0, contentsStart, contentsEnd, totalLen - contentsEnd}

        // Patch the ByteRange value in the PDF.
        byteRangeStr := fmt.Sprintf("[%d %d %d %d]", byteRange[0], byteRange[1], byteRange[2], byteRange[3])
        // Pad to fixed width
        for len(byteRangeStr) &lt; signatureByteRangeSize </span><span class="cov8" title="1">{
                byteRangeStr += " "
        }</span>
        <span class="cov8" title="1">brPlaceholder := sigValObj.byteRangePlaceholder()
        brOffset := bytes.Index(pdfBytes, []byte(brPlaceholder))
        if brOffset &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: ByteRange placeholder not found in PDF output")
        }</span>
        <span class="cov8" title="1">copy(pdfBytes[brOffset:brOffset+len(brPlaceholder)], []byte(byteRangeStr))

        // Collect the data to sign (everything except the Contents hex string).
        signedData := make([]byte, 0, byteRange[1]+byteRange[3])
        signedData = append(signedData, pdfBytes[byteRange[0]:byteRange[0]+byteRange[1]]...)
        signedData = append(signedData, pdfBytes[byteRange[2]:byteRange[2]+byteRange[3]]...)

        // Create PKCS#7 detached signature.
        pkcs7Sig, err := createPKCS7Signature(signedData, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: create PKCS#7 signature: %w", err)
        }</span>

        // Hex-encode the signature and patch it into the Contents.
        <span class="cov8" title="1">hexSig := fmt.Sprintf("%X", pkcs7Sig)
        if len(hexSig) &gt; signatureContentsSize*2 </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: PKCS#7 signature too large (%d bytes, max %d)", len(pkcs7Sig), signatureContentsSize)
        }</span>
        // Pad with zeros
        <span class="cov8" title="1">for len(hexSig) &lt; signatureContentsSize*2 </span><span class="cov8" title="1">{
                hexSig += "0"
        }</span>

        // The Contents value in the PDF is &lt;placeholder...&gt;
        // contentsStart points to '&lt;', contentsEnd points after '&gt;'
        // We need to replace the hex content between &lt; and &gt;
        <span class="cov8" title="1">copy(pdfBytes[contentsStart+1:contentsEnd-1], []byte(hexSig))

        // Write the final signed PDF.
        if _, err := w.Write(pdfBytes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: write signed PDF: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SignPDFToFile signs the PDF and writes it to a file.
func (gp *GoPdf) SignPDFToFile(cfg SignatureConfig, path string) error <span class="cov8" title="1">{
        f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gopdf: create file: %w", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        return gp.SignPDF(cfg, f)</span>
}

// createPKCS7Signature creates a PKCS#7 detached signature over the given data.
func createPKCS7Signature(data []byte, cfg *SignatureConfig) ([]byte, error) <span class="cov8" title="1">{
        signedData, err := pkcs7.NewSignedData(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("new signed data: %w", err)
        }</span>

        <span class="cov8" title="1">signerConfig := pkcs7.SignerInfoConfig{}
        if err := signedData.AddSigner(cfg.Certificate, cfg.PrivateKey, signerConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("add signer: %w", err)
        }</span>

        // Add certificate chain
        <span class="cov8" title="1">for _, cert := range cfg.CertificateChain </span><span class="cov8" title="1">{
                signedData.AddCertificate(cert)
        }</span>

        // Detach content â€” the signature does not embed the original data
        <span class="cov8" title="1">signedData.Detach()

        return signedData.Finish()</span>
}

// findPageObjByNumber returns the PageObj for the given 1-based page number.
func (gp *GoPdf) findPageObjByNumber(pageNo int) *PageObj <span class="cov8" title="1">{
        count := 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if p, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        count++
                        if count == pageNo </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// AddSignatureField adds an empty (unsigned) signature field to the current page.
// This can be used to create a signature placeholder that can be signed later.
func (gp *GoPdf) AddSignatureField(name string, x, y, w, h float64) error <span class="cov8" title="1">{
        return gp.AddFormField(FormField{
                Type:        FormFieldSignature,
                Name:        name,
                X:           x,
                Y:           y,
                W:           w,
                H:           h,
                HasBorder:   true,
                BorderColor: [3]uint8{0, 0, 0},
        })
}</span>

// VerifySignatureFromFile reads a signed PDF file and verifies its digital signatures.
func VerifySignatureFromFile(path string) ([]SignatureVerifyResult, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read PDF: %w", err)
        }</span>
        <span class="cov8" title="1">return VerifySignature(data)</span>
}

// SignatureVerifyResult holds the result of verifying a single PDF signature.
type SignatureVerifyResult struct {
        // SignerName is the common name from the signing certificate.
        SignerName string
        // Valid is true if the signature is cryptographically valid.
        Valid bool
        // Reason is the stated reason for signing.
        Reason string
        // Location is the stated signing location.
        Location string
        // SignTime is the stated signing time.
        SignTime time.Time
        // Error contains the verification error, if any.
        Error error
}

// VerifySignature verifies digital signatures in a PDF byte slice.
// It extracts PKCS#7 signatures and validates them against the signed byte ranges.
func VerifySignature(pdfData []byte) ([]SignatureVerifyResult, error) <span class="cov8" title="1">{
        sigs, err := extractSignatures(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(sigs) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no digital signatures found in PDF")
        }</span>

        <span class="cov8" title="1">var results []SignatureVerifyResult
        for _, sig := range sigs </span><span class="cov8" title="1">{
                result := SignatureVerifyResult{
                        Reason:   sig.reason,
                        Location: sig.location,
                        SignTime: sig.signTime,
                }

                // Collect signed data from byte ranges
                signedData := make([]byte, 0)
                for i := 0; i+1 &lt; len(sig.byteRange); i += 2 </span><span class="cov8" title="1">{
                        offset := sig.byteRange[i]
                        length := sig.byteRange[i+1]
                        if offset+length &gt; len(pdfData) </span><span class="cov0" title="0">{
                                result.Error = fmt.Errorf("byte range exceeds PDF size")
                                result.Valid = false
                                results = append(results, result)
                                continue</span>
                        }
                        <span class="cov8" title="1">signedData = append(signedData, pdfData[offset:offset+length]...)</span>
                }

                // Parse and verify PKCS#7
                <span class="cov8" title="1">p7, err := pkcs7.Parse(sig.contents)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("parse PKCS#7: %w", err)
                        result.Valid = false
                        results = append(results, result)
                        continue</span>
                }

                // For detached signatures, set the content to the signed data
                <span class="cov8" title="1">p7.Content = signedData

                if err := p7.Verify(); err != nil </span><span class="cov8" title="1">{
                        result.Error = fmt.Errorf("verify signature: %w", err)
                        result.Valid = false
                }</span> else<span class="cov8" title="1"> {
                        result.Valid = true
                }</span>

                // Extract signer name
                <span class="cov8" title="1">if len(p7.Signers) &gt; 0 </span><span class="cov8" title="1">{
                        for _, cert := range p7.Certificates </span><span class="cov8" title="1">{
                                if cert.SerialNumber.Cmp(p7.Signers[0].IssuerAndSerialNumber.SerialNumber) == 0 </span><span class="cov8" title="1">{
                                        result.SignerName = cert.Subject.CommonName
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">results = append(results, result)</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}

// rawSignature holds extracted signature data from a PDF.
type rawSignature struct {
        contents  []byte
        byteRange []int
        reason    string
        location  string
        signTime  time.Time
}

// extractSignatures does a simple scan of the PDF for signature dictionaries.
// This is a lightweight parser â€” it finds /Type /Sig dictionaries and extracts
// the /Contents and /ByteRange values.
func extractSignatures(pdfData []byte) ([]rawSignature, error) <span class="cov8" title="1">{
        var sigs []rawSignature

        // Scan for /Type /Sig patterns
        searchFrom := 0
        for </span><span class="cov8" title="1">{
                idx := bytes.Index(pdfData[searchFrom:], []byte("/Type /Sig"))
                if idx &lt; 0 </span><span class="cov8" title="1">{
                        // Also try /Type/Sig (no space)
                        idx = bytes.Index(pdfData[searchFrom:], []byte("/Type/Sig"))
                        if idx &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">pos := searchFrom + idx

                // Find the dictionary boundaries (scan backward for &lt;&lt;, forward for &gt;&gt;)
                dictStart := bytes.LastIndex(pdfData[:pos], []byte("&lt;&lt;"))
                if dictStart &lt; 0 </span><span class="cov0" title="0">{
                        searchFrom = pos + 10
                        continue</span>
                }

                // Find matching &gt;&gt; (simple approach: find next &gt;&gt;)
                <span class="cov8" title="1">dictEnd := bytes.Index(pdfData[pos:], []byte("&gt;&gt;"))
                if dictEnd &lt; 0 </span><span class="cov0" title="0">{
                        searchFrom = pos + 10
                        continue</span>
                }
                <span class="cov8" title="1">dictEnd = pos + dictEnd + 2
                dict := pdfData[dictStart:dictEnd]

                sig := rawSignature{}

                // Extract /ByteRange [...]
                if brIdx := bytes.Index(dict, []byte("/ByteRange")); brIdx &gt;= 0 </span><span class="cov8" title="1">{
                        brStart := bytes.Index(dict[brIdx:], []byte("["))
                        brEnd := bytes.Index(dict[brIdx:], []byte("]"))
                        if brStart &gt;= 0 &amp;&amp; brEnd &gt; brStart </span><span class="cov8" title="1">{
                                brStr := string(dict[brIdx+brStart+1 : brIdx+brEnd])
                                sig.byteRange = parseIntArray(brStr)
                        }</span>
                }

                // Extract /Contents &lt;hex&gt;
                <span class="cov8" title="1">if cIdx := bytes.Index(dict, []byte("/Contents")); cIdx &gt;= 0 </span><span class="cov8" title="1">{
                        rest := dict[cIdx+9:]
                        hexStart := bytes.IndexByte(rest, '&lt;')
                        hexEnd := bytes.IndexByte(rest, '&gt;')
                        if hexStart &gt;= 0 &amp;&amp; hexEnd &gt; hexStart </span><span class="cov8" title="1">{
                                hexStr := string(rest[hexStart+1 : hexEnd])
                                sig.contents = hexDecode(hexStr)
                        }</span>
                }

                // Extract /Reason
                <span class="cov8" title="1">if rIdx := bytes.Index(dict, []byte("/Reason")); rIdx &gt;= 0 </span><span class="cov8" title="1">{
                        sig.reason = extractPDFString(dict[rIdx+7:])
                }</span>

                // Extract /Location
                <span class="cov8" title="1">if lIdx := bytes.Index(dict, []byte("/Location")); lIdx &gt;= 0 </span><span class="cov8" title="1">{
                        sig.location = extractPDFString(dict[lIdx+9:])
                }</span>

                <span class="cov8" title="1">if len(sig.byteRange) &gt;= 4 &amp;&amp; len(sig.contents) &gt; 0 </span><span class="cov8" title="1">{
                        sigs = append(sigs, sig)
                }</span>

                <span class="cov8" title="1">searchFrom = dictEnd</span>
        }

        <span class="cov8" title="1">return sigs, nil</span>
}

// parseIntArray parses space-separated integers from a string.
func parseIntArray(s string) []int <span class="cov8" title="1">{
        var nums []int
        var current []byte
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                c := s[i]
                if c &gt;= '0' &amp;&amp; c &lt;= '9' </span><span class="cov8" title="1">{
                        current = append(current, c)
                }</span> else<span class="cov8" title="1"> if len(current) &gt; 0 </span><span class="cov8" title="1">{
                        n := 0
                        for _, d := range current </span><span class="cov8" title="1">{
                                n = n*10 + int(d-'0')
                        }</span>
                        <span class="cov8" title="1">nums = append(nums, n)
                        current = current[:0]</span>
                }
        }
        <span class="cov8" title="1">if len(current) &gt; 0 </span><span class="cov8" title="1">{
                n := 0
                for _, d := range current </span><span class="cov8" title="1">{
                        n = n*10 + int(d-'0')
                }</span>
                <span class="cov8" title="1">nums = append(nums, n)</span>
        }
        <span class="cov8" title="1">return nums</span>
}

// hexDecode decodes a hex string to bytes.
func hexDecode(s string) []byte <span class="cov8" title="1">{
        // Remove whitespace and trailing zeros
        s = trimTrailingZeros(s)
        if len(s)%2 != 0 </span><span class="cov0" title="0">{
                s += "0"
        }</span>
        <span class="cov8" title="1">result := make([]byte, len(s)/2)
        for i := 0; i &lt; len(s); i += 2 </span><span class="cov8" title="1">{
                result[i/2] = hexByte(s[i])&lt;&lt;4 | hexByte(s[i+1])
        }</span>
        <span class="cov8" title="1">return result</span>
}

func hexByte(c byte) byte <span class="cov8" title="1">{
        switch </span>{
        case c &gt;= '0' &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                return c - '0'</span>
        case c &gt;= 'A' &amp;&amp; c &lt;= 'F':<span class="cov8" title="1">
                return c - 'A' + 10</span>
        case c &gt;= 'a' &amp;&amp; c &lt;= 'f':<span class="cov8" title="1">
                return c - 'a' + 10</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

func trimTrailingZeros(s string) string <span class="cov8" title="1">{
        // Trim pairs of trailing "00"
        for len(s) &gt;= 2 &amp;&amp; s[len(s)-2:] == "00" </span><span class="cov8" title="1">{
                s = s[:len(s)-2]
        }</span>
        <span class="cov8" title="1">return s</span>
}

// extractPDFString extracts a parenthesized PDF string value.
func extractPDFString(data []byte) string <span class="cov8" title="1">{
        // Skip whitespace
        i := 0
        for i &lt; len(data) &amp;&amp; (data[i] == ' ' || data[i] == '\n' || data[i] == '\r') </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">if i &gt;= len(data) || data[i] != '(' </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">i++ // skip '('
        depth := 1
        var result []byte
        for i &lt; len(data) &amp;&amp; depth &gt; 0 </span><span class="cov8" title="1">{
                switch data[i] </span>{
                case '(':<span class="cov8" title="1">
                        depth++
                        result = append(result, data[i])</span>
                case ')':<span class="cov8" title="1">
                        depth--
                        if depth &gt; 0 </span><span class="cov8" title="1">{
                                result = append(result, data[i])
                        }</span>
                case '\\':<span class="cov8" title="1">
                        i++
                        if i &lt; len(data) </span><span class="cov8" title="1">{
                                result = append(result, data[i])
                        }</span>
                default:<span class="cov8" title="1">
                        result = append(result, data[i])</span>
                }
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return string(result)</span>
}

// Ensure rand is used (for potential future use in nonce generation).
var _ = rand.Reader
</pre>
		
		<pre class="file" id="file47" style="display: none">package gopdf

// DocumentStats contains summary statistics about the PDF document.
type DocumentStats struct {
        // PageCount is the total number of pages.
        PageCount int
        // ObjectCount is the total number of PDF objects.
        ObjectCount int
        // LiveObjectCount is the number of non-null objects.
        LiveObjectCount int
        // FontCount is the number of font objects.
        FontCount int
        // ImageCount is the number of image objects.
        ImageCount int
        // ContentStreamCount is the number of content stream objects.
        ContentStreamCount int
        // HasOutlines indicates whether the document has bookmarks.
        HasOutlines bool
        // HasEmbeddedFiles indicates whether the document has attachments.
        HasEmbeddedFiles bool
        // HasXMPMetadata indicates whether XMP metadata is set.
        HasXMPMetadata bool
        // HasPageLabels indicates whether page labels are defined.
        HasPageLabels bool
        // HasOCGs indicates whether optional content groups are defined.
        HasOCGs bool
        // PDFVersion is the configured PDF version.
        PDFVersion PDFVersion
}

// GetDocumentStats returns summary statistics about the document.
//
// Example:
//
//        stats := pdf.GetDocumentStats()
//        fmt.Printf("Pages: %d, Fonts: %d, Images: %d\n",
//            stats.PageCount, stats.FontCount, stats.ImageCount)
func (gp *GoPdf) GetDocumentStats() DocumentStats <span class="cov8" title="1">{
        stats := DocumentStats{
                PageCount:       gp.GetNumberOfPages(),
                ObjectCount:     gp.GetObjectCount(),
                LiveObjectCount: gp.GetLiveObjectCount(),
                HasOutlines:     gp.outlines != nil &amp;&amp; gp.outlines.Count() &gt; 0,
                HasEmbeddedFiles: len(gp.embeddedFiles) &gt; 0,
                HasXMPMetadata:  gp.xmpMetadata != nil,
                HasPageLabels:   len(gp.pageLabels) &gt; 0,
                HasOCGs:         len(gp.ocgs) &gt; 0,
                PDFVersion:      gp.pdfVersion,
        }

        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">switch obj.getType() </span>{
                case "Font", subsetFont:<span class="cov8" title="1">
                        stats.FontCount++</span>
                case "Image":<span class="cov8" title="1">
                        stats.ImageCount++</span>
                case "Content":<span class="cov8" title="1">
                        stats.ContentStreamCount++</span>
                }
        }

        <span class="cov8" title="1">return stats</span>
}

// FontInfo describes a font used in the document.
type FontInfo struct {
        // Family is the font family name.
        Family string
        // Style is the font style (Regular, Bold, Italic, etc.).
        Style int
        // IsEmbedded indicates whether the font file is embedded.
        IsEmbedded bool
        // Index is the internal object index.
        Index int
}

// GetFonts returns information about all fonts in the document.
func (gp *GoPdf) GetFonts() []FontInfo <span class="cov8" title="1">{
        var fonts []FontInfo
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">switch o := obj.(type) </span>{
                case *FontObj:<span class="cov8" title="1">
                        fonts = append(fonts, FontInfo{
                                Family:     o.Family,
                                Style:      0,
                                IsEmbedded: o.IsEmbedFont,
                                Index:      i,
                        })</span>
                case *SubsetFontObj:<span class="cov8" title="1">
                        fonts = append(fonts, FontInfo{
                                Family:     o.GetFamily(),
                                Style:      0,
                                IsEmbedded: true,
                                Index:      i,
                        })</span>
                }
        }
        <span class="cov8" title="1">return fonts</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package gopdf

import (
        "compress/flate"
        "errors"
        "fmt"
        "io"
        "time"
)

// EmbeddedFile represents a file to be embedded in the PDF.
type EmbeddedFile struct {
        Name        string    // Display name of the file
        Content     []byte    // File content
        MimeType    string    // MIME type (e.g. "application/pdf", "text/plain")
        Description string    // Optional description
        ModDate     time.Time // Modification date (default: now)
}

// EmbeddedFileInfo contains metadata about an embedded file.
type EmbeddedFileInfo struct {
        Name        string
        MimeType    string
        Description string
        Size        int       // uncompressed size in bytes
        ModDate     time.Time // modification date
}

// ErrEmbeddedFileNotFound is returned when the specified embedded file name does not exist.
var ErrEmbeddedFileNotFound = errors.New("embedded file not found")

// embeddedFileStreamObj is the PDF stream object for the embedded file content.
type embeddedFileStreamObj struct {
        data     []byte
        mimeType string
        modDate  time.Time
}

func (e embeddedFileStreamObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (e embeddedFileStreamObj) getType() string <span class="cov8" title="1">{
        return "EmbeddedFile"
}</span>

func (e embeddedFileStreamObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        // Compress the data.
        var compressed []byte
        </span><span class="cov8" title="1">{
                var buf []byte
                bw := &amp;byteWriter{buf: &amp;buf}
                zw, err := flate.NewWriter(bw, flate.DefaultCompression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := zw.Write(e.data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := zw.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">compressed = *bw.buf</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /EmbeddedFile\n")
        if e.mimeType != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Subtype /%s\n", escapeMimeType(e.mimeType))
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "/Length %d\n", len(compressed))
        io.WriteString(w, "/Filter /FlateDecode\n")
        io.WriteString(w, "/Params &lt;&lt;\n")
        fmt.Fprintf(w, "  /Size %d\n", len(e.data))
        if !e.modDate.IsZero() </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /ModDate (D:%s)\n", e.modDate.Format("20060102150405"))
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "stream\n")
        w.Write(compressed)
        io.WriteString(w, "\nendstream\n")
        return nil</span>
}

// fileSpecObj is the PDF file specification object.
type fileSpecObj struct {
        name        string
        description string
        streamObjID int // 1-based object ID of the embedded file stream
}

func (f fileSpecObj) init(fn func() *GoPdf) {<span class="cov0" title="0">}</span>

func (f fileSpecObj) getType() string <span class="cov8" title="1">{
        return "Filespec"
}</span>

func (f fileSpecObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /Filespec\n")
        fmt.Fprintf(w, "/F (%s)\n", escapeAnnotString(f.name))
        fmt.Fprintf(w, "/UF (%s)\n", escapeAnnotString(f.name))
        if f.description != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Desc (%s)\n", escapeAnnotString(f.description))
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "/EF &lt;&lt; /F %d 0 R &gt;&gt;\n", f.streamObjID)
        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// byteWriter is a simple io.Writer that appends to a byte slice.
type byteWriter struct {
        buf *[]byte
}

func (bw *byteWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        *bw.buf = append(*bw.buf, p...)
        return len(p), nil
}</span>

// escapeMimeType converts a MIME type to a PDF name-safe string.
// e.g. "application/pdf" -&gt; "application#2Fpdf"
func escapeMimeType(mime string) string <span class="cov8" title="1">{
        result := make([]byte, 0, len(mime))
        for i := 0; i &lt; len(mime); i++ </span><span class="cov8" title="1">{
                if mime[i] == '/' </span><span class="cov8" title="1">{
                        result = append(result, '#', '2', 'F')
                }</span> else<span class="cov8" title="1"> {
                        result = append(result, mime[i])
                }</span>
        }
        <span class="cov8" title="1">return string(result)</span>
}

// embeddedFileRef tracks an embedded file for the Names dictionary.
type embeddedFileRef struct {
        name          string
        fileSpecObjID int
        streamObjIdx  int // 0-based index of the stream object
}

// AddEmbeddedFile attaches a file to the PDF document.
// The file will appear in the PDF viewer's attachment panel.
//
// Example:
//
//        data, _ := os.ReadFile("report.csv")
//        pdf.AddEmbeddedFile(gopdf.EmbeddedFile{
//            Name:     "report.csv",
//            Content:  data,
//            MimeType: "text/csv",
//        })
func (gp *GoPdf) AddEmbeddedFile(ef EmbeddedFile) error <span class="cov8" title="1">{
        if ef.Name == "" </span><span class="cov8" title="1">{
                return ErrEmptyString
        }</span>
        <span class="cov8" title="1">if len(ef.Content) == 0 </span><span class="cov8" title="1">{
                return ErrEmptyString
        }</span>
        <span class="cov8" title="1">if ef.ModDate.IsZero() </span><span class="cov8" title="1">{
                ef.ModDate = time.Now()
        }</span>

        // Add the embedded file stream object.
        <span class="cov8" title="1">streamIdx := gp.addObj(embeddedFileStreamObj{
                data:     ef.Content,
                mimeType: ef.MimeType,
                modDate:  ef.ModDate,
        })
        streamObjID := streamIdx + 1 // PDF object IDs are 1-based

        // Add the file specification object.
        fileSpecIdx := gp.addObj(fileSpecObj{
                name:        ef.Name,
                description: ef.Description,
                streamObjID: streamObjID,
        })

        // Track embedded files for the Names dictionary.
        if gp.embeddedFiles == nil </span><span class="cov8" title="1">{
                gp.embeddedFiles = make([]embeddedFileRef, 0)
        }</span>
        <span class="cov8" title="1">gp.embeddedFiles = append(gp.embeddedFiles, embeddedFileRef{
                name:          ef.Name,
                fileSpecObjID: fileSpecIdx + 1,
                streamObjIdx:  streamIdx,
        })

        return nil</span>
}

// GetEmbeddedFile retrieves the content of an embedded file by name.
//
// Example:
//
//        data, err := pdf.GetEmbeddedFile("report.csv")
func (gp *GoPdf) GetEmbeddedFile(name string) ([]byte, error) <span class="cov8" title="1">{
        for _, ref := range gp.embeddedFiles </span><span class="cov8" title="1">{
                if ref.name == name </span><span class="cov8" title="1">{
                        streamIdx := ref.streamObjIdx
                        if streamIdx &lt; 0 || streamIdx &gt;= len(gp.pdfObjs) </span><span class="cov0" title="0">{
                                return nil, ErrEmbeddedFileNotFound
                        }</span>
                        <span class="cov8" title="1">if s, ok := gp.pdfObjs[streamIdx].(embeddedFileStreamObj); ok </span><span class="cov8" title="1">{
                                out := make([]byte, len(s.data))
                                copy(out, s.data)
                                return out, nil
                        }</span>
                        <span class="cov0" title="0">return nil, ErrEmbeddedFileNotFound</span>
                }
        }
        <span class="cov8" title="1">return nil, ErrEmbeddedFileNotFound</span>
}

// DeleteEmbeddedFile removes an embedded file by name.
//
// Example:
//
//        err := pdf.DeleteEmbeddedFile("report.csv")
func (gp *GoPdf) DeleteEmbeddedFile(name string) error <span class="cov8" title="1">{
        for i, ref := range gp.embeddedFiles </span><span class="cov8" title="1">{
                if ref.name == name </span><span class="cov8" title="1">{
                        gp.embeddedFiles = append(gp.embeddedFiles[:i], gp.embeddedFiles[i+1:]...)
                        streamIdx := ref.streamObjIdx
                        fileSpecIdx := ref.fileSpecObjID - 1
                        if streamIdx &gt;= 0 &amp;&amp; streamIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                gp.pdfObjs[streamIdx] = nullObj{}
                        }</span>
                        <span class="cov8" title="1">if fileSpecIdx &gt;= 0 &amp;&amp; fileSpecIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                gp.pdfObjs[fileSpecIdx] = nullObj{}
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }
        <span class="cov8" title="1">return ErrEmbeddedFileNotFound</span>
}

// UpdateEmbeddedFile replaces the content of an existing embedded file.
//
// Example:
//
//        err := pdf.UpdateEmbeddedFile("report.csv", gopdf.EmbeddedFile{
//            Name:     "report.csv",
//            Content:  newData,
//            MimeType: "text/csv",
//        })
func (gp *GoPdf) UpdateEmbeddedFile(name string, ef EmbeddedFile) error <span class="cov8" title="1">{
        for _, ref := range gp.embeddedFiles </span><span class="cov8" title="1">{
                if ref.name == name </span><span class="cov8" title="1">{
                        streamIdx := ref.streamObjIdx
                        if streamIdx &lt; 0 || streamIdx &gt;= len(gp.pdfObjs) </span><span class="cov0" title="0">{
                                return ErrEmbeddedFileNotFound
                        }</span>
                        <span class="cov8" title="1">if _, ok := gp.pdfObjs[streamIdx].(embeddedFileStreamObj); !ok </span><span class="cov0" title="0">{
                                return ErrEmbeddedFileNotFound
                        }</span>
                        <span class="cov8" title="1">modDate := ef.ModDate
                        if modDate.IsZero() </span><span class="cov8" title="1">{
                                modDate = time.Now()
                        }</span>
                        <span class="cov8" title="1">gp.pdfObjs[streamIdx] = embeddedFileStreamObj{
                                data:     ef.Content,
                                mimeType: ef.MimeType,
                                modDate:  modDate,
                        }
                        fileSpecIdx := ref.fileSpecObjID - 1
                        if fileSpecIdx &gt;= 0 &amp;&amp; fileSpecIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                if fs, ok := gp.pdfObjs[fileSpecIdx].(fileSpecObj); ok &amp;&amp; ef.Description != "" </span><span class="cov8" title="1">{
                                        fs.description = ef.Description
                                        gp.pdfObjs[fileSpecIdx] = fs
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
        }
        <span class="cov8" title="1">return ErrEmbeddedFileNotFound</span>
}

// GetEmbeddedFileInfo returns metadata about an embedded file.
//
// Example:
//
//        info, err := pdf.GetEmbeddedFileInfo("report.csv")
//        fmt.Println(info.Size, info.MimeType)
func (gp *GoPdf) GetEmbeddedFileInfo(name string) (EmbeddedFileInfo, error) <span class="cov8" title="1">{
        for _, ref := range gp.embeddedFiles </span><span class="cov8" title="1">{
                if ref.name == name </span><span class="cov8" title="1">{
                        streamIdx := ref.streamObjIdx
                        fileSpecIdx := ref.fileSpecObjID - 1
                        info := EmbeddedFileInfo{Name: name}
                        if streamIdx &gt;= 0 &amp;&amp; streamIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                if s, ok := gp.pdfObjs[streamIdx].(embeddedFileStreamObj); ok </span><span class="cov8" title="1">{
                                        info.MimeType = s.mimeType
                                        info.Size = len(s.data)
                                        info.ModDate = s.modDate
                                }</span>
                        }
                        <span class="cov8" title="1">if fileSpecIdx &gt;= 0 &amp;&amp; fileSpecIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                if fs, ok := gp.pdfObjs[fileSpecIdx].(fileSpecObj); ok </span><span class="cov8" title="1">{
                                        info.Description = fs.description
                                }</span>
                        }
                        <span class="cov8" title="1">return info, nil</span>
                }
        }
        <span class="cov8" title="1">return EmbeddedFileInfo{}, ErrEmbeddedFileNotFound</span>
}

// GetEmbeddedFileNames returns the names of all embedded files.
//
// Example:
//
//        names := pdf.GetEmbeddedFileNames()
func (gp *GoPdf) GetEmbeddedFileNames() []string <span class="cov8" title="1">{
        names := make([]string, len(gp.embeddedFiles))
        for i, ref := range gp.embeddedFiles </span><span class="cov8" title="1">{
                names[i] = ref.name
        }</span>
        <span class="cov8" title="1">return names</span>
}

// GetEmbeddedFileCount returns the number of embedded files.
//
// Example:
//
//        count := pdf.GetEmbeddedFileCount()
func (gp *GoPdf) GetEmbeddedFileCount() int <span class="cov8" title="1">{
        return len(gp.embeddedFiles)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "os"
)

// EmbedFontObj is an embedded font object.
type EmbedFontObj struct {
        Data      string
        zfontpath string
        font      IFont
        getRoot   func() *GoPdf
}

func (e *EmbedFontObj) init(funcGetRoot func() *GoPdf) <span class="cov0" title="0">{
        e.getRoot = funcGetRoot
}</span>

func (e *EmbedFontObj) protection() *PDFProtection <span class="cov8" title="1">{
        return e.getRoot().protection()
}</span>

func (e *EmbedFontObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        b, err := os.ReadFile(e.zfontpath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "&lt;&lt;/Length %d\n", len(b))
        io.WriteString(w, "/Filter /FlateDecode\n")
        fmt.Fprintf(w, "/Length1 %d\n", e.font.GetOriginalsize())
        io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "stream\n")
        if e.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(e.protection().objectkey(objID), b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.Write(tmp)
                io.WriteString(w, "\n")</span>
        } else<span class="cov8" title="1"> {
                w.Write(b)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "\nendstream\n")
        return nil</span>
}

func (e *EmbedFontObj) getType() string <span class="cov8" title="1">{
        return "EmbedFont"
}</span>

// SetFont sets the font of an embedded font object.
func (e *EmbedFontObj) SetFont(font IFont, zfontpath string) <span class="cov8" title="1">{
        e.font = font
        e.zfontpath = zfontpath
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package gopdf

import (
        "io"
)

// EncodingObj is a font object.
type EncodingObj struct {
        font IFont
}

func (e *EncodingObj) init(funcGetRoot func() *GoPdf) {<span class="cov0" title="0">

}</span>
func (e *EncodingObj) getType() string <span class="cov8" title="1">{
        return "Encoding"
}</span>
func (e *EncodingObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [")
        io.WriteString(w, e.font.GetDiff())
        io.WriteString(w, "]&gt;&gt;\n")
        return nil
}</span>

// SetFont sets the font of an encoding object.
func (e *EncodingObj) SetFont(font IFont) <span class="cov8" title="1">{
        e.font = font
}</span>

// GetFont gets the font from an encoding object.
func (e *EncodingObj) GetFont() IFont <span class="cov8" title="1">{
        return e.font
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
)

// EncryptionObj  encryption object res
type EncryptionObj struct {
        uValue []byte //U entry in pdf document
        oValue []byte //O entry in pdf document
        pValue int    //P entry in pdf document
}

func (e *EncryptionObj) init(func() *GoPdf) {<span class="cov0" title="0">

}</span>

func (e *EncryptionObj) getType() string <span class="cov8" title="1">{
        return "Encryption"
}</span>

func (e *EncryptionObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Filter /Standard\n")
        io.WriteString(w, "/V 1\n")
        io.WriteString(w, "/R 2\n")
        fmt.Fprintf(w, "/O (%s)\n", e.escape(e.oValue))
        fmt.Fprintf(w, "/U (%s)\n", e.escape(e.uValue))
        fmt.Fprintf(w, "/P %d\n", e.pValue)
        io.WriteString(w, "&gt;&gt;\n")
        return nil
}</span>

func (e *EncryptionObj) escape(b []byte) string <span class="cov8" title="1">{
        s := string(b)
        s = strings.Replace(s, "\\", "\\\\", -1)
        s = strings.Replace(s, "(", "\\(", -1)
        s = strings.Replace(s, ")", "\\)", -1)
        s = strings.Replace(s, "\r", "\\r", -1)
        return s
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "sync"

        "errors"
)

// TODO: add all fields https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf 8.4.5 page 128
type ExtGState struct {
        Index      int
        ca         *float64
        CA         *float64
        BM         *BlendModeType
        SMaskIndex *int
}

type ExtGStateOptions struct {
        StrokingCA    *float64
        NonStrokingCa *float64
        BlendMode     *BlendModeType
        SMaskIndex    *int
}

func (extOpt ExtGStateOptions) GetId() string <span class="cov8" title="1">{
        id := ""
        if extOpt.StrokingCA != nil </span><span class="cov8" title="1">{
                id += fmt.Sprintf("CA_%.3f;", *extOpt.StrokingCA)
        }</span>
        <span class="cov8" title="1">if extOpt.NonStrokingCa != nil </span><span class="cov8" title="1">{
                id += fmt.Sprintf("ca_%.3f;", *extOpt.NonStrokingCa)
        }</span>
        <span class="cov8" title="1">if extOpt.BlendMode != nil </span><span class="cov8" title="1">{
                id += fmt.Sprintf("BM_%s;", *extOpt.BlendMode)
        }</span>
        <span class="cov8" title="1">if extOpt.SMaskIndex != nil </span><span class="cov8" title="1">{
                id += fmt.Sprintf("SMask_%d_0_R;", *extOpt.SMaskIndex)
        }</span>

        <span class="cov8" title="1">return id</span>
}

func GetCachedExtGState(opts ExtGStateOptions, gp *GoPdf) (ExtGState, error) <span class="cov8" title="1">{
        extGState, ok := gp.curr.extGStatesMap.Find(opts)
        if !ok </span><span class="cov8" title="1">{
                extGState = ExtGState{
                        BM:         opts.BlendMode,
                        CA:         opts.StrokingCA,
                        ca:         opts.NonStrokingCa,
                        SMaskIndex: opts.SMaskIndex,
                }

                extGState.Index = gp.addObj(extGState)

                pdfObj := gp.pdfObjs[gp.indexOfProcSet]
                procset, ok := pdfObj.(*ProcSetObj)
                if !ok </span><span class="cov0" title="0">{
                        return ExtGState{}, errors.New("can't convert pdfobject to procsetobj")
                }</span>

                <span class="cov8" title="1">procset.ExtGStates = append(procset.ExtGStates, ExtGS{Index: extGState.Index})

                gp.curr.extGStatesMap.Save(opts.GetId(), extGState)</span>

                //extGState = extGState
        }

        <span class="cov8" title="1">return extGState, nil</span>
}

func (egs ExtGState) init(func() *GoPdf) {<span class="cov8" title="1">}</span>

func (egs ExtGState) getType() string <span class="cov8" title="1">{
        return "ExtGState"
}</span>

func (egs ExtGState) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        content := "&lt;&lt;\n"
        content += "\t/Type /ExtGState\n"

        if egs.ca != nil </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/ca %.3F\n", *egs.ca)
        }</span>
        <span class="cov8" title="1">if egs.CA != nil </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/CA %.3F\n", *egs.CA)
        }</span>
        <span class="cov8" title="1">if egs.BM != nil </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/BM %s\n", *egs.BM)
        }</span>

        <span class="cov8" title="1">if egs.SMaskIndex != nil </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/SMask %d 0 R\n", *egs.SMaskIndex+1)
        }</span>

        <span class="cov8" title="1">content += "&gt;&gt;\n"

        if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type ExtGStatesMap struct {
        syncer sync.Mutex
        table  map[string]ExtGState
}

func NewExtGStatesMap() ExtGStatesMap <span class="cov8" title="1">{
        return ExtGStatesMap{
                syncer: sync.Mutex{},
                table:  make(map[string]ExtGState),
        }
}</span>

func (extm *ExtGStatesMap) Find(extGState ExtGStateOptions) (ExtGState, bool) <span class="cov8" title="1">{
        key := extGState.GetId()

        extm.syncer.Lock()
        defer extm.syncer.Unlock()

        t, ok := extm.table[key]
        if !ok </span><span class="cov8" title="1">{
                return ExtGState{}, false
        }</span>

        <span class="cov0" title="0">return t, ok</span>

}

func (tm *ExtGStatesMap) Save(id string, extGState ExtGState) ExtGState <span class="cov8" title="1">{
        tm.syncer.Lock()
        defer tm.syncer.Unlock()

        tm.table[id] = extGState

        return extGState
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package gopdf

import (
        "bytes"
        "errors"
        "io"
        "os"
        "sync"
)

// ErrFontNotFound occurs when the specified font family is not found in the container.
var ErrFontNotFound = errors.New("font not found")

// FontContainer manages a collection of fonts.
type FontContainer struct {
        fonts sync.Map
}

// AddTTFFontWithOption adds a font by the specified TTF file path with options.
func (fc *FontContainer) AddTTFFontWithOption(family string, ttfpath string, option TtfOption) error <span class="cov8" title="1">{
        if _, err := os.Stat(ttfpath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">data, err := os.ReadFile(ttfpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rd := bytes.NewReader(data)
        return fc.AddTTFFontByReaderWithOption(family, rd, option)</span>
}

// AddTTFFont adds a font by the specified TTF file path.
func (fc *FontContainer) AddTTFFont(family string, ttfpath string) error <span class="cov8" title="1">{
        return fc.AddTTFFontWithOption(family, ttfpath, defaultTtfFontOption())
}</span>

// AddTTFFontByReader adds font by reader.
func (fc *FontContainer) AddTTFFontByReader(family string, rd io.Reader) error <span class="cov8" title="1">{
        return fc.AddTTFFontByReaderWithOption(family, rd, defaultTtfFontOption())
}</span>

// AddTTFFontByReaderWithOption adds font by reader with option.
func (fc *FontContainer) AddTTFFontByReaderWithOption(family string, rd io.Reader, option TtfOption) error <span class="cov8" title="1">{
        var subsetFont SubsetFontObj
        subsetFont.SetTtfFontOption(option)
        subsetFont.SetFamily(family)
        err := subsetFont.SetTTFByReader(rd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fc.fonts.Store(family, subsetFont)
        return nil</span>
}

// AddTTFFontData adds font by data.
func (fc *FontContainer) AddTTFFontData(family string, fontData []byte) error <span class="cov8" title="1">{
        return fc.AddTTFFontDataWithOption(family, fontData, defaultTtfFontOption())
}</span>

// AddTTFFontDataWithOption adds font by data with option.
func (fc *FontContainer) AddTTFFontDataWithOption(family string, fontData []byte, option TtfOption) error <span class="cov8" title="1">{
        var subsetFont SubsetFontObj
        subsetFont.SetTtfFontOption(option)
        subsetFont.SetFamily(family)
        err := subsetFont.SetTTFData(fontData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fc.fonts.Store(family, subsetFont)
        return nil</span>
}

// AddTTFFontFromFontContainer adds a font from a FontContainer
func (gp *GoPdf) AddTTFFontFromFontContainer(family string, container *FontContainer) error <span class="cov8" title="1">{
        untypedSubsetFontObj, ok := container.fonts.Load(family)
        if !ok </span><span class="cov8" title="1">{
                return ErrFontNotFound
        }</span>
        <span class="cov8" title="1">subsetFont := untypedSubsetFontObj.(SubsetFontObj)
        subsetFont.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">return gp.setSubsetFontObject(&amp;subsetFont, family, subsetFont.ttfFontOption)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package gopdf

import (
        "fmt"
)

// ExtractedFont holds information about a font found in a PDF.
type ExtractedFont struct {
        // Name is the font resource name (e.g., "F1").
        Name string
        // BaseFont is the PostScript font name (e.g., "Helvetica", "TimesNewRoman").
        BaseFont string
        // Subtype is the font type (e.g., "Type1", "TrueType", "Type0").
        Subtype string
        // Encoding is the font encoding (e.g., "WinAnsiEncoding", "Identity-H").
        Encoding string
        // ObjNum is the PDF object number of the font.
        ObjNum int
        // IsEmbedded indicates whether the font data is embedded in the PDF.
        IsEmbedded bool
        // Data is the raw font data (if embedded and extractable). May be nil.
        Data []byte
}

// ExtractFontsFromPage extracts font information from a specific page (0-based).
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        fonts, _ := gopdf.ExtractFontsFromPage(data, 0)
//        for _, f := range fonts {
//            fmt.Printf("%s: %s (%s) embedded=%v\n", f.Name, f.BaseFont, f.Subtype, f.IsEmbedded)
//        }
func ExtractFontsFromPage(pdfData []byte, pageIndex int) ([]ExtractedFont, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if pageIndex &lt; 0 || pageIndex &gt;= len(parser.pages) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("page index %d out of range (0..%d)", pageIndex, len(parser.pages)-1)
        }</span>
        <span class="cov8" title="1">page := parser.pages[pageIndex]
        return extractFontsFromResources(parser, page.resources), nil</span>
}

// ExtractFontsFromAllPages extracts font information from all pages.
func ExtractFontsFromAllPages(pdfData []byte) (map[int][]ExtractedFont, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := make(map[int][]ExtractedFont, len(parser.pages))
        for i, page := range parser.pages </span><span class="cov8" title="1">{
                fonts := extractFontsFromResources(parser, page.resources)
                if len(fonts) &gt; 0 </span><span class="cov8" title="1">{
                        result[i] = fonts
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func extractFontsFromResources(parser *rawPDFParser, res rawPDFResources) []ExtractedFont <span class="cov8" title="1">{
        var fonts []ExtractedFont
        for name, objNum := range res.fonts </span><span class="cov8" title="1">{
                obj, ok := parser.objects[objNum]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">f := ExtractedFont{
                        Name:   name,
                        ObjNum: objNum,
                }
                f.BaseFont = extractName(obj.dict, "/BaseFont")
                f.Subtype = extractName(obj.dict, "/Subtype")
                f.Encoding = extractName(obj.dict, "/Encoding")

                // Check for embedded font data.
                descRef := extractRef(obj.dict, "/FontDescriptor")
                if descRef &gt; 0 </span><span class="cov8" title="1">{
                        if descObj, ok := parser.objects[descRef]; ok </span><span class="cov8" title="1">{
                                // Look for /FontFile, /FontFile2, or /FontFile3.
                                for _, key := range []string{"/FontFile", "/FontFile2", "/FontFile3"} </span><span class="cov8" title="1">{
                                        ffRef := extractRef(descObj.dict, key)
                                        if ffRef &gt; 0 </span><span class="cov8" title="1">{
                                                f.IsEmbedded = true
                                                if ffObj, ok := parser.objects[ffRef]; ok &amp;&amp; ffObj.stream != nil </span><span class="cov8" title="1">{
                                                        f.Data = ffObj.stream
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        }
                                }
                        }
                }

                <span class="cov8" title="1">fonts = append(fonts, f)</span>
        }
        <span class="cov8" title="1">return fonts</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// FontObj font obj
type FontObj struct {
        Family string
        //Style string
        //Size int
        IsEmbedFont bool

        indexObjWidth          int
        indexObjFontDescriptor int
        indexObjEncoding       int

        Font        IFont
        CountOfFont int
}

func (f *FontObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        f.IsEmbedFont = false
        //me.CountOfFont = -1
}</span>

func (f *FontObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        baseFont := f.Family
        if f.Font != nil </span><span class="cov8" title="1">{
                baseFont = f.Font.GetName()
        }</span>

        <span class="cov8" title="1">io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "  /Type /%s\n", f.getType())
        io.WriteString(w, "  /Subtype /TrueType\n")
        fmt.Fprintf(w, "  /BaseFont /%s\n", baseFont)
        if f.IsEmbedFont </span><span class="cov8" title="1">{
                io.WriteString(w, "  /FirstChar 32 /LastChar 255\n")
                fmt.Fprintf(w, "  /Widths %d 0 R\n", f.indexObjWidth)
                fmt.Fprintf(w, "  /FontDescriptor %d 0 R\n", f.indexObjFontDescriptor)
                fmt.Fprintf(w, "  /Encoding %d 0 R\n", f.indexObjEncoding)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

func (f *FontObj) getType() string <span class="cov8" title="1">{
        return "Font"
}</span>

// SetIndexObjWidth sets the width of a font object.
func (f *FontObj) SetIndexObjWidth(index int) <span class="cov8" title="1">{
        f.indexObjWidth = index
}</span>

// SetIndexObjFontDescriptor sets the font descriptor.
func (f *FontObj) SetIndexObjFontDescriptor(index int) <span class="cov8" title="1">{
        f.indexObjFontDescriptor = index
}</span>

// SetIndexObjEncoding sets the encoding.
func (f *FontObj) SetIndexObjEncoding(index int) <span class="cov8" title="1">{
        f.indexObjEncoding = index
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package gopdf

import (
        "strings"
)

// Regular - font style regular
const Regular = 0 //000000
// Italic - font style italic
const Italic = 1 //000001
// Bold - font style bold
const Bold = 2 //000010
// Underline - font style underline
const Underline = 4 //000100

func getConvertedStyle(fontStyle string) (style int) <span class="cov8" title="1">{
        fontStyle = strings.ToUpper(fontStyle)
        if strings.Contains(fontStyle, "B") </span><span class="cov8" title="1">{
                style = style | Bold
        }</span>
        <span class="cov8" title="1">if strings.Contains(fontStyle, "I") </span><span class="cov8" title="1">{
                style = style | Italic
        }</span>
        <span class="cov8" title="1">if strings.Contains(fontStyle, "U") </span><span class="cov8" title="1">{
                style = style | Underline
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package gopdf

import (
        "strconv"
        //"fmt"
        "bytes"
)

// FontConvertHelperCw2Str converts main ASCII characters of a FontCW to a string.
func FontConvertHelperCw2Str(cw FontCw) string <span class="cov8" title="1">{
        buff := new(bytes.Buffer)
        buff.WriteString(" ")
        i := 32
        for i &lt;= 255 </span><span class="cov8" title="1">{
                buff.WriteString(strconv.Itoa(cw[byte(i)]) + " ")
                i++
        }</span>
        <span class="cov8" title="1">return buff.String()</span>
}

// FontConvertHelper_Cw2Str converts main ASCII characters of a FontCW to a string. (for backward compatibility)
// Deprecated: Use FontConvertHelperCw2Str(cw FontCw) instead
func FontConvertHelper_Cw2Str(cw FontCw) string <span class="cov8" title="1">{
        return FontConvertHelperCw2Str(cw)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// FontDescriptorObj is a font descriptor object.
type FontDescriptorObj struct {
        font              IFont
        fontFileObjRelate string
}

func (f *FontDescriptorObj) init(funcGetRoot func() *GoPdf) {<span class="cov0" title="0">

}</span>

func (f *FontDescriptorObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{

        fmt.Fprintf(w, "&lt;&lt;/Type /FontDescriptor /FontName /%s ", f.font.GetName())
        descs := f.font.GetDesc()
        i := 0
        max := len(descs)
        for i &lt; max </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/%s %s ", descs[i].Key, descs[i].Val)
                i++
        }</span>

        <span class="cov8" title="1">if f.getType() == "Type1" </span><span class="cov0" title="0">{
                io.WriteString(w, "/FontFile ")
        }</span> else<span class="cov8" title="1"> {
                io.WriteString(w, "/FontFile2 ")
        }</span>

        <span class="cov8" title="1">io.WriteString(w, f.fontFileObjRelate)
        io.WriteString(w, "&gt;&gt;\n")

        return nil</span>
}

func (f *FontDescriptorObj) getType() string <span class="cov8" title="1">{
        return "FontDescriptor"
}</span>

// SetFont sets the font in descriptor.
func (f *FontDescriptorObj) SetFont(font IFont) <span class="cov8" title="1">{
        f.font = font
}</span>

// GetFont gets font from descriptor.
func (f *FontDescriptorObj) GetFont() IFont <span class="cov8" title="1">{
        return f.font
}</span>

// SetFontFileObjRelate ???
func (f *FontDescriptorObj) SetFontFileObjRelate(relate string) <span class="cov8" title="1">{
        f.fontFileObjRelate = relate
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// ============================================================
// PDF Form Fields (AcroForm / Widgets)
// ============================================================

// FormFieldType represents the type of a PDF form field.
type FormFieldType int

const (
        // FormFieldText is a text input field.
        FormFieldText FormFieldType = iota
        // FormFieldCheckbox is a checkbox field.
        FormFieldCheckbox
        // FormFieldRadio is a radio button field.
        FormFieldRadio
        // FormFieldChoice is a dropdown/list field.
        FormFieldChoice
        // FormFieldButton is a push button field.
        FormFieldButton
        // FormFieldSignature is a signature field.
        FormFieldSignature
)

// String returns the field type name.
func (ft FormFieldType) String() string <span class="cov8" title="1">{
        switch ft </span>{
        case FormFieldText:<span class="cov8" title="1">
                return "Text"</span>
        case FormFieldCheckbox:<span class="cov8" title="1">
                return "Checkbox"</span>
        case FormFieldRadio:<span class="cov8" title="1">
                return "Radio"</span>
        case FormFieldChoice:<span class="cov8" title="1">
                return "Choice"</span>
        case FormFieldButton:<span class="cov8" title="1">
                return "Button"</span>
        case FormFieldSignature:<span class="cov8" title="1">
                return "Signature"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// FormField defines a form field to be added to a PDF page.
type FormField struct {
        // Type is the field type.
        Type FormFieldType
        // Name is the field name (unique identifier).
        Name string
        // X, Y are the top-left corner position.
        X, Y float64
        // W, H are the width and height.
        W, H float64
        // Value is the default value.
        Value string
        // FontFamily is the font family for text fields (must be pre-loaded).
        FontFamily string
        // FontSize is the font size for text fields (default 12).
        FontSize float64
        // Options is a list of choices for Choice fields.
        Options []string
        // MaxLen is the maximum character length for text fields (0 = unlimited).
        MaxLen int
        // Multiline enables multi-line text input.
        Multiline bool
        // ReadOnly makes the field non-editable.
        ReadOnly bool
        // Required marks the field as required.
        Required bool
        // Color is the text color [R, G, B] (0-255).
        Color [3]uint8
        // BorderColor is the border color [R, G, B] (0-255).
        BorderColor [3]uint8
        // FillColor is the background fill color [R, G, B] (0-255).
        FillColor [3]uint8
        // HasBorder controls whether a border is drawn.
        HasBorder bool
        // HasFill controls whether a background fill is drawn.
        HasFill bool
        // Checked is the initial state for checkboxes.
        Checked bool
        // PageNo is the 1-based page number (set internally).
        pageNo int
}

// formFieldObj is the PDF widget annotation + field object.
type formFieldObj struct {
        field    FormField
        pageRef  int // page object ID (1-based)
        fontRef  string // font resource name like "/F1"
        fontObjID int  // font object ID (1-based)
}

func (f formFieldObj) init(fn func() *GoPdf) {<span class="cov0" title="0">}</span>

func (f formFieldObj) getType() string <span class="cov8" title="1">{
        return "FormField"
}</span>

func (f formFieldObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        field := f.field
        x1 := field.X
        y1 := field.Y
        x2 := field.X + field.W
        y2 := field.Y + field.H

        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /Annot\n")
        io.WriteString(w, "/Subtype /Widget\n")
        fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y1, x2, y2)
        fmt.Fprintf(w, "/P %d 0 R\n", f.pageRef)
        fmt.Fprintf(w, "/T (%s)\n", escapeAnnotString(field.Name))

        if field.Value != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/V (%s)\n", escapeAnnotString(field.Value))
                fmt.Fprintf(w, "/DV (%s)\n", escapeAnnotString(field.Value))
        }</span>

        // Field flags
        <span class="cov8" title="1">ff := 0
        if field.ReadOnly </span><span class="cov8" title="1">{
                ff |= 1 // bit 1
        }</span>
        <span class="cov8" title="1">if field.Required </span><span class="cov8" title="1">{
                ff |= 2 // bit 2
        }</span>

        <span class="cov8" title="1">switch field.Type </span>{
        case FormFieldText:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Tx\n")
                if field.Multiline </span><span class="cov8" title="1">{
                        ff |= 1 &lt;&lt; 12 // bit 13
                }</span>
                <span class="cov8" title="1">if field.MaxLen &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/MaxLen %d\n", field.MaxLen)
                }</span>
        case FormFieldCheckbox:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Btn\n")
                if field.Checked </span><span class="cov8" title="1">{
                        io.WriteString(w, "/V /Yes\n/AS /Yes\n")
                }</span> else<span class="cov8" title="1"> {
                        io.WriteString(w, "/V /Off\n/AS /Off\n")
                }</span>
        case FormFieldRadio:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Btn\n")
                ff |= 1 &lt;&lt; 15 // bit 16 = radio
                ff |= 1 &lt;&lt; 14</span> // bit 15 = NoToggleToOff
        case FormFieldChoice:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Ch\n")
                if len(field.Options) &gt; 0 </span><span class="cov8" title="1">{
                        io.WriteString(w, "/Opt [")
                        for _, opt := range field.Options </span><span class="cov8" title="1">{
                                fmt.Fprintf(w, "(%s) ", escapeAnnotString(opt))
                        }</span>
                        <span class="cov8" title="1">io.WriteString(w, "]\n")</span>
                }
        case FormFieldButton:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Btn\n")
                ff |= 1 &lt;&lt; 16</span> // bit 17 = pushbutton
        case FormFieldSignature:<span class="cov8" title="1">
                io.WriteString(w, "/FT /Sig\n")</span>
        }

        <span class="cov8" title="1">if ff != 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Ff %d\n", ff)
        }</span>

        // Appearance characteristics
        <span class="cov8" title="1">io.WriteString(w, "/MK &lt;&lt;\n")
        if field.HasBorder </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /BC [%.4f %.4f %.4f]\n",
                        float64(field.BorderColor[0])/255,
                        float64(field.BorderColor[1])/255,
                        float64(field.BorderColor[2])/255)
        }</span>
        <span class="cov8" title="1">if field.HasFill </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /BG [%.4f %.4f %.4f]\n",
                        float64(field.FillColor[0])/255,
                        float64(field.FillColor[1])/255,
                        float64(field.FillColor[2])/255)
        }</span>
        <span class="cov8" title="1">if field.Type == FormFieldCheckbox </span><span class="cov8" title="1">{
                io.WriteString(w, "  /CA (4)\n") // checkmark character
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")

        // Border style
        if field.HasBorder </span><span class="cov8" title="1">{
                io.WriteString(w, "/BS &lt;&lt; /W 1 /S /S &gt;&gt;\n")
        }</span>

        // Default appearance string for text fields
        <span class="cov8" title="1">if field.Type == FormFieldText || field.Type == FormFieldChoice </span><span class="cov8" title="1">{
                fontSize := field.FontSize
                if fontSize == 0 </span><span class="cov8" title="1">{
                        fontSize = 12
                }</span>
                <span class="cov8" title="1">r := float64(field.Color[0]) / 255
                g := float64(field.Color[1]) / 255
                b := float64(field.Color[2]) / 255
                if f.fontRef != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/DA (%s %.1f Tf %.4f %.4f %.4f rg)\n",
                                f.fontRef, fontSize, r, g, b)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(w, "/DA (/Helv %.1f Tf %.4f %.4f %.4f rg)\n",
                                fontSize, r, g, b)
                }</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// AddFormField adds a form field (widget) to the current page.
// The field will appear as an interactive form element in PDF viewers.
//
// For text fields, set FontFamily to a pre-loaded font name.
// If FontFamily is empty, the standard Helvetica font is used.
//
// Example:
//
//        pdf.AddFormField(gopdf.FormField{
//            Type:      gopdf.FormFieldText,
//            Name:      "username",
//            X:         50,
//            Y:         100,
//            W:         200,
//            H:         25,
//            Value:     "Enter name",
//            FontSize:  12,
//            HasBorder: true,
//            BorderColor: [3]uint8{0, 0, 0},
//        })
func (gp *GoPdf) AddFormField(field FormField) error <span class="cov8" title="1">{
        if field.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("form field name is required")
        }</span>
        <span class="cov8" title="1">if field.W &lt;= 0 || field.H &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("form field width and height must be positive")
        }</span>

        // Find current page object
        <span class="cov8" title="1">pageObjID := gp.findCurrentPageObjID()
        if pageObjID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no current page")
        }</span>

        // Resolve font reference
        <span class="cov8" title="1">var fontRef string
        var fontObjID int
        if field.FontFamily != "" </span><span class="cov8" title="1">{
                for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                        switch o := obj.(type) </span>{
                        case *SubsetFontObj:<span class="cov8" title="1">
                                if o.GetFamily() == field.FontFamily </span><span class="cov8" title="1">{
                                        fontRef = fmt.Sprintf("/F%d", o.CountOfFont+1)
                                        fontObjID = i + 1
                                }</span>
                        case *FontObj:<span class="cov0" title="0">
                                if o.Family == field.FontFamily </span><span class="cov0" title="0">{
                                        fontRef = fmt.Sprintf("/F%d", o.CountOfFont+1)
                                        fontObjID = i + 1
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">ffObj := formFieldObj{
                field:    field,
                pageRef:  pageObjID,
                fontRef:  fontRef,
                fontObjID: fontObjID,
        }
        idx := gp.addObj(ffObj)

        // Add to page's annotation list
        page := gp.findCurrentPageObj()
        if page != nil </span><span class="cov8" title="1">{
                page.LinkObjIds = append(page.LinkObjIds, idx+1)
        }</span>

        <span class="cov8" title="1">gp.formFields = append(gp.formFields, formFieldRef{
                field:  field,
                objIdx: idx,
        })

        return nil</span>
}

// AddTextField is a convenience method for adding a text input field.
func (gp *GoPdf) AddTextField(name string, x, y, w, h float64) error <span class="cov8" title="1">{
        return gp.AddFormField(FormField{
                Type:        FormFieldText,
                Name:        name,
                X:           x,
                Y:           y,
                W:           w,
                H:           h,
                FontSize:    12,
                HasBorder:   true,
                BorderColor: [3]uint8{0, 0, 0},
        })
}</span>

// AddCheckbox is a convenience method for adding a checkbox field.
func (gp *GoPdf) AddCheckbox(name string, x, y, size float64, checked bool) error <span class="cov8" title="1">{
        return gp.AddFormField(FormField{
                Type:        FormFieldCheckbox,
                Name:        name,
                X:           x,
                Y:           y,
                W:           size,
                H:           size,
                Checked:     checked,
                HasBorder:   true,
                BorderColor: [3]uint8{0, 0, 0},
        })
}</span>

// AddDropdown is a convenience method for adding a dropdown choice field.
func (gp *GoPdf) AddDropdown(name string, x, y, w, h float64, options []string) error <span class="cov8" title="1">{
        return gp.AddFormField(FormField{
                Type:        FormFieldChoice,
                Name:        name,
                X:           x,
                Y:           y,
                W:           w,
                H:           h,
                Options:     options,
                FontSize:    12,
                HasBorder:   true,
                BorderColor: [3]uint8{0, 0, 0},
        })
}</span>

// GetFormFields returns all form fields added to the document.
func (gp *GoPdf) GetFormFields() []FormField <span class="cov8" title="1">{
        fields := make([]FormField, len(gp.formFields))
        for i, ref := range gp.formFields </span><span class="cov8" title="1">{
                fields[i] = ref.field
        }</span>
        <span class="cov8" title="1">return fields</span>
}

// findCurrentPageObjID returns the 1-based object ID of the current page.
func (gp *GoPdf) findCurrentPageObjID() int <span class="cov8" title="1">{
        if gp.curr.IndexOfPageObj &gt;= 0 &amp;&amp; gp.curr.IndexOfPageObj &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                return gp.curr.IndexOfPageObj + 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// findCurrentPageObj returns the current PageObj.
func (gp *GoPdf) findCurrentPageObj() *PageObj <span class="cov8" title="1">{
        if gp.curr.IndexOfPageObj &gt;= 0 &amp;&amp; gp.curr.IndexOfPageObj &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                if p, ok := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj); ok </span><span class="cov8" title="1">{
                        return p
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "io"
        "strings"
)

// ============================================================
// Form Field Operations â€” delete, modify, detect, bake
// ============================================================

// DeleteFormField removes a form field by name from the document.
// Returns an error if the field is not found.
//
// Example:
//
//        err := pdf.DeleteFormField("username")
func (gp *GoPdf) DeleteFormField(name string) error <span class="cov8" title="1">{
        idx := -1
        for i, ref := range gp.formFields </span><span class="cov8" title="1">{
                if ref.field.Name == name </span><span class="cov8" title="1">{
                        idx = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if idx &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("form field %q not found", name)
        }</span>

        <span class="cov8" title="1">ref := gp.formFields[idx]

        // Null out the PDF object.
        if ref.objIdx &gt;= 0 &amp;&amp; ref.objIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                gp.pdfObjs[ref.objIdx] = nullObj{}
        }</span>

        // Remove from page's annotation list.
        <span class="cov8" title="1">objID := ref.objIdx + 1
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if page, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        for j, id := range page.LinkObjIds </span><span class="cov8" title="1">{
                                if id == objID </span><span class="cov8" title="1">{
                                        page.LinkObjIds = append(page.LinkObjIds[:j], page.LinkObjIds[j+1:]...)
                                        break</span>
                                }
                        }
                }
        }

        // Remove from formFields slice.
        <span class="cov8" title="1">gp.formFields = append(gp.formFields[:idx], gp.formFields[idx+1:]...)

        return nil</span>
}

// ModifyFormFieldValue updates the value of an existing form field by name.
//
// Example:
//
//        err := pdf.ModifyFormFieldValue("username", "John Doe")
func (gp *GoPdf) ModifyFormFieldValue(name, value string) error <span class="cov8" title="1">{
        for i, ref := range gp.formFields </span><span class="cov8" title="1">{
                if ref.field.Name == name </span><span class="cov8" title="1">{
                        gp.formFields[i].field.Value = value

                        // Update the underlying PDF object.
                        if ref.objIdx &gt;= 0 &amp;&amp; ref.objIdx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                                if ffObj, ok := gp.pdfObjs[ref.objIdx].(formFieldObj); ok </span><span class="cov8" title="1">{
                                        ffObj.field.Value = value
                                        gp.pdfObjs[ref.objIdx] = ffObj
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
        }
        <span class="cov8" title="1">return fmt.Errorf("form field %q not found", name)</span>
}

// IsFormPDF detects whether the given PDF data contains form fields (AcroForm).
// This is a standalone function that operates on raw PDF bytes.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        if gopdf.IsFormPDF(data) {
//            fmt.Println("This PDF contains form fields")
//        }
func IsFormPDF(pdfData []byte) bool <span class="cov8" title="1">{
        // Look for /AcroForm in the catalog or anywhere in the PDF.
        return bytes.Contains(pdfData, []byte("/AcroForm")) &amp;&amp;
                (bytes.Contains(pdfData, []byte("/Fields")) ||
                        bytes.Contains(pdfData, []byte("/FT ")))
}</span>

// BakeAnnotations flattens all annotations and form fields into the page
// content streams, making them non-interactive. This is similar to
// PyMuPDF's bake() function.
//
// After baking, form fields become static content and can no longer be edited.
//
// Example:
//
//        pdf.BakeAnnotations()
//        pdf.WritePdf("baked.pdf")
func (gp *GoPdf) BakeAnnotations() <span class="cov8" title="1">{
        // For each page, convert annotations to static drawing commands.
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                page, ok := obj.(*PageObj)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var bakedContent strings.Builder

                for _, annotID := range page.LinkObjIds </span><span class="cov8" title="1">{
                        objIdx := annotID - 1
                        if objIdx &lt; 0 || objIdx &gt;= len(gp.pdfObjs) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">switch a := gp.pdfObjs[objIdx].(type) </span>{
                        case formFieldObj:<span class="cov8" title="1">
                                // Bake form field as static text.
                                bakedContent.WriteString(bakeFormField(a))
                                gp.pdfObjs[objIdx] = nullObj{}</span>
                        case annotationObj:<span class="cov8" title="1">
                                // Bake annotation as static drawing.
                                bakedContent.WriteString(bakeAnnotation(a))
                                gp.pdfObjs[objIdx] = nullObj{}</span>
                        }
                }

                <span class="cov8" title="1">if bakedContent.Len() &gt; 0 </span><span class="cov8" title="1">{
                        // Append baked content to the page's content stream.
                        gp.appendContentToPage(page, bakedContent.String())
                }</span>

                // Clear the annotation list.
                <span class="cov8" title="1">page.LinkObjIds = nil</span>
        }

        // Clear form fields.
        <span class="cov8" title="1">gp.formFields = nil</span>
}

// bakeFormField converts a form field to static PDF drawing commands.
func bakeFormField(f formFieldObj) string <span class="cov8" title="1">{
        field := f.field
        var buf strings.Builder

        buf.WriteString("q\n")

        // Draw background if filled.
        if field.HasFill </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "%.4f %.4f %.4f rg\n",
                        float64(field.FillColor[0])/255,
                        float64(field.FillColor[1])/255,
                        float64(field.FillColor[2])/255)
                fmt.Fprintf(&amp;buf, "%.2f %.2f %.2f %.2f re f\n",
                        field.X, field.Y, field.W, field.H)
        }</span>

        // Draw border if present.
        <span class="cov8" title="1">if field.HasBorder </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "%.4f %.4f %.4f RG\n",
                        float64(field.BorderColor[0])/255,
                        float64(field.BorderColor[1])/255,
                        float64(field.BorderColor[2])/255)
                fmt.Fprintf(&amp;buf, "1 w\n")
                fmt.Fprintf(&amp;buf, "%.2f %.2f %.2f %.2f re S\n",
                        field.X, field.Y, field.W, field.H)
        }</span>

        // Draw text value.
        <span class="cov8" title="1">if field.Value != "" &amp;&amp; (field.Type == FormFieldText || field.Type == FormFieldChoice) </span><span class="cov8" title="1">{
                fontSize := field.FontSize
                if fontSize == 0 </span><span class="cov0" title="0">{
                        fontSize = 12
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(&amp;buf, "BT\n")
                fmt.Fprintf(&amp;buf, "%.4f %.4f %.4f rg\n",
                        float64(field.Color[0])/255,
                        float64(field.Color[1])/255,
                        float64(field.Color[2])/255)
                fmt.Fprintf(&amp;buf, "/Helv %.1f Tf\n", fontSize)
                fmt.Fprintf(&amp;buf, "%.2f %.2f Td\n", field.X+2, field.Y+field.H-fontSize-2)
                fmt.Fprintf(&amp;buf, "(%s) Tj\n", escapeAnnotString(field.Value))
                fmt.Fprintf(&amp;buf, "ET\n")</span>
        }

        // Draw checkmark for checked checkboxes.
        <span class="cov8" title="1">if field.Type == FormFieldCheckbox &amp;&amp; field.Checked </span><span class="cov8" title="1">{
                cx := field.X + field.W*0.2
                cy := field.Y + field.H*0.2
                fmt.Fprintf(&amp;buf, "0 0 0 RG\n2 w\n")
                fmt.Fprintf(&amp;buf, "%.2f %.2f m %.2f %.2f l S\n",
                        cx, cy+field.H*0.3, cx+field.W*0.3, cy)
                fmt.Fprintf(&amp;buf, "%.2f %.2f m %.2f %.2f l S\n",
                        cx+field.W*0.3, cy, cx+field.W*0.6, cy+field.H*0.6)
        }</span>

        <span class="cov8" title="1">buf.WriteString("Q\n")
        return buf.String()</span>
}

// bakeAnnotation converts an annotation to static PDF drawing commands.
func bakeAnnotation(a annotationObj) string <span class="cov8" title="1">{
        opt := a.opt
        var buf strings.Builder

        buf.WriteString("q\n")

        // Draw annotation rectangle with color.
        r := float64(opt.Color[0]) / 255
        g := float64(opt.Color[1]) / 255
        b := float64(opt.Color[2]) / 255
        fmt.Fprintf(&amp;buf, "%.4f %.4f %.4f RG\n", r, g, b)
        fmt.Fprintf(&amp;buf, "1 w\n")
        fmt.Fprintf(&amp;buf, "%.2f %.2f %.2f %.2f re S\n",
                opt.X, opt.Y, opt.W, opt.H)

        // Draw content text if present.
        if opt.Content != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "BT\n")
                fontSize := opt.FontSize
                if fontSize == 0 </span><span class="cov8" title="1">{
                        fontSize = 10
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(&amp;buf, "%.4f %.4f %.4f rg\n", r, g, b)
                fmt.Fprintf(&amp;buf, "/Helv %.1f Tf\n", fontSize)
                fmt.Fprintf(&amp;buf, "%.2f %.2f Td\n", opt.X+2, opt.Y+opt.H-fontSize-2)
                fmt.Fprintf(&amp;buf, "(%s) Tj\n", escapeAnnotString(opt.Content))
                fmt.Fprintf(&amp;buf, "ET\n")</span>
        }

        <span class="cov8" title="1">buf.WriteString("Q\n")
        return buf.String()</span>
}

// appendContentToPage appends raw content stream data to a page.
func (gp *GoPdf) appendContentToPage(page *PageObj, content string) <span class="cov8" title="1">{
        // Create a new content object with the baked content.
        contentObj := new(ContentObj)
        contentObj.init(func() *GoPdf </span><span class="cov8" title="1">{ return gp }</span>)
        // Use the raw cache to inject pre-built content stream commands.
        <span class="cov8" title="1">contentObj.listCache.append(&amp;cacheContentRaw{data: content})
        idx := gp.addObj(contentObj)
        page.Contents = fmt.Sprintf("%s %d 0 R ", page.Contents, idx+1)</span>
}

// cacheContentRaw is a cache item that writes raw PDF content stream data.
type cacheContentRaw struct {
        data string
}

func (c *cacheContentRaw) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        _, err := io.WriteString(w, c.data)
        return err
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package gopdf

// GarbageCollectLevel controls how aggressively unused objects are removed.
type GarbageCollectLevel int

const (
        // GCNone performs no garbage collection.
        GCNone GarbageCollectLevel = 0
        // GCCompact removes null/deleted objects and renumbers.
        GCCompact GarbageCollectLevel = 1
        // GCDedup additionally deduplicates identical objects.
        GCDedup GarbageCollectLevel = 2
)

// GarbageCollect removes unused and deleted objects from the document.
// This reduces file size by eliminating null placeholders left by
// DeletePage and other operations.
//
// level controls the aggressiveness:
//   - GCNone (0): no-op
//   - GCCompact (1): remove null objects, renumber references
//   - GCDedup (2): also deduplicate identical stream objects
//
// Returns the number of objects removed.
//
// Example:
//
//        pdf.DeletePage(2)
//        removed := pdf.GarbageCollect(gopdf.GCCompact)
//        fmt.Printf("Removed %d unused objects\n", removed)
func (gp *GoPdf) GarbageCollect(level GarbageCollectLevel) int <span class="cov8" title="1">{
        if level == GCNone </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">removed := 0

        // Phase 1: Mark null/deleted objects.
        liveObjs := make([]IObj, 0, len(gp.pdfObjs))
        oldToNew := make(map[int]int) // old index -&gt; new index

        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if obj == nil </span><span class="cov8" title="1">{
                        removed++
                        continue</span>
                }
                <span class="cov8" title="1">if _, isNull := obj.(nullObj); isNull </span><span class="cov8" title="1">{
                        removed++
                        continue</span>
                }
                <span class="cov8" title="1">oldToNew[i] = len(liveObjs)
                liveObjs = append(liveObjs, obj)</span>
        }

        <span class="cov8" title="1">if removed == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Phase 2: Update internal index references.
        <span class="cov8" title="1">gp.pdfObjs = liveObjs
        gp.reindexAfterCompact(oldToNew)

        // Phase 3: Deduplication (GCDedup only).
        if level &gt;= GCDedup </span><span class="cov8" title="1">{
                removed += gp.deduplicateObjects()
        }</span>

        <span class="cov8" title="1">return removed</span>
}

// deduplicateObjects finds and merges identical ImportedObj instances.
// Returns the number of additional objects removed.
func (gp *GoPdf) deduplicateObjects() int <span class="cov8" title="1">{
        // Build a map of ImportedObj data -&gt; first index.
        type importedKey struct {
                data string
        }
        seen := make(map[importedKey]int) // key -&gt; first occurrence index
        mergeMap := make(map[int]int)     // duplicate index -&gt; canonical index

        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                imp, ok := obj.(*ImportedObj)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key := importedKey{data: imp.Data}
                if firstIdx, exists := seen[key]; exists </span><span class="cov8" title="1">{
                        mergeMap[i] = firstIdx
                }</span> else<span class="cov8" title="1"> {
                        seen[key] = i
                }</span>
        }

        <span class="cov8" title="1">if len(mergeMap) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Replace duplicates with nullObj.
        <span class="cov8" title="1">for dupIdx := range mergeMap </span><span class="cov8" title="1">{
                gp.pdfObjs[dupIdx] = nullObj{}
        }</span>

        // Compact again to remove the new nulls.
        <span class="cov8" title="1">liveObjs := make([]IObj, 0, len(gp.pdfObjs))
        oldToNew := make(map[int]int)
        removed := 0

        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if _, isNull := obj.(nullObj); isNull </span><span class="cov8" title="1">{
                        removed++
                        continue</span>
                }
                <span class="cov8" title="1">oldToNew[i] = len(liveObjs)
                liveObjs = append(liveObjs, obj)</span>
        }

        <span class="cov8" title="1">if removed == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">gp.pdfObjs = liveObjs
        gp.reindexAfterCompact(oldToNew)
        return removed</span>
}

// reindexAfterCompact updates all internal index references after compaction.
func (gp *GoPdf) reindexAfterCompact(oldToNew map[int]int) <span class="cov8" title="1">{
        if newIdx, ok := oldToNew[gp.indexOfCatalogObj]; ok </span><span class="cov8" title="1">{
                gp.indexOfCatalogObj = newIdx
        }</span>
        <span class="cov8" title="1">if newIdx, ok := oldToNew[gp.indexOfPagesObj]; ok </span><span class="cov8" title="1">{
                gp.indexOfPagesObj = newIdx
        }</span>
        <span class="cov8" title="1">if gp.indexOfFirstPageObj &gt;= 0 </span><span class="cov8" title="1">{
                if newIdx, ok := oldToNew[gp.indexOfFirstPageObj]; ok </span><span class="cov8" title="1">{
                        gp.indexOfFirstPageObj = newIdx
                }</span>
        }
        <span class="cov8" title="1">if gp.curr.IndexOfPageObj &gt;= 0 </span><span class="cov8" title="1">{
                if newIdx, ok := oldToNew[gp.curr.IndexOfPageObj]; ok </span><span class="cov8" title="1">{
                        gp.curr.IndexOfPageObj = newIdx
                }</span>
        }
        <span class="cov8" title="1">if gp.indexOfContent &gt;= 0 </span><span class="cov8" title="1">{
                if newIdx, ok := oldToNew[gp.indexOfContent]; ok </span><span class="cov8" title="1">{
                        gp.indexOfContent = newIdx
                }</span>
        }
        <span class="cov8" title="1">if newIdx, ok := oldToNew[gp.indexOfProcSet]; ok </span><span class="cov8" title="1">{
                gp.indexOfProcSet = newIdx
        }</span>
        <span class="cov8" title="1">if gp.indexOfOutlinesObj &gt;= 0 </span><span class="cov8" title="1">{
                if newIdx, ok := oldToNew[gp.indexOfOutlinesObj]; ok </span><span class="cov8" title="1">{
                        gp.indexOfOutlinesObj = newIdx
                }</span>
        }
        <span class="cov8" title="1">for i, idx := range gp.indexEncodingObjFonts </span><span class="cov0" title="0">{
                if newIdx, ok := oldToNew[idx]; ok </span><span class="cov0" title="0">{
                        gp.indexEncodingObjFonts[i] = newIdx
                }</span>
        }
        <span class="cov8" title="1">gp.numOfPagesObj = 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if _, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        gp.numOfPagesObj++
                }</span>
        }
}

// GetObjectCount returns the total number of PDF objects in the document.
// This includes all objects (pages, fonts, images, etc.).
func (gp *GoPdf) GetObjectCount() int <span class="cov8" title="1">{
        return len(gp.pdfObjs)
}</span>

// GetLiveObjectCount returns the number of non-null PDF objects.
func (gp *GoPdf) GetLiveObjectCount() int <span class="cov8" title="1">{
        count := 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, isNull := obj.(nullObj); isNull </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">count++</span>
        }
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package gopdf

import "math"

// RectFrom creates a Rect positioned at (x, y) with width w and height h.
// This is a convenience for working with positioned rectangles.
type RectFrom struct {
        X, Y, W, H float64
}

// Contains returns true if point (px, py) is inside the rectangle.
func (r RectFrom) Contains(px, py float64) bool <span class="cov8" title="1">{
        return px &gt;= r.X &amp;&amp; px &lt;= r.X+r.W &amp;&amp; py &gt;= r.Y &amp;&amp; py &lt;= r.Y+r.H
}</span>

// ContainsRect returns true if other is entirely inside r.
func (r RectFrom) ContainsRect(other RectFrom) bool <span class="cov8" title="1">{
        return other.X &gt;= r.X &amp;&amp; other.Y &gt;= r.Y &amp;&amp;
                other.X+other.W &lt;= r.X+r.W &amp;&amp; other.Y+other.H &lt;= r.Y+r.H
}</span>

// Intersects returns true if r and other overlap.
func (r RectFrom) Intersects(other RectFrom) bool <span class="cov8" title="1">{
        return r.X &lt; other.X+other.W &amp;&amp; r.X+r.W &gt; other.X &amp;&amp;
                r.Y &lt; other.Y+other.H &amp;&amp; r.Y+r.H &gt; other.Y
}</span>

// Intersection returns the overlapping area of two rectangles.
// Returns a zero RectFrom if they don't overlap.
func (r RectFrom) Intersection(other RectFrom) RectFrom <span class="cov8" title="1">{
        if !r.Intersects(other) </span><span class="cov8" title="1">{
                return RectFrom{}
        }</span>
        <span class="cov8" title="1">x := math.Max(r.X, other.X)
        y := math.Max(r.Y, other.Y)
        x2 := math.Min(r.X+r.W, other.X+other.W)
        y2 := math.Min(r.Y+r.H, other.Y+other.H)
        return RectFrom{X: x, Y: y, W: x2 - x, H: y2 - y}</span>
}

// Union returns the smallest rectangle that contains both r and other.
func (r RectFrom) Union(other RectFrom) RectFrom <span class="cov8" title="1">{
        x := math.Min(r.X, other.X)
        y := math.Min(r.Y, other.Y)
        x2 := math.Max(r.X+r.W, other.X+other.W)
        y2 := math.Max(r.Y+r.H, other.Y+other.H)
        return RectFrom{X: x, Y: y, W: x2 - x, H: y2 - y}
}</span>

// IsEmpty returns true if the rectangle has zero or negative area.
func (r RectFrom) IsEmpty() bool <span class="cov8" title="1">{
        return r.W &lt;= 0 || r.H &lt;= 0
}</span>

// Area returns the area of the rectangle.
func (r RectFrom) Area() float64 <span class="cov8" title="1">{
        if r.W &lt;= 0 || r.H &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return r.W * r.H</span>
}

// Center returns the center point of the rectangle.
func (r RectFrom) Center() Point <span class="cov8" title="1">{
        return Point{X: r.X + r.W/2, Y: r.Y + r.H/2}
}</span>

// Normalize ensures W and H are positive, adjusting X and Y if needed.
func (r RectFrom) Normalize() RectFrom <span class="cov8" title="1">{
        if r.W &lt; 0 </span><span class="cov8" title="1">{
                r.X += r.W
                r.W = -r.W
        }</span>
        <span class="cov8" title="1">if r.H &lt; 0 </span><span class="cov8" title="1">{
                r.Y += r.H
                r.H = -r.H
        }</span>
        <span class="cov8" title="1">return r</span>
}

// Matrix represents a 2D affine transformation matrix [a b c d e f].
// The transformation is:
//
//        x' = a*x + c*y + e
//        y' = b*x + d*y + f
type Matrix struct {
        A, B, C, D, E, F float64
}

// IdentityMatrix returns the identity transformation matrix.
func IdentityMatrix() Matrix <span class="cov8" title="1">{
        return Matrix{A: 1, B: 0, C: 0, D: 1, E: 0, F: 0}
}</span>

// TranslateMatrix returns a translation matrix.
func TranslateMatrix(tx, ty float64) Matrix <span class="cov8" title="1">{
        return Matrix{A: 1, B: 0, C: 0, D: 1, E: tx, F: ty}
}</span>

// ScaleMatrix returns a scaling matrix.
func ScaleMatrix(sx, sy float64) Matrix <span class="cov8" title="1">{
        return Matrix{A: sx, B: 0, C: 0, D: sy, E: 0, F: 0}
}</span>

// RotateMatrix returns a rotation matrix for the given angle in degrees.
func RotateMatrix(degrees float64) Matrix <span class="cov8" title="1">{
        rad := degrees * math.Pi / 180
        cos := math.Cos(rad)
        sin := math.Sin(rad)
        return Matrix{A: cos, B: sin, C: -sin, D: cos, E: 0, F: 0}
}</span>

// Multiply returns the product of m and other (m * other).
func (m Matrix) Multiply(other Matrix) Matrix <span class="cov8" title="1">{
        return Matrix{
                A: m.A*other.A + m.C*other.B,
                B: m.B*other.A + m.D*other.B,
                C: m.A*other.C + m.C*other.D,
                D: m.B*other.C + m.D*other.D,
                E: m.A*other.E + m.C*other.F + m.E,
                F: m.B*other.E + m.D*other.F + m.F,
        }
}</span>

// TransformPoint applies the matrix transformation to a point.
func (m Matrix) TransformPoint(x, y float64) (float64, float64) <span class="cov8" title="1">{
        return m.A*x + m.C*y + m.E, m.B*x + m.D*y + m.F
}</span>

// IsIdentity returns true if this is the identity matrix.
func (m Matrix) IsIdentity() bool <span class="cov8" title="1">{
        const eps = 1e-10
        return math.Abs(m.A-1) &lt; eps &amp;&amp; math.Abs(m.B) &lt; eps &amp;&amp;
                math.Abs(m.C) &lt; eps &amp;&amp; math.Abs(m.D-1) &lt; eps &amp;&amp;
                math.Abs(m.E) &lt; eps &amp;&amp; math.Abs(m.F) &lt; eps
}</span>

// Distance returns the Euclidean distance between two points.
func Distance(p1, p2 Point) float64 <span class="cov8" title="1">{
        dx := p2.X - p1.X
        dy := p2.Y - p1.Y
        return math.Sqrt(dx*dx + dy*dy)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package gopdf

import (
        "bufio"
        "bytes"
        "compress/zlib" // for constants
        "errors"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "log"
        "math"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/phpdave11/gofpdi"
)

const subsetFont = "SubsetFont"

const colorSpace = "ColorSpace"

// the default margin if no margins are set
const defaultMargin = 10.0 //for backward compatible

var ErrEmptyString = errors.New("empty string")

var ErrMissingFontFamily = errors.New("font family not found")

var ErrMissingColorSpace = errors.New("color space not found")

var ErrExistsColorSpace = errors.New("color space already exists")

var ErrUndefinedCacheContentImage = errors.New("cacheContentImage is undefined")

var ErrInvalidRectangleCoordinates = errors.New("Invalid coordinates for the rectangle")

var ErrInvalidRectangleRadius = errors.New("Radius length cannot exceed rectangle height or width")

// GoPdf : A simple library for generating PDF written in Go lang
type GoPdf struct {

        //page Margin
        //leftMargin float64
        //topMargin  float64
        margins Margins

        pdfObjs []IObj
        config  Config
        anchors map[string]anchorOption

        indexOfCatalogObj int

        /*---index à¸‚à¸­à¸‡ obj à¸ªà¸³à¸„à¸±à¸à¹† à¹€à¸à¹‡à¸šà¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” loop à¸•à¸­à¸™à¸„à¹‰à¸™à¸«à¸²---*/
        //index à¸‚à¸­à¸‡ obj pages
        indexOfPagesObj int

        //number of pages
        numOfPagesObj int

        //index à¸‚à¸­à¸‡ obj page à¸­à¸±à¸™à¹à¸£à¸
        indexOfFirstPageObj int

        //à¸•à¹ˆà¸³à¹à¸«à¸™à¹ˆà¸‡à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
        curr Current

        indexEncodingObjFonts []int
        indexOfContent        int

        //index à¸‚à¸­à¸‡ procset à¸‹à¸¶à¹ˆà¸‡à¸„à¸§à¸£à¸ˆà¸°à¸¡à¸µà¸­à¸±à¸™à¹€à¸”à¸µà¸¢à¸§
        indexOfProcSet int

        //IsUnderline bool

        // Buffer for io.Reader compliance
        buf bytes.Buffer

        //pdf PProtection
        pdfProtection   *PDFProtection
        encryptionObjID int

        // content streams only
        compressLevel int

        //info
        isUseInfo bool
        info      *PdfInfo

        //outlines
        outlines           *OutlinesObj
        indexOfOutlinesObj int

        //header and footer functions
        headerFunc func()
        footerFunc func()

        // gofpdi free pdf document importer
        fpdi *gofpdi.Importer

        //placeholder text
        placeHolderTexts map[string]([]placeHolderTextInfo)

        //embedded files
        embeddedFiles []embeddedFileRef

        //pdf version
        pdfVersion PDFVersion

        //page labels
        pageLabels []PageLabel

        //xmp metadata
        xmpMetadata *XMPMetadata

        //optional content groups (layers)
        ocgs []ocgRef

        //layer configurations (alternate OCG configs)
        layerConfigs []LayerConfig

        //layer UI configuration
        layerUIConfig *LayerUIConfig

        //form fields (AcroForm)
        formFields []formFieldRef

        //mark info
        markInfo *MarkInfo

        //journal (undo/redo)
        journal *Journal
}

// formFieldRef stores a form field and its object index.
type formFieldRef struct {
        field   FormField
        objIdx  int // index in pdfObjs
}

type DrawableRectOptions struct {
        Rect
        X            float64
        Y            float64
        PaintStyle   PaintStyle
        Transparency *Transparency

        extGStateIndexes []int
}

type CropOptions struct {
        X      float64
        Y      float64
        Width  float64
        Height float64
}

type ImageOptions struct {
        DegreeAngle    float64
        VerticalFlip   bool
        HorizontalFlip bool
        X              float64
        Y              float64
        Rect           *Rect
        Mask           *MaskOptions
        Crop           *CropOptions
        Transparency   *Transparency

        extGStateIndexes []int
}
type ImageFromOption struct {
        Format string //jpeg,png
        X      float64
        Y      float64
        Rect   *Rect
}

type MaskOptions struct {
        ImageOptions
        BBox   *[4]float64
        Holder ImageHolder
}

type lineOptions struct {
        extGStateIndexes []int
}

type polygonOptions struct {
        extGStateIndexes []int
}

// SetLineWidth : set line width
func (gp *GoPdf) SetLineWidth(width float64) <span class="cov8" title="1">{
        gp.curr.lineWidth = gp.UnitsToPoints(width)
        gp.getContent().AppendStreamSetLineWidth(gp.UnitsToPoints(width))
}</span>

// SetCompressLevel : set compress Level for content streams
// Possible values for level:
//
//        -2 HuffmanOnly, -1 DefaultCompression (which is level 6)
//         0 No compression,
//         1 fastest compression, but not very good ratio
//         9 best compression, but slowest
func (gp *GoPdf) SetCompressLevel(level int) <span class="cov8" title="1">{
        errfmt := "compress level too %s, using %s instead\n"
        if level &lt; -2 </span><span class="cov8" title="1">{ //-2 = zlib.HuffmanOnly
                fmt.Fprintf(os.Stderr, errfmt, "small", "DefaultCompression")
                level = zlib.DefaultCompression
        }</span> else<span class="cov8" title="1"> if level &gt; zlib.BestCompression </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, errfmt, "big", "BestCompression")
                level = zlib.BestCompression
                return
        }</span>
        // sanity check complete
        <span class="cov8" title="1">gp.compressLevel = level</span>
}

// SetNoCompression : compressLevel = 0
func (gp *GoPdf) SetNoCompression() <span class="cov8" title="1">{
        gp.compressLevel = zlib.NoCompression
}</span>

// SetLineType : set line type  ("dashed" ,"dotted")
//
//        Usage:
//        pdf.SetLineType("dashed")
//        pdf.Line(50, 200, 550, 200)
//        pdf.SetLineType("dotted")
//        pdf.Line(50, 400, 550, 400)
func (gp *GoPdf) SetLineType(linetype string) <span class="cov8" title="1">{
        gp.getContent().AppendStreamSetLineType(linetype)
}</span>

// SetCustomLineType : set custom line type
//
//        Usage:
//        pdf.SetCustomLineType([]float64{0.8, 0.8}, 0)
//        pdf.Line(50, 200, 550, 200)
func (gp *GoPdf) SetCustomLineType(dashArray []float64, dashPhase float64) <span class="cov8" title="1">{
        for i := range dashArray </span><span class="cov8" title="1">{
                gp.UnitsToPointsVar(&amp;dashArray[i])
        }</span>
        <span class="cov8" title="1">gp.UnitsToPointsVar(&amp;dashPhase)
        gp.getContent().AppendStreamSetCustomLineType(dashArray, dashPhase)</span>
}

// Line : draw line
//
//        Usage:
//        pdf.SetTransparency(gopdf.Transparency{Alpha: 0.5,BlendModeType: gopdf.ColorBurn})
//        pdf.SetLineType("dotted")
//        pdf.SetStrokeColor(255, 0, 0)
//        pdf.SetLineWidth(2)
//        pdf.Line(10, 30, 585, 30)
//        pdf.ClearTransparency()
func (gp *GoPdf) Line(x1 float64, y1 float64, x2 float64, y2 float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x1, &amp;y1, &amp;x2, &amp;y2)
        transparency, err := gp.getCachedTransparency(nil)
        if err != nil </span><span class="cov0" title="0">{
                transparency = nil
        }</span>
        <span class="cov8" title="1">var opts = lineOptions{}
        if transparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)
        }</span>
        <span class="cov8" title="1">gp.getContent().AppendStreamLine(x1, y1, x2, y2, opts)</span>
}

// RectFromLowerLeft : draw rectangle from lower-left corner (x, y)
func (gp *GoPdf) RectFromLowerLeft(x float64, y float64, wdth float64, hght float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y, &amp;wdth, &amp;hght)

        opts := DrawableRectOptions{
                X:          x,
                Y:          y,
                PaintStyle: DrawPaintStyle,
                Rect:       Rect{W: wdth, H: hght},
        }

        gp.getContent().AppendStreamRectangle(opts)
}</span>

// RectFromUpperLeft : draw rectangle from upper-left corner (x, y)
func (gp *GoPdf) RectFromUpperLeft(x float64, y float64, wdth float64, hght float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y, &amp;wdth, &amp;hght)

        opts := DrawableRectOptions{
                X:          x,
                Y:          y + hght,
                PaintStyle: DrawPaintStyle,
                Rect:       Rect{W: wdth, H: hght},
        }

        gp.getContent().AppendStreamRectangle(opts)
}</span>

// RectFromLowerLeftWithStyle : draw rectangle from lower-left corner (x, y)
//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw. This is the default value.
//     F: fill
//     DF or FD: draw and fill
func (gp *GoPdf) RectFromLowerLeftWithStyle(x float64, y float64, wdth float64, hght float64, style string) <span class="cov8" title="1">{
        opts := DrawableRectOptions{
                X: x,
                Y: y,
                Rect: Rect{
                        H: hght,
                        W: wdth,
                },
                PaintStyle: parseStyle(style),
        }
        gp.RectFromLowerLeftWithOpts(opts)
}</span>

func (gp *GoPdf) RectFromLowerLeftWithOpts(opts DrawableRectOptions) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;opts.X, &amp;opts.Y, &amp;opts.W, &amp;opts.H)

        imageTransparency, err := gp.getCachedTransparency(opts.Transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if imageTransparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">gp.getContent().AppendStreamRectangle(opts)

        return nil</span>
}

// RectFromUpperLeftWithStyle : draw rectangle from upper-left corner (x, y)
//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw. This is the default value.
//     F: fill
//     DF or FD: draw and fill
func (gp *GoPdf) RectFromUpperLeftWithStyle(x float64, y float64, wdth float64, hght float64, style string) <span class="cov8" title="1">{
        opts := DrawableRectOptions{
                X: x,
                Y: y,
                Rect: Rect{
                        H: hght,
                        W: wdth,
                },
                PaintStyle: parseStyle(style),
        }
        gp.RectFromUpperLeftWithOpts(opts)
}</span>

func (gp *GoPdf) RectFromUpperLeftWithOpts(opts DrawableRectOptions) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;opts.X, &amp;opts.Y, &amp;opts.W, &amp;opts.H)

        opts.Y += opts.H

        imageTransparency, err := gp.getCachedTransparency(opts.Transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if imageTransparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">gp.getContent().AppendStreamRectangle(opts)

        return nil</span>
}

// Oval : draw oval
func (gp *GoPdf) Oval(x1 float64, y1 float64, x2 float64, y2 float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x1, &amp;y1, &amp;x2, &amp;y2)
        gp.getContent().AppendStreamOval(x1, y1, x2, y2)
}</span>

// Br : new line
func (gp *GoPdf) Br(h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;h)
        gp.curr.Y += h
        gp.curr.X = gp.margins.Left
}</span>

// SetGrayFill set the grayscale for the fill, takes a float64 between 0.0 and 1.0
func (gp *GoPdf) SetGrayFill(grayScale float64) <span class="cov8" title="1">{
        gp.curr.txtColorMode = "gray"
        gp.curr.grayFill = grayScale
        gp.getContent().AppendStreamSetGrayFill(grayScale)
}</span>

// SetGrayStroke set the grayscale for the stroke, takes a float64 between 0.0 and 1.0
func (gp *GoPdf) SetGrayStroke(grayScale float64) <span class="cov8" title="1">{
        gp.curr.grayStroke = grayScale
        gp.getContent().AppendStreamSetGrayStroke(grayScale)
}</span>

// SetX : set current position X
func (gp *GoPdf) SetX(x float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x)
        gp.curr.setXCount++
        gp.curr.X = x
}</span>

// GetX : get current position X
func (gp *GoPdf) GetX() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.curr.X)
}</span>

// SetNewY : set current position y, and modified y if add a new page.
// Example:
// For example, if the page height is set to 841px, MarginTop is 20px,
// MarginBottom is 10px, and the height of the element(such as text) to be inserted is 25px,
// because 10&lt;25, you need to add another page and set y to 20px.
// Because of called AddPage(), X is set to MarginLeft, so you should specify X if needed,
// or make sure SetX() is after SetNewY(), or using SetNewXY().
// SetNewYIfNoOffset is more suitable for scenarios where the offset does not change, such as pdf.Image().
func (gp *GoPdf) SetNewY(y float64, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if gp.curr.Y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() </span><span class="cov8" title="1">{
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }</span>
        <span class="cov8" title="1">gp.curr.Y = y</span>
}

// SetNewYIfNoOffset : set current position y, and modified y if add a new page.
// Example:
// For example, if the page height is set to 841px, MarginTop is 20px,
// MarginBottom is 10px, and the height of the element(such as image) to be inserted is 200px,
// because 10&lt;200, you need to add another page and set y to 20px.
// Tips: gp.curr.X and gp.curr.Y do not change when pdf.Image() is called.
func (gp *GoPdf) SetNewYIfNoOffset(y float64, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() </span><span class="cov8" title="1">{ // using new y(*y) instead of gp.curr.Y
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }</span>
        <span class="cov8" title="1">gp.curr.Y = y</span>
}

// SetNewXY : set current position x and y, and modified y if add a new page.
// Example:
// For example, if the page height is set to 841px, MarginTop is 20px,
// MarginBottom is 10px, and the height of the element to be inserted is 25px,
// because 10&lt;25, you need to add another page and set y to 20px.
// Because of AddPage(), X is set to MarginLeft, so you should specify X if needed,
// or make sure SetX() is after SetNewY().
func (gp *GoPdf) SetNewXY(y float64, x, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if gp.curr.Y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() </span><span class="cov8" title="1">{
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }</span>
        <span class="cov8" title="1">gp.curr.Y = y
        gp.SetX(x)</span>
}

/*
//experimental
func (gp *GoPdf) SetNewY(y float64, h float64) float64 {
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if gp.curr.Y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() {
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }
        gp.curr.Y = y
        return gp.GetY()
}

//experimental
func (gp *GoPdf) SetNewYIfNoOffset(y float64, h float64) float64 {
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() { // using new y(*y) instead of gp.curr.Y
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }
        gp.curr.Y = y
        return gp.GetY()
}

//experimental
func (gp *GoPdf) SetNewXY(y float64, x, h float64) float64{
        gp.UnitsToPointsVar(&amp;y)
        gp.UnitsToPointsVar(&amp;h)
        if gp.curr.Y+h &gt; gp.curr.pageSize.H-gp.MarginBottom() {
                gp.AddPage()
                y = gp.MarginTop() // reset to top of the page.
        }
        gp.curr.Y = y
        gp.SetX(x)
        return gp.GetY()
}
*/

// SetY : set current position y
func (gp *GoPdf) SetY(y float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;y)
        gp.curr.Y = y
}</span>

// GetY : get current position y
func (gp *GoPdf) GetY() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.curr.Y)
}</span>

// SetXY : set current position x and y
func (gp *GoPdf) SetXY(x, y float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x)
        gp.curr.setXCount++
        gp.curr.X = x

        gp.UnitsToPointsVar(&amp;y)
        gp.curr.Y = y
}</span>

// ImageByHolder : draw image by ImageHolder
func (gp *GoPdf) ImageByHolder(img ImageHolder, x float64, y float64, rect *Rect) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y)

        rect = rect.UnitsToPoints(gp.config.Unit)

        imageOptions := ImageOptions{
                X:    x,
                Y:    y,
                Rect: rect,
        }

        return gp.imageByHolder(img, imageOptions)
}</span>

func (gp *GoPdf) ImageByHolderWithOptions(img ImageHolder, opts ImageOptions) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;opts.X, &amp;opts.Y)

        opts.Rect = opts.Rect.UnitsToPoints(gp.config.Unit)

        imageTransparency, err := gp.getCachedTransparency(opts.Transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if imageTransparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">if opts.Mask != nil </span><span class="cov8" title="1">{
                maskTransparency, err := gp.getCachedTransparency(opts.Mask.ImageOptions.Transparency)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if maskTransparency != nil </span><span class="cov0" title="0">{
                        opts.Mask.ImageOptions.extGStateIndexes = append(opts.Mask.ImageOptions.extGStateIndexes, maskTransparency.extGStateIndex)
                }</span>

                <span class="cov8" title="1">gp.UnitsToPointsVar(&amp;opts.Mask.ImageOptions.X, &amp;opts.Mask.ImageOptions.Y)
                opts.Mask.ImageOptions.Rect = opts.Mask.ImageOptions.Rect.UnitsToPoints(gp.config.Unit)

                extGStateIndex, err := gp.maskHolder(opts.Mask.Holder, *opts.Mask)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">opts.extGStateIndexes = append(opts.extGStateIndexes, extGStateIndex)</span>
        }

        <span class="cov8" title="1">return gp.imageByHolder(img, opts)</span>
}

func (gp *GoPdf) maskHolder(img ImageHolder, opts MaskOptions) (int, error) <span class="cov8" title="1">{
        var cacheImage *ImageCache
        var cacheContentImage *cacheContentImage

        for _, imgcache := range gp.curr.ImgCaches </span><span class="cov8" title="1">{
                if img.ID() == imgcache.Path </span><span class="cov8" title="1">{
                        cacheImage = &amp;imgcache
                        break</span>
                }
        }

        <span class="cov8" title="1">if cacheImage == nil </span><span class="cov8" title="1">{
                maskImgobj := &amp;ImageObj{IsMask: true}
                maskImgobj.init(func() *GoPdf </span><span class="cov0" title="0">{
                        return gp
                }</span>)
                <span class="cov8" title="1">maskImgobj.setProtection(gp.protection())

                err := maskImgobj.SetImage(img)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">if opts.Rect == nil </span><span class="cov8" title="1">{
                        if opts.Rect, err = maskImgobj.getRect(); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }

                <span class="cov8" title="1">if err := maskImgobj.parse(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">if gp.indexOfProcSet != -1 </span><span class="cov8" title="1">{
                        index := gp.addObj(maskImgobj)
                        cacheContentImage = gp.getContent().GetCacheContentImage(index, opts.ImageOptions)
                        procset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)
                        procset.RelateXobjs = append(procset.RelateXobjs, RelateXobject{IndexOfObj: index})

                        imgcache := ImageCache{
                                Index: index,
                                Path:  img.ID(),
                                Rect:  opts.Rect,
                        }
                        gp.curr.ImgCaches[index] = imgcache
                        gp.curr.CountOfImg++
                }</span>
        } else<span class="cov8" title="1"> {
                if opts.Rect == nil </span><span class="cov0" title="0">{
                        opts.Rect = gp.curr.ImgCaches[cacheImage.Index].Rect
                }</span>

                <span class="cov8" title="1">cacheContentImage = gp.getContent().GetCacheContentImage(cacheImage.Index, opts.ImageOptions)</span>
        }

        <span class="cov8" title="1">if cacheContentImage != nil </span><span class="cov8" title="1">{
                extGStateInd, err := gp.createTransparencyXObjectGroup(cacheContentImage, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">return extGStateInd, nil</span>
        }

        <span class="cov0" title="0">return 0, ErrUndefinedCacheContentImage</span>
}

func (gp *GoPdf) createTransparencyXObjectGroup(image *cacheContentImage, opts MaskOptions) (int, error) <span class="cov8" title="1">{
        bbox := opts.BBox
        if bbox == nil </span><span class="cov8" title="1">{
                bbox = &amp;[4]float64{
                        // correct BBox values is [opts.X, gp.curr.pageSize.H - opts.Y - opts.Rect.H, opts.X + opts.Rect.W, gp.curr.pageSize.H - opts.Y]
                        // but if compress pdf through ghostscript result file can't open correctly in mac viewer, because mac viewer can't parse BBox value correctly
                        // all other viewers parse BBox correctly (like Adobe Acrobat Reader, Chrome, even Internet Explorer)
                        // that's why we need to set [0, 0, gp.curr.pageSize.W, gp.curr.pageSize.H]
                        -gp.curr.pageSize.W * 2,
                        -gp.curr.pageSize.H * 2,
                        gp.curr.pageSize.W * 2,
                        gp.curr.pageSize.H * 2,
                        // Also, Chrome pdf viewer incorrectly recognize BBox value, that's why we need to set twice as much value
                        // for every mask element will be displayed
                }
        }</span>

        <span class="cov8" title="1">groupOpts := TransparencyXObjectGroupOptions{
                BBox:             *bbox,
                ExtGStateIndexes: opts.extGStateIndexes,
                XObjects:         []cacheContentImage{*image},
        }

        transparencyXObjectGroup, err := GetCachedTransparencyXObjectGroup(groupOpts, gp)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">sMaskOptions := SMaskOptions{
                Subtype:                       SMaskLuminositySubtype,
                TransparencyXObjectGroupIndex: transparencyXObjectGroup.Index,
        }
        sMask := GetCachedMask(sMaskOptions, gp)

        extGStateOpts := ExtGStateOptions{SMaskIndex: &amp;sMask.Index}
        extGState, err := GetCachedExtGState(extGStateOpts, gp)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return extGState.Index + 1, nil</span>
}

func (gp *GoPdf) imageByHolder(img ImageHolder, opts ImageOptions) error <span class="cov8" title="1">{
        cacheImageIndex := -1

        for _, imgcache := range gp.curr.ImgCaches </span><span class="cov8" title="1">{
                if img.ID() == imgcache.Path </span><span class="cov8" title="1">{
                        cacheImageIndex = imgcache.Index
                        break</span>
                }
        }

        <span class="cov8" title="1">if cacheImageIndex == -1 </span><span class="cov8" title="1">{ //new image

                //create img object
                imgobj := new(ImageObj)
                if opts.Mask != nil </span><span class="cov8" title="1">{
                        imgobj.SplittedMask = true
                }</span>

                <span class="cov8" title="1">imgobj.init(func() *GoPdf </span><span class="cov0" title="0">{
                        return gp
                }</span>)
                <span class="cov8" title="1">imgobj.setProtection(gp.protection())

                err := imgobj.SetImage(img)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if opts.Rect == nil </span><span class="cov8" title="1">{
                        if opts.Rect, err = imgobj.getRect(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">err = imgobj.parse()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">index := gp.addObj(imgobj)
                if gp.indexOfProcSet != -1 </span><span class="cov8" title="1">{
                        //à¸¢à¸±à¸”à¸£à¸¹à¸›
                        procset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)
                        gp.getContent().AppendStreamImage(index, opts)
                        procset.RelateXobjs = append(procset.RelateXobjs, RelateXobject{IndexOfObj: index})
                        //à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸£à¸¹à¸›à¹€à¸­à¸²à¹„à¸§à¹‰
                        var imgcache ImageCache
                        imgcache.Index = index
                        imgcache.Path = img.ID()
                        imgcache.Rect = opts.Rect
                        gp.curr.ImgCaches[index] = imgcache
                        gp.curr.CountOfImg++
                }</span>

                <span class="cov8" title="1">if imgobj.haveSMask() </span><span class="cov8" title="1">{
                        smaskObj, err := imgobj.createSMask()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">imgobj.imginfo.smarkObjID = gp.addObj(smaskObj)</span>
                }

                <span class="cov8" title="1">if imgobj.isColspaceIndexed() </span><span class="cov8" title="1">{
                        dRGB, err := imgobj.createDeviceRGB()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">dRGB.getRoot = func() *GoPdf </span><span class="cov8" title="1">{
                                return gp
                        }</span>
                        <span class="cov8" title="1">imgobj.imginfo.deviceRGBObjID = gp.addObj(dRGB)</span>
                }

        } else<span class="cov8" title="1"> { //same img
                if opts.Rect == nil </span><span class="cov8" title="1">{
                        opts.Rect = gp.curr.ImgCaches[cacheImageIndex].Rect
                }</span>

                <span class="cov8" title="1">gp.getContent().AppendStreamImage(cacheImageIndex, opts)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Image : draw image
func (gp *GoPdf) Image(picPath string, x float64, y float64, rect *Rect) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y)
        rect = rect.UnitsToPoints(gp.config.Unit)
        imgh, err := ImageHolderByPath(picPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">imageOptions := ImageOptions{
                X:    x,
                Y:    y,
                Rect: rect,
        }

        return gp.imageByHolder(imgh, imageOptions)</span>
}

func (gp *GoPdf) ImageFrom(img image.Image, x float64, y float64, rect *Rect) error <span class="cov8" title="1">{
        return gp.ImageFromWithOption(img, ImageFromOption{
                Format: "png",
                X:      x,
                Y:      y,
                Rect:   rect,
        })
}</span>

func (gp *GoPdf) ImageFromWithOption(img image.Image, opts ImageFromOption) error <span class="cov8" title="1">{
        if img == nil </span><span class="cov8" title="1">{
                return errors.New("Invalid image")
        }</span>

        <span class="cov8" title="1">gp.UnitsToPointsVar(&amp;opts.X, &amp;opts.Y)
        opts.Rect = opts.Rect.UnitsToPoints(gp.config.Unit)
        r, w := io.Pipe()
        go func() </span><span class="cov8" title="1">{
                bw := bufio.NewWriter(w)
                var err error
                switch opts.Format </span>{
                case "png":<span class="cov8" title="1">
                        err = png.Encode(bw, img)</span>
                case "jpeg":<span class="cov8" title="1">
                        err = jpeg.Encode(bw, img, nil)</span>
                }

                <span class="cov8" title="1">bw.Flush()
                if err != nil </span><span class="cov0" title="0">{
                        w.CloseWithError(err)
                }</span> else<span class="cov8" title="1"> {
                        w.Close()
                }</span>
        }()

        <span class="cov8" title="1">imgh, err := ImageHolderByReader(bufio.NewReader(r))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">imageOptions := ImageOptions{
                X:    opts.X,
                Y:    opts.Y,
                Rect: opts.Rect,
        }

        return gp.imageByHolder(imgh, imageOptions)</span>
}

// AddPage : add new page
func (gp *GoPdf) AddPage() <span class="cov8" title="1">{
        emptyOpt := PageOption{}
        gp.AddPageWithOption(emptyOpt)
}</span>

// AddPageWithOption  : add new page with option
func (gp *GoPdf) AddPageWithOption(opt PageOption) <span class="cov8" title="1">{
        opt.TrimBox = opt.TrimBox.UnitsToPoints(gp.config.Unit)
        opt.PageSize = opt.PageSize.UnitsToPoints(gp.config.Unit)

        page := new(PageObj)
        page.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)

        <span class="cov8" title="1">if !opt.isEmpty() </span><span class="cov8" title="1">{ //use page option
                page.setOption(opt)
                gp.curr.pageSize = opt.PageSize

                if opt.isTrimBoxSet() </span><span class="cov8" title="1">{
                        gp.curr.trimBox = opt.TrimBox
                }</span>
        } else<span class="cov8" title="1"> { //use default
                gp.curr.pageSize = &amp;gp.config.PageSize
                gp.curr.trimBox = &amp;gp.config.TrimBox
        }</span>

        <span class="cov8" title="1">page.ResourcesRelate = strconv.Itoa(gp.indexOfProcSet+1) + " 0 R"
        index := gp.addObj(page)
        if gp.indexOfFirstPageObj == -1 </span><span class="cov8" title="1">{
                gp.indexOfFirstPageObj = index
        }</span>
        <span class="cov8" title="1">gp.curr.IndexOfPageObj = index

        gp.numOfPagesObj++

        //reset
        gp.indexOfContent = -1
        gp.resetCurrXY()

        if gp.headerFunc != nil </span><span class="cov8" title="1">{
                gp.headerFunc()
                gp.resetCurrXY()
        }</span>

        <span class="cov8" title="1">if gp.footerFunc != nil </span><span class="cov8" title="1">{
                gp.footerFunc()
                gp.resetCurrXY()
        }</span>
}

func (gp *GoPdf) AddOutline(title string) <span class="cov8" title="1">{
        gp.outlines.AddOutline(gp.curr.IndexOfPageObj+1, title)
}</span>

// AddOutlineWithPosition add an outline with position
func (gp *GoPdf) AddOutlineWithPosition(title string) *OutlineObj <span class="cov8" title="1">{
        return gp.outlines.AddOutlinesWithPosition(gp.curr.IndexOfPageObj+1, title, gp.config.PageSize.H-gp.curr.Y+20)
}</span>

// AddHeader - add a header function, if present this will be automatically called by AddPage()
func (gp *GoPdf) AddHeader(f func()) <span class="cov8" title="1">{
        gp.headerFunc = f
}</span>

// AddFooter - add a footer function, if present this will be automatically called by AddPage()
func (gp *GoPdf) AddFooter(f func()) <span class="cov8" title="1">{
        gp.footerFunc = f
}</span>

// Start : init gopdf
func (gp *GoPdf) Start(config Config) <span class="cov8" title="1">{

        gp.start(config)

}</span>

func (gp *GoPdf) StartWithImporter(config Config, importer *gofpdi.Importer) <span class="cov8" title="1">{

        gp.start(config, importer)

}</span>

func (gp *GoPdf) start(config Config, importer ...*gofpdi.Importer) <span class="cov8" title="1">{

        gp.config = config
        gp.init(importer...)
        //init all basic obj
        catalog := new(CatalogObj)
        catalog.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">pages := new(PagesObj)
        pages.init(func() *GoPdf </span><span class="cov8" title="1">{
                return gp
        }</span>)
        <span class="cov8" title="1">gp.outlines = new(OutlinesObj)
        gp.outlines.init(func() *GoPdf </span><span class="cov8" title="1">{
                return gp
        }</span>)
        <span class="cov8" title="1">gp.indexOfCatalogObj = gp.addObj(catalog)
        gp.indexOfPagesObj = gp.addObj(pages)
        gp.indexOfOutlinesObj = gp.addObj(gp.outlines)
        gp.outlines.SetIndexObjOutlines(gp.indexOfOutlinesObj)

        //indexOfProcSet
        procset := new(ProcSetObj)
        procset.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">gp.indexOfProcSet = gp.addObj(procset)

        if gp.isUseProtection() </span><span class="cov8" title="1">{
                gp.pdfProtection = gp.createProtection()
        }</span>

        <span class="cov8" title="1">gp.placeHolderTexts = make(map[string][]placeHolderTextInfo)</span>

}

// convertNumericToFloat64 : accept numeric types, return float64-value
func convertNumericToFloat64(size interface{}) (fontSize float64, err error) <span class="cov8" title="1">{
        switch size := size.(type) </span>{
        case float32:<span class="cov8" title="1">
                return float64(size), nil</span>
        case float64:<span class="cov8" title="1">
                return float64(size), nil</span>
        case int:<span class="cov8" title="1">
                return float64(size), nil</span>
        case int16:<span class="cov8" title="1">
                return float64(size), nil</span>
        case int32:<span class="cov8" title="1">
                return float64(size), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(size), nil</span>
        case int8:<span class="cov8" title="1">
                return float64(size), nil</span>
        case uint:<span class="cov8" title="1">
                return float64(size), nil</span>
        case uint16:<span class="cov8" title="1">
                return float64(size), nil</span>
        case uint32:<span class="cov8" title="1">
                return float64(size), nil</span>
        case uint64:<span class="cov8" title="1">
                return float64(size), nil</span>
        case uint8:<span class="cov8" title="1">
                return float64(size), nil</span>
        default:<span class="cov8" title="1">
                return 0.0, fmt.Errorf("fontSize must be of type (u)int* or float*, not %T", size)</span>
        }
}

// SetFontWithStyle : set font style support Regular or Underline
// for Bold|Italic should be loaded appropriate fonts with same styles defined
// size MUST be uint*, int* or float64*
func (gp *GoPdf) SetFontWithStyle(family string, style int, size interface{}) error <span class="cov8" title="1">{
        fontSize, err := convertNumericToFloat64(size)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">found := false
        i := 0
        max := len(gp.pdfObjs)
        for i &lt; max </span><span class="cov8" title="1">{
                if gp.pdfObjs[i].getType() == subsetFont </span><span class="cov8" title="1">{
                        obj := gp.pdfObjs[i]
                        sub, ok := obj.(*SubsetFontObj)
                        if ok </span><span class="cov8" title="1">{
                                if sub.GetFamily() == family &amp;&amp; sub.GetTtfFontOption().Style == style&amp;^Underline </span><span class="cov8" title="1">{
                                        gp.curr.FontSize = fontSize
                                        gp.curr.FontStyle = style
                                        gp.curr.FontFontCount = sub.CountOfFont
                                        gp.curr.FontISubset = sub
                                        found = true
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return ErrMissingFontFamily
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetFont : set font style support "" or "U"
// for "B" and "I" should be loaded appropriate fonts with same styles defined
// size MUST be uint*, int* or float64*
func (gp *GoPdf) SetFont(family string, style string, size interface{}) error <span class="cov8" title="1">{
        return gp.SetFontWithStyle(family, getConvertedStyle(style), size)
}</span>

// SetFontSize : set the font size (and only the font size) of the currently
// active font
func (gp *GoPdf) SetFontSize(fontSize float64) error <span class="cov8" title="1">{
        gp.curr.FontSize = fontSize
        return nil
}</span>

// SetCharSpacing : set the character spacing of the currently active font
func (gp *GoPdf) SetCharSpacing(charSpacing float64) error <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;charSpacing)
        gp.curr.CharSpacing = charSpacing
        return nil
}</span>

// WritePdf : write pdf file
func (gp *GoPdf) WritePdf(pdfPath string) error <span class="cov8" title="1">{
        return os.WriteFile(pdfPath, gp.GetBytesPdf(), 0644)
}</span>

// WriteTo implements the io.WriterTo interface and can
// be used to stream the PDF as it is compiled to an io.Writer.
func (gp *GoPdf) WriteTo(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        return gp.compilePdf(w)
}</span>

// Write streams the pdf as it is compiled to an io.Writer
//
// Deprecated: use the WriteTo method instead.
func (gp *GoPdf) Write(w io.Writer) error <span class="cov8" title="1">{
        _, err := gp.compilePdf(w)
        return err
}</span>

func (gp *GoPdf) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if gp.buf.Len() == 0 &amp;&amp; gp.buf.Cap() == 0 </span><span class="cov8" title="1">{
                if _, err := gp.compilePdf(&amp;gp.buf); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }
        <span class="cov8" title="1">return gp.buf.Read(p)</span>
}

// Close clears the gopdf buffer.
func (gp *GoPdf) Close() error <span class="cov8" title="1">{
        gp.buf = bytes.Buffer{}
        return nil
}</span>

func (gp *GoPdf) compilePdf(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        gp.prepare()
        err = gp.Close()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">max := len(gp.pdfObjs)
        writer := newCountingWriter(w)
        fmt.Fprintf(writer, "%s\n%%\xe2\xe3\xcf\xd3\n\n", gp.GetPDFVersion().Header())
        linelens := make([]int64, max)
        i := 0

        for i &lt; max </span><span class="cov8" title="1">{
                objID := i + 1
                linelens[i] = writer.offset
                pdfObj := gp.pdfObjs[i]
                fmt.Fprintf(writer, "%d 0 obj\n", objID)
                pdfObj.write(writer, objID)
                io.WriteString(writer, "endobj\n\n")
                i++
        }</span>
        <span class="cov8" title="1">gp.xref(writer, writer.offset, linelens, i)
        return writer.offset, nil</span>
}

type (
        countingWriter struct {
                offset int64
                writer io.Writer
        }
)

func newCountingWriter(w io.Writer) *countingWriter <span class="cov8" title="1">{
        return &amp;countingWriter{writer: w}
}</span>

func (cw *countingWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        n, err := cw.writer.Write(b)
        cw.offset += int64(n)
        return n, err
}</span>

// GetBytesPdfReturnErr : get bytes of pdf file
func (gp *GoPdf) GetBytesPdfReturnErr() ([]byte, error) <span class="cov8" title="1">{
        err := gp.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = gp.compilePdf(&amp;gp.buf)
        return gp.buf.Bytes(), err</span>
}

// GetBytesPdf returns the PDF content as bytes.
//
// Deprecated: This method calls log.Fatalf on error, which terminates the
// program. Use GetBytesPdfReturnErr instead.
func (gp *GoPdf) GetBytesPdf() []byte <span class="cov8" title="1">{
        b, err := gp.GetBytesPdfReturnErr()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%s", err.Error())
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Text write text start at current x,y ( current y is the baseline of text )
func (gp *GoPdf) Text(text string) error <span class="cov8" title="1">{

        text, err := gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = gp.getContent().AppendStreamText(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CellWithOption create cell of text ( use current x,y is upper-left corner of cell)
func (gp *GoPdf) CellWithOption(rectangle *Rect, text string, opt CellOption) error <span class="cov8" title="1">{
        transparency, err := gp.getCachedTransparency(opt.Transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if transparency != nil </span><span class="cov8" title="1">{
                opt.extGStateIndexes = append(opt.extGStateIndexes, transparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">rectangle = rectangle.UnitsToPoints(gp.config.Unit)
        text, err = gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := gp.getContent().AppendStreamSubsetFont(rectangle, text, opt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Cell : create cell of text ( use current x,y is upper-left corner of cell)
// Note that this has no effect on Rect.H pdf (now). Fix later :-)
func (gp *GoPdf) Cell(rectangle *Rect, text string) error <span class="cov8" title="1">{
        rectangle = rectangle.UnitsToPoints(gp.config.Unit)
        defaultopt := CellOption{
                Align:  Left | Top,
                Border: 0,
                Float:  Right,
        }

        text, err := gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = gp.getContent().AppendStreamSubsetFont(rectangle, text, defaultopt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MultiCell : create of text with line breaks ( use current x,y is upper-left corner of cell)
func (gp *GoPdf) MultiCell(rectangle *Rect, text string) error <span class="cov8" title="1">{
        var line []rune
        x := gp.GetX()
        var totalLineHeight float64
        length := len([]rune(text))

        // get lineHeight
        text, err := gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, lineHeight, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gp.PointsToUnitsVar(&amp;lineHeight)

        for i, v := range []rune(text) </span><span class="cov8" title="1">{
                if totalLineHeight+lineHeight &gt; rectangle.H </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">lineWidth, _ := gp.MeasureTextWidth(string(line))
                runeWidth, _ := gp.MeasureTextWidth(string(v))

                if lineWidth+runeWidth &gt; rectangle.W </span><span class="cov8" title="1">{
                        gp.Cell(&amp;Rect{W: rectangle.W, H: lineHeight}, string(line))
                        gp.Br(lineHeight)
                        gp.SetX(x)
                        totalLineHeight = totalLineHeight + lineHeight
                        line = nil
                }</span>

                <span class="cov8" title="1">line = append(line, v)

                if i == length-1 </span><span class="cov8" title="1">{
                        gp.Cell(&amp;Rect{W: rectangle.W, H: lineHeight}, string(line))
                        gp.Br(lineHeight)
                        gp.SetX(x)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsFitMultiCell : check whether the rectangle's area is big enough for the text
func (gp *GoPdf) IsFitMultiCell(rectangle *Rect, text string) (bool, float64, error) <span class="cov8" title="1">{
        var line []rune
        var totalLineHeight float64
        length := len([]rune(text))

        // get lineHeight
        text, err := gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return false, totalLineHeight, err
        }</span>
        <span class="cov8" title="1">_, lineHeight, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)

        if err != nil </span><span class="cov0" title="0">{
                return false, totalLineHeight, err
        }</span>
        <span class="cov8" title="1">gp.PointsToUnitsVar(&amp;lineHeight)

        for i, v := range []rune(text) </span><span class="cov8" title="1">{
                if totalLineHeight+lineHeight &gt; rectangle.H </span><span class="cov8" title="1">{
                        return false, totalLineHeight, nil
                }</span>
                <span class="cov8" title="1">lineWidth, _ := gp.MeasureTextWidth(string(line))
                runeWidth, _ := gp.MeasureTextWidth(string(v))

                if lineWidth+runeWidth &gt; rectangle.W </span><span class="cov8" title="1">{
                        totalLineHeight += lineHeight
                        line = nil
                }</span>

                <span class="cov8" title="1">line = append(line, v)

                if i == length-1 </span><span class="cov8" title="1">{
                        totalLineHeight += lineHeight
                }</span>
        }

        <span class="cov8" title="1">ok := true
        if totalLineHeight &gt; rectangle.H </span><span class="cov0" title="0">{
                ok = false
        }</span>

        <span class="cov8" title="1">return ok, totalLineHeight, nil</span>
}

// IsFitMultiCellWithNewline : similar to IsFitMultiCell, but process char newline as Br
func (gp *GoPdf) IsFitMultiCellWithNewline(rectangle *Rect, text string) (bool, float64, error) <span class="cov8" title="1">{
        r := *rectangle
        strs := strings.Split(text, "\n")

        for _, s := range strs </span><span class="cov8" title="1">{
                ok, height, err := gp.IsFitMultiCell(&amp;r, s)
                if err != nil || !ok </span><span class="cov8" title="1">{
                        return false, 0, err
                }</span>
                <span class="cov8" title="1">r.H -= height</span>
        }

        <span class="cov8" title="1">return true, rectangle.H - r.H, nil</span>
}

// MultiCellWithOption create of text with line breaks ( use current x,y is upper-left corner of cell)
func (gp *GoPdf) MultiCellWithOption(rectangle *Rect, text string, opt CellOption) error <span class="cov8" title="1">{
        if opt.BreakOption == nil </span><span class="cov8" title="1">{
                opt.BreakOption = &amp;DefaultBreakOption
        }</span>

        <span class="cov8" title="1">transparency, err := gp.getCachedTransparency(opt.Transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if transparency != nil </span><span class="cov8" title="1">{
                opt.extGStateIndexes = append(opt.extGStateIndexes, transparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">x := gp.GetX()

        // get lineHeight
        itext, err := gp.curr.FontISubset.AddChars(text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, lineHeight, _, err := createContent(gp.curr.FontISubset, itext, gp.curr.FontSize, gp.curr.CharSpacing, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gp.PointsToUnitsVar(&amp;lineHeight)

        textSplits, err := gp.SplitTextWithOption(text, rectangle.W, opt.BreakOption)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">startHeight := rectangle.H
        if l := len(textSplits); l &gt; 1 </span><span class="cov8" title="1">{
                shiftLines := l / 2
                if l%2 != 0 </span><span class="cov8" title="1">{
                        shiftLines += 1
                }</span>
                <span class="cov8" title="1">startHeight = rectangle.H - (lineHeight+1.5)*float64(shiftLines)</span>
        }

        <span class="cov8" title="1">for _, text := range textSplits </span><span class="cov8" title="1">{
                gp.CellWithOption(&amp;Rect{W: rectangle.W, H: startHeight}, string(text), opt)
                gp.Br(lineHeight)
                gp.SetX(x)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SplitText splits text into multiple lines based on width performing potential mid-word breaks.
func (gp *GoPdf) SplitText(text string, width float64) ([]string, error) <span class="cov8" title="1">{
        return gp.SplitTextWithOption(text, width, &amp;DefaultBreakOption)
}</span>

// SplitTextWithWordWrap behaves the same way SplitText does but performs a word-wrap considering spaces in case
// a text line split would split a word.
func (gp *GoPdf) SplitTextWithWordWrap(text string, width float64) ([]string, error) <span class="cov8" title="1">{
        return gp.SplitTextWithOption(text, width, &amp;BreakOption{
                Mode:           BreakModeIndicatorSensitive,
                BreakIndicator: ' ',
        })
}</span>

// SplitTextWithOption splits a text into multiple lines based on the current font size of the document.
// BreakOptions allow to define the behavior of the split (strict or sensitive). For more information see BreakOption.
func (gp *GoPdf) SplitTextWithOption(text string, width float64, opt *BreakOption) ([]string, error) <span class="cov8" title="1">{
        // fallback to default break option
        if opt == nil </span><span class="cov8" title="1">{
                opt = &amp;DefaultBreakOption
        }</span>
        <span class="cov8" title="1">var lineText []rune
        var lineTexts []string
        utf8Texts := []rune(text)
        utf8TextsLen := len(utf8Texts) // utf8 string quantity
        if utf8TextsLen == 0 </span><span class="cov8" title="1">{
                return lineTexts, ErrEmptyString
        }</span>
        <span class="cov8" title="1">separatorWidth, err := gp.MeasureTextWidth(opt.Separator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // possible (not conflicting) position of the separator within the currently processed line
        <span class="cov8" title="1">separatorIdx := 0
        for i := 0; i &lt; utf8TextsLen; i++ </span><span class="cov8" title="1">{
                lineWidth, err := gp.MeasureTextWidth(string(lineText))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">runeWidth, err := gp.MeasureTextWidth(string(utf8Texts[i]))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // mid-word break required since the max width of the given rect is exceeded
                <span class="cov8" title="1">if lineWidth+runeWidth &gt; width &amp;&amp; utf8Texts[i] != '\n' </span><span class="cov8" title="1">{
                        // forceBreak will be set to true in case an indicator sensitive break was not possible which will cause
                        // strict break to not exceed the desired width
                        forceBreak := false
                        if opt.Mode == BreakModeIndicatorSensitive </span><span class="cov8" title="1">{
                                forceBreak = !performIndicatorSensitiveLineBreak(&amp;lineTexts, &amp;lineText, &amp;i, opt)
                        }</span>
                        // BreakModeStrict breaks immediately with an optionally available separator
                        <span class="cov8" title="1">if opt.Mode == BreakModeStrict || forceBreak </span><span class="cov8" title="1">{
                                performStrictLineBreak(&amp;lineTexts, &amp;lineText, &amp;i, separatorIdx, opt)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                // regular break due to a new line rune
                <span class="cov8" title="1">if utf8Texts[i] == '\n' </span><span class="cov8" title="1">{
                        lineTexts = append(lineTexts, string(lineText))
                        lineText = lineText[0:0]
                        continue</span>
                }
                // end of text
                <span class="cov8" title="1">if i == utf8TextsLen-1 </span><span class="cov8" title="1">{
                        lineText = append(lineText, utf8Texts[i])
                        lineTexts = append(lineTexts, string(lineText))
                }</span>
                // store overall index when separator would still fit in the currently processed text-line
                <span class="cov8" title="1">if opt.HasSeparator() &amp;&amp; lineWidth+runeWidth+separatorWidth &lt;= width </span><span class="cov8" title="1">{
                        separatorIdx = i
                }</span>
                <span class="cov8" title="1">lineText = append(lineText, utf8Texts[i])</span>
        }
        <span class="cov8" title="1">return lineTexts, nil</span>
}

// [experimental]
// PlaceHolderText Create a text placehold for fillin text later with function FillInPlaceHoldText.
func (gp *GoPdf) PlaceHolderText(placeHolderName string, placeHolderWidth float64) error <span class="cov8" title="1">{

        //placeHolderText := fmt.Sprintf("{%s}", placeHolderName)
        _, err := gp.curr.FontISubset.AddChars("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gp.PointsToUnitsVar(&amp;placeHolderWidth)
        err = gp.getContent().appendStreamPlaceHolderText(placeHolderWidth)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">content := gp.pdfObjs[gp.indexOfContent].(*ContentObj)
        indexInContent := len(content.listCache.caches) - 1
        indexOfContent := gp.indexOfContent
        fontISubset := gp.curr.FontISubset

        gp.placeHolderTexts[placeHolderName] = append(
                gp.placeHolderTexts[placeHolderName],
                placeHolderTextInfo{
                        indexOfContent:   indexOfContent,
                        indexInContent:   indexInContent,
                        fontISubset:      fontISubset,
                        placeHolderWidth: placeHolderWidth,
                        fontSize:         gp.curr.FontSize,
                        charSpacing:      gp.curr.CharSpacing,
                },
        )

        return nil</span>
}

// [experimental]
// fill in text that created by function PlaceHolderText
// align: Left,Right,Center
func (gp *GoPdf) FillInPlaceHoldText(placeHolderName string, text string, align int) error <span class="cov8" title="1">{

        infos, ok := gp.placeHolderTexts[placeHolderName]
        if !ok </span><span class="cov8" title="1">{
                return errors.New("placeHolderName not found")
        }</span>

        <span class="cov8" title="1">for _, info := range infos </span><span class="cov8" title="1">{
                content, ok := gp.pdfObjs[info.indexOfContent].(*ContentObj)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("gp.pdfObjs is not *ContentObj")
                }</span>
                <span class="cov8" title="1">contentText, ok := content.listCache.caches[info.indexInContent].(*cacheContentText)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("listCache.caches is not *cacheContentText")
                }</span>
                <span class="cov8" title="1">info.fontISubset.AddChars(text)
                contentText.text = text

                //Calculate position
                _, _, textWidthPdfUnit, err := createContent(gp.curr.FontISubset, text, info.fontSize, info.charSpacing, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">width := pointsToUnits(gp.config, textWidthPdfUnit)

                if align == Right </span><span class="cov8" title="1">{
                        diff := info.placeHolderWidth - width
                        contentText.x = contentText.x + diff
                }</span> else<span class="cov8" title="1"> if align == Center </span><span class="cov8" title="1">{
                        diff := info.placeHolderWidth - width
                        contentText.x = contentText.x + diff/2
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func performIndicatorSensitiveLineBreak(lineTexts *[]string, lineText *[]rune, i *int, opt *BreakOption) bool <span class="cov8" title="1">{
        brIdx := breakIndicatorIndex(*lineText, opt.BreakIndicator)
        if brIdx &gt; 0 </span><span class="cov8" title="1">{
                diff := len(*lineText) - brIdx
                *lineText = (*lineText)[0:brIdx]
                *lineTexts = append(*lineTexts, string(*lineText))
                *lineText = (*lineText)[0:0]
                *i -= diff
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func performStrictLineBreak(lineTexts *[]string, lineText *[]rune, i *int, separatorIdx int, opt *BreakOption) <span class="cov8" title="1">{
        if opt.HasSeparator() &amp;&amp; separatorIdx &gt; -1 </span><span class="cov8" title="1">{
                // trim the line to the last possible index with an appended separator
                trimIdx := *i - separatorIdx
                *lineText = (*lineText)[0 : len(*lineText)-trimIdx]
                // append separator to the line
                *lineText = append(*lineText, []rune(opt.Separator)...)
                *lineTexts = append(*lineTexts, string(*lineText))
                *lineText = (*lineText)[0:0]
                *i = separatorIdx - 1
                return
        }</span>
        <span class="cov8" title="1">*lineTexts = append(*lineTexts, string(*lineText))
        *lineText = (*lineText)[0:0]
        *i--</span>
}

// breakIndicatorIndex returns the index where a text line (i.e. rune slice) can be split "gracefully" by checking on
// the break indicator.
// In case no possible break can be identified -1 is returned.
func breakIndicatorIndex(text []rune, bi rune) int <span class="cov8" title="1">{
        for i := len(text) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                if text[i] == bi </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// ImportPage imports a page and return template id.
// gofpdi code
func (gp *GoPdf) ImportPage(sourceFile string, pageno int, box string) int <span class="cov8" title="1">{
        // Set source file for fpdi
        gp.fpdi.SetSourceFile(sourceFile)

        // gofpdi needs to know where to start the object id at.
        // By default, it starts at 1, but gopdf adds a few objects initially.
        startObjID := gp.GetNextObjectID()

        // Set gofpdi next object ID to  whatever the value of startObjID is
        gp.fpdi.SetNextObjectID(startObjID)

        // Import page
        tpl := gp.fpdi.ImportPage(pageno, box)

        // Import objects into current pdf document
        tplObjIDs := gp.fpdi.PutFormXobjects()

        // Set template names and ids in gopdf
        gp.ImportTemplates(tplObjIDs)

        // Get a map[int]string of the imported objects.
        // The map keys will be the ID of each object.
        imported := gp.fpdi.GetImportedObjects()

        // Import gofpdi objects into gopdf, starting at whatever the value of startObjID is
        gp.ImportObjects(imported, startObjID)

        // Return template ID
        return tpl
}</span>

// ImportPageStream imports page using a stream.
// Return template id after importing.
// gofpdi code
func (gp *GoPdf) ImportPageStream(sourceStream *io.ReadSeeker, pageno int, box string) int <span class="cov8" title="1">{
        // Set source file for fpdi
        gp.fpdi.SetSourceStream(sourceStream)

        // gofpdi needs to know where to start the object id at.
        // By default, it starts at 1, but gopdf adds a few objects initially.
        startObjID := gp.GetNextObjectID()

        // Set gofpdi next object ID to  whatever the value of startObjID is
        gp.fpdi.SetNextObjectID(startObjID)

        // Import page
        tpl := gp.fpdi.ImportPage(pageno, box)

        // Import objects into current pdf document
        tplObjIDs := gp.fpdi.PutFormXobjects()

        // Set template names and ids in gopdf
        gp.ImportTemplates(tplObjIDs)

        // Get a map[int]string of the imported objects.
        // The map keys will be the ID of each object.
        imported := gp.fpdi.GetImportedObjects()

        // Import gofpdi objects into gopdf, starting at whatever the value of startObjID is
        gp.ImportObjects(imported, startObjID)

        // Return template ID
        return tpl
}</span>

// GetStreamPageSizes gets the sizes of the pages using a stream
// Returns a map of available pages and its box sizes starting with the first page at index 1 containing a map of boxes containing a map of size values
func (gp *GoPdf) GetStreamPageSizes(sourceStream *io.ReadSeeker) map[int]map[string]map[string]float64 <span class="cov8" title="1">{
        gp.fpdi.SetSourceStream(sourceStream)
        return gp.fpdi.GetPageSizes()
}</span>

// GetPageSizes gets the sizes of the pages of a pdf file1
// Returns a map of available pages and its box sizes starting with the first page at index 1 containing a map of boxes containing a map of size values
func (gp *GoPdf) GetPageSizes(sourceFile string) map[int]map[string]map[string]float64 <span class="cov8" title="1">{
        gp.fpdi.SetSourceFile(sourceFile)
        return gp.fpdi.GetPageSizes()
}</span>

// UseImportedTemplate draws an imported PDF page.
func (gp *GoPdf) UseImportedTemplate(tplid int, x float64, y float64, w float64, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y, &amp;w, &amp;h)
        // Get template values to draw
        tplName, scaleX, scaleY, tX, tY := gp.fpdi.UseTemplate(tplid, x, y, w, h)
        gp.getContent().AppendStreamImportedTemplate(tplName, scaleX, scaleY, tX, tY)
}</span>

// ImportPagesFromSource imports pages from a source pdf.
// The source can be a file path, byte slice, or (*)io.ReadSeeker.
func (gp *GoPdf) ImportPagesFromSource(source interface{}, box string) error <span class="cov8" title="1">{
        switch v := source.(type) </span>{
        case string:<span class="cov8" title="1">
                // Set source file for fpdi
                gp.fpdi.SetSourceFile(v)</span>
        case []byte:<span class="cov8" title="1">
                // Set source stream for fpdi
                rs := io.ReadSeeker(bytes.NewReader(v))
                gp.fpdi.SetSourceStream(&amp;rs)</span>
        case io.ReadSeeker:<span class="cov8" title="1">
                // Set source stream for fpdi
                gp.fpdi.SetSourceStream(&amp;v)</span>
        case *io.ReadSeeker:<span class="cov8" title="1">
                // Set source stream for fpdi
                gp.fpdi.SetSourceStream(v)</span>
        default:<span class="cov8" title="1">
                return errors.New("source type not supported")</span>
        }

        // Get number of pages from source file
        <span class="cov8" title="1">pages := gp.fpdi.GetNumPages()

        // Get page sizes from source file
        sizes := gp.fpdi.GetPageSizes()

        for i := 0; i &lt; pages; i++ </span><span class="cov8" title="1">{
                pageno := i + 1

                // Get the size of the page
                size, ok := sizes[pageno][box]
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("can not get page size")
                }</span>

                // Add a new page to the document
                <span class="cov8" title="1">gp.AddPage()

                // gofpdi needs to know where to start the object id at.
                // By default, it starts at 1, but gopdf adds a few objects initially.
                startObjID := gp.GetNextObjectID()

                // Set gofpdi next object ID to  whatever the value of startObjID is
                gp.fpdi.SetNextObjectID(startObjID)

                // Import page
                tpl := gp.fpdi.ImportPage(pageno, box)

                // Import objects into current pdf document
                tplObjIDs := gp.fpdi.PutFormXobjects()

                // Set template names and ids in gopdf
                gp.ImportTemplates(tplObjIDs)

                // Get a map[int]string of the imported objects.
                // The map keys will be the ID of each object.
                imported := gp.fpdi.GetImportedObjects()

                // Import gofpdi objects into gopdf, starting at whatever the value of startObjID is
                gp.ImportObjects(imported, startObjID)

                // Draws the imported template on the current page
                gp.UseImportedTemplate(tpl, 0, 0, size["w"], size["h"])</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetNextObjectID gets the next object ID so that gofpdi knows where to start the object IDs.
func (gp *GoPdf) GetNextObjectID() int <span class="cov8" title="1">{
        return len(gp.pdfObjs) + 1
}</span>

// GetNumberOfPages gets the number of pages from the PDF.
func (gp *GoPdf) GetNumberOfPages() int <span class="cov8" title="1">{
        return gp.numOfPagesObj
}</span>

// ImportObjects imports objects from gofpdi into current document.
func (gp *GoPdf) ImportObjects(objs map[int]string, startObjID int) <span class="cov8" title="1">{
        for i := startObjID; i &lt; len(objs)+startObjID; i++ </span><span class="cov8" title="1">{
                if objs[i] != "" </span><span class="cov8" title="1">{
                        gp.addObj(&amp;ImportedObj{Data: objs[i]})
                }</span>
        }
}

// ImportTemplates names into procset dictionary.
func (gp *GoPdf) ImportTemplates(tpls map[string]int) <span class="cov8" title="1">{
        procset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)
        for tplName, tplID := range tpls </span><span class="cov8" title="1">{
                procset.ImportedTemplateIds[tplName] = tplID
        }</span>
}

// AddExternalLink adds a new external link.
func (gp *GoPdf) AddExternalLink(url string, x, y, w, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y, &amp;w, &amp;h)

        linkOpt := linkOption{x, gp.config.PageSize.H - y, w, h, url, ""}
        gp.addLink(linkOpt)
}</span>

// AddInternalLink adds a new internal link.
func (gp *GoPdf) AddInternalLink(anchor string, x, y, w, h float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y, &amp;w, &amp;h)

        linkOpt := linkOption{x, gp.config.PageSize.H - y, w, h, "", anchor}
        gp.addLink(linkOpt)
}</span>

func (gp *GoPdf) addLink(option linkOption) <span class="cov8" title="1">{
        page := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)
        linkObj := gp.addObj(annotObj{option, func() *GoPdf </span><span class="cov8" title="1">{
                return gp
        }</span>})
        <span class="cov8" title="1">page.LinkObjIds = append(page.LinkObjIds, linkObj+1)</span>
}

// SetAnchor creates a new anchor.
func (gp *GoPdf) SetAnchor(name string) <span class="cov8" title="1">{
        y := gp.config.PageSize.H - gp.curr.Y + float64(gp.curr.FontSize)
        gp.anchors[name] = anchorOption{gp.curr.IndexOfPageObj, y}
}</span>

// AddTTFFontByReader adds font data by reader.
func (gp *GoPdf) AddTTFFontData(family string, fontData []byte) error <span class="cov8" title="1">{
        return gp.AddTTFFontDataWithOption(family, fontData, defaultTtfFontOption())
}</span>

// AddTTFFontDataWithOption adds font data with option.
func (gp *GoPdf) AddTTFFontDataWithOption(family string, fontData []byte, option TtfOption) error <span class="cov8" title="1">{
        subsetFont := new(SubsetFontObj)
        subsetFont.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">subsetFont.SetTtfFontOption(option)
        subsetFont.SetFamily(family)
        err := subsetFont.SetTTFData(fontData)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gp.setSubsetFontObject(subsetFont, family, option)</span>
}

// AddTTFFontByReader adds font file by reader.
func (gp *GoPdf) AddTTFFontByReader(family string, rd io.Reader) error <span class="cov8" title="1">{
        return gp.AddTTFFontByReaderWithOption(family, rd, defaultTtfFontOption())
}</span>

// AddTTFFontByReaderWithOption adds font file by reader with option.
func (gp *GoPdf) AddTTFFontByReaderWithOption(family string, rd io.Reader, option TtfOption) error <span class="cov8" title="1">{
        subsetFont := new(SubsetFontObj)
        subsetFont.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">subsetFont.SetTtfFontOption(option)
        subsetFont.SetFamily(family)
        err := subsetFont.SetTTFByReader(rd)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gp.setSubsetFontObject(subsetFont, family, option)</span>
}

// setSubsetFontObject sets SubsetFontObj.
// The given SubsetFontObj is expected to be configured in advance.
func (gp *GoPdf) setSubsetFontObject(subsetFont *SubsetFontObj, family string, option TtfOption) error <span class="cov8" title="1">{
        unicodemap := new(UnicodeMap)
        unicodemap.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">unicodemap.setProtection(gp.protection())
        unicodemap.SetPtrToSubsetFontObj(subsetFont)
        unicodeindex := gp.addObj(unicodemap)

        pdfdic := new(PdfDictionaryObj)
        pdfdic.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">pdfdic.setProtection(gp.protection())
        pdfdic.SetPtrToSubsetFontObj(subsetFont)
        pdfdicindex := gp.addObj(pdfdic)

        subfontdesc := new(SubfontDescriptorObj)
        subfontdesc.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">subfontdesc.SetPtrToSubsetFontObj(subsetFont)
        subfontdesc.SetIndexObjPdfDictionary(pdfdicindex)
        subfontdescindex := gp.addObj(subfontdesc)

        cidfont := new(CIDFontObj)
        cidfont.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)
        <span class="cov8" title="1">cidfont.SetPtrToSubsetFontObj(subsetFont)
        cidfont.SetIndexObjSubfontDescriptor(subfontdescindex)
        cidindex := gp.addObj(cidfont)

        subsetFont.SetIndexObjCIDFont(cidindex)
        subsetFont.SetIndexObjUnicodeMap(unicodeindex)
        index := gp.addObj(subsetFont) //add à¸«à¸¥à¸±à¸‡à¸ªà¸¸à¸”

        if gp.indexOfProcSet != -1 </span><span class="cov8" title="1">{
                procset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)
                if !procset.Relates.IsContainsFamilyAndStyle(family, option.Style&amp;^Underline) </span><span class="cov8" title="1">{
                        procset.Relates = append(procset.Relates, RelateFont{Family: family, IndexOfObj: index, CountOfFont: gp.curr.CountOfFont, Style: option.Style &amp;^ Underline})
                        subsetFont.CountOfFont = gp.curr.CountOfFont
                        gp.curr.CountOfFont++
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddTTFFontWithOption : add font file
func (gp *GoPdf) AddTTFFontWithOption(family string, ttfpath string, option TtfOption) error <span class="cov8" title="1">{

        if _, err := os.Stat(ttfpath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">data, err := os.ReadFile(ttfpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rd := bytes.NewReader(data)
        return gp.AddTTFFontByReaderWithOption(family, rd, option)</span>
}

// AddTTFFont : add font file
func (gp *GoPdf) AddTTFFont(family string, ttfpath string) error <span class="cov8" title="1">{
        return gp.AddTTFFontWithOption(family, ttfpath, defaultTtfFontOption())
}</span>

// KernOverride override kern value
func (gp *GoPdf) KernOverride(family string, fn FuncKernOverride) error <span class="cov8" title="1">{
        i := 0
        max := len(gp.pdfObjs)
        for i &lt; max </span><span class="cov8" title="1">{
                if gp.pdfObjs[i].getType() == subsetFont </span><span class="cov8" title="1">{
                        obj := gp.pdfObjs[i]
                        sub, ok := obj.(*SubsetFontObj)
                        if ok </span><span class="cov8" title="1">{
                                if sub.GetFamily() == family </span><span class="cov8" title="1">{
                                        sub.funcKernOverride = fn
                                        return nil
                                }</span>
                        }
                }
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return ErrMissingFontFamily</span>
}

// SetTextColor :  function sets the text color
func (gp *GoPdf) SetTextColor(r uint8, g uint8, b uint8) <span class="cov8" title="1">{
        gp.curr.txtColorMode = "color"
        rgb := cacheContentTextColorRGB{
                r: r,
                g: g,
                b: b,
        }
        gp.curr.setTextColor(rgb)
}</span>

func (gp *GoPdf) SetTextColorCMYK(c, m, y, k uint8) <span class="cov8" title="1">{
        gp.curr.txtColorMode = "color"
        cmyk := cacheContentTextColorCMYK{
                c: c,
                m: m,
                y: y,
                k: k,
        }
        gp.curr.setTextColor(cmyk)
}</span>

// SetStrokeColor set the color for the stroke
func (gp *GoPdf) SetStrokeColor(r uint8, g uint8, b uint8) <span class="cov8" title="1">{
        gp.getContent().AppendStreamSetColorStroke(r, g, b)
}</span>

// SetFillColor set the color for the stroke
func (gp *GoPdf) SetFillColor(r uint8, g uint8, b uint8) <span class="cov8" title="1">{
        gp.getContent().AppendStreamSetColorFill(r, g, b)
}</span>

// SetStrokeColorCMYK set the color for the stroke in CMYK color mode
func (gp *GoPdf) SetStrokeColorCMYK(c, m, y, k uint8) <span class="cov8" title="1">{
        gp.getContent().AppendStreamSetColorStrokeCMYK(c, m, y, k)
}</span>

// SetFillColorCMYK set the color for the fill in CMYK color mode
func (gp *GoPdf) SetFillColorCMYK(c, m, y, k uint8) <span class="cov8" title="1">{
        gp.getContent().AppendStreamSetColorFillCMYK(c, m, y, k)
}</span>

// MeasureTextWidth : measure Width of text (use current font)
func (gp *GoPdf) MeasureTextWidth(text string) (float64, error) <span class="cov8" title="1">{

        text, err := gp.curr.FontISubset.AddChars(text) //AddChars for create CharacterToGlyphIndex
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">_, _, textWidthPdfUnit, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return pointsToUnits(gp.config, textWidthPdfUnit), nil</span>
}

// MeasureCellHeightByText : measure Height of cell by text (use current font)
func (gp *GoPdf) MeasureCellHeightByText(text string) (float64, error) <span class="cov8" title="1">{

        text, err := gp.curr.FontISubset.AddChars(text) //AddChars for create CharacterToGlyphIndex
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">_, cellHeightPdfUnit, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return pointsToUnits(gp.config, cellHeightPdfUnit), nil</span>
}

// Curve Draws a BÃ©zier curve (the BÃ©zier curve is tangent to the line between the control points at either end of the curve)
// Parameters:
// - x0, y0: Start point
// - x1, y1: Control point 1
// - x2, y2: Control point 2
// - x3, y3: End point
// - style: Style of rectangule (draw and/or fill: D, F, DF, FD)
func (gp *GoPdf) Curve(x0 float64, y0 float64, x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64, style string) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3)
        gp.getContent().AppendStreamCurve(x0, y0, x1, y1, x2, y2, x3, y3, style)
}</span>

/*
//SetProtection set permissions as well as user and owner passwords
func (gp *GoPdf) SetProtection(permissions int, userPass []byte, ownerPass []byte) {
        gp.pdfProtection = new(PDFProtection)
        gp.pdfProtection.setProtection(permissions, userPass, ownerPass)
}*/

// SetInfo set Document Information Dictionary
func (gp *GoPdf) SetInfo(info PdfInfo) <span class="cov8" title="1">{
        gp.info = &amp;info
        gp.isUseInfo = true
}</span>

// GetInfo get Document Information Dictionary
func (gp *GoPdf) GetInfo() PdfInfo <span class="cov8" title="1">{
        return *gp.info
}</span>

// Rotate rotate text or image
// angle is angle in degrees.
// x, y is rotation center
func (gp *GoPdf) Rotate(angle, x, y float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;x, &amp;y)
        gp.getContent().appendRotate(angle, x, y)
}</span>

// RotateReset reset rotate
func (gp *GoPdf) RotateReset() <span class="cov8" title="1">{
        gp.getContent().appendRotateReset()
}</span>

// Polygon : draw polygon
//   - style: Style of polygon (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw. This is the default value.
//     F: fill
//     DF or FD: draw and fill
//
// Usage:
//
//         pdf.SetStrokeColor(255, 0, 0)
//                pdf.SetLineWidth(2)
//                pdf.SetFillColor(0, 255, 0)
//                pdf.Polygon([]gopdf.Point{{X: 10, Y: 30}, {X: 585, Y: 200}, {X: 585, Y: 250}}, "DF")
func (gp *GoPdf) Polygon(points []Point, style string) <span class="cov8" title="1">{

        transparency, err := gp.getCachedTransparency(nil)
        if err != nil </span><span class="cov0" title="0">{
                transparency = nil
        }</span>

        <span class="cov8" title="1">var opts = polygonOptions{}
        if transparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">var pointReals []Point
        for _, p := range points </span><span class="cov8" title="1">{
                x := p.X
                y := p.Y
                gp.UnitsToPointsVar(&amp;x, &amp;y)
                pointReals = append(pointReals, Point{X: x, Y: y})
        }</span>
        <span class="cov8" title="1">gp.getContent().AppendStreamPolygon(pointReals, style, opts)</span>
}

// Polyline draws an open polyline (connected line segments, not closed).
// Unlike Polygon, the path is not closed â€” only stroked.
//
// Usage:
//
//        pdf.SetStrokeColor(255, 0, 0)
//        pdf.SetLineWidth(2)
//        pdf.Polyline([]gopdf.Point{{X: 10, Y: 30}, {X: 100, Y: 200}, {X: 200, Y: 50}})
func (gp *GoPdf) Polyline(points []Point) <span class="cov8" title="1">{
        transparency, err := gp.getCachedTransparency(nil)
        if err != nil </span><span class="cov0" title="0">{
                transparency = nil
        }</span>

        <span class="cov8" title="1">var opts = polylineOptions{}
        if transparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">var pointReals []Point
        for _, p := range points </span><span class="cov8" title="1">{
                x := p.X
                y := p.Y
                gp.UnitsToPointsVar(&amp;x, &amp;y)
                pointReals = append(pointReals, Point{X: x, Y: y})
        }</span>
        <span class="cov8" title="1">gp.getContent().AppendStreamPolyline(pointReals, opts)</span>
}

// Sector draws a sector (pie/fan shape) defined by a center point, radius,
// and start/end angles in degrees (counter-clockwise from the positive X axis).
//   - cx, cy: center point
//   - r: radius
//   - startDeg: start angle in degrees
//   - endDeg: end angle in degrees
//   - style: Style of sector (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw (stroke). This is the default value.
//     F: fill
//     DF or FD: draw and fill
//
// Usage:
//
//        pdf.SetStrokeColor(0, 0, 0)
//        pdf.SetFillColor(255, 0, 0)
//        pdf.Sector(200, 300, 80, 0, 90, "FD")
func (gp *GoPdf) Sector(cx, cy, r, startDeg, endDeg float64, style string) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;cx, &amp;cy, &amp;r)

        transparency, err := gp.getCachedTransparency(nil)
        if err != nil </span><span class="cov0" title="0">{
                transparency = nil
        }</span>

        <span class="cov8" title="1">var opts = sectorOptions{}
        if transparency != nil </span><span class="cov8" title="1">{
                opts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)
        }</span>

        <span class="cov8" title="1">style = strings.ToUpper(strings.TrimSpace(style))
        gp.getContent().AppendStreamSector(cx, cy, r, startDeg, endDeg, style, opts)</span>
}

// ClipPolygon sets a clipping path from polygon points.
func (gp *GoPdf) ClipPolygon(points []Point) <span class="cov8" title="1">{
        var pointReals []Point
        for _, p := range points </span><span class="cov8" title="1">{
                x := p.X
                y := p.Y
                gp.UnitsToPointsVar(&amp;x, &amp;y)
                pointReals = append(pointReals, Point{X: x, Y: y})
        }</span>
        <span class="cov8" title="1">gp.getContent().AppendStreamClipPolygon(pointReals)</span>
}

// SaveGraphicsState saves the current graphics state.
// Use with RestoreGraphicsState to scope clipping paths and transformations.
func (gp *GoPdf) SaveGraphicsState() <span class="cov8" title="1">{
        gp.getContent().AppendStreamSaveGraphicsState()
}</span>

// RestoreGraphicsState restores a previously saved graphics state.
// Clipping paths and transformations are reset to the saved state.
func (gp *GoPdf) RestoreGraphicsState() <span class="cov8" title="1">{
        gp.getContent().AppendStreamRestoreGraphicsState()
}</span>

// Rectangle : draw rectangle, and add radius input to make a round corner, it helps to calculate the round corner coordinates and use Polygon functions to draw rectangle
//   - style: Style of Rectangle (draw and/or fill: D, F, DF, FD)
//     D or empty string: draw. This is the default value.
//     F: fill
//     DF or FD: draw and fill
//
// Usage:
//
//         pdf.SetStrokeColor(255, 0, 0)
//                pdf.SetLineWidth(2)
//                pdf.SetFillColor(0, 255, 0)
//                pdf.Rectangle(196.6, 336.8, 398.3, 379.3, "DF", 3, 10)
func (gp *GoPdf) Rectangle(x0 float64, y0 float64, x1 float64, y1 float64, style string, radius float64, radiusPointNum int) error <span class="cov8" title="1">{
        if x1 &lt;= x0 || y1 &lt;= y0 </span><span class="cov8" title="1">{
                return ErrInvalidRectangleCoordinates
        }</span>
        <span class="cov8" title="1">if radiusPointNum &lt;= 0 || radius &lt;= 0 </span><span class="cov8" title="1">{
                //draw rectangle without round corner
                points := []Point{}
                points = append(points, Point{X: x0, Y: y0})
                points = append(points, Point{X: x1, Y: y0})
                points = append(points, Point{X: x1, Y: y1})
                points = append(points, Point{X: x0, Y: y1})
                gp.Polygon(points, style)

        }</span> else<span class="cov8" title="1"> {

                if radius &gt; (x1-x0) || radius &gt; (y1-y0) </span><span class="cov8" title="1">{
                        return ErrInvalidRectangleCoordinates
                }</span>

                <span class="cov8" title="1">degrees := []float64{}
                angle := float64(90) / float64(radiusPointNum+1)
                accAngle := angle
                for accAngle &lt; float64(90) </span><span class="cov8" title="1">{
                        degrees = append(degrees, accAngle)
                        accAngle += angle
                }</span>

                <span class="cov8" title="1">radians := []float64{}
                for _, v := range degrees </span><span class="cov8" title="1">{
                        radians = append(radians, v*math.Pi/180)
                }</span>

                <span class="cov8" title="1">points := []Point{}
                points = append(points, Point{X: x0, Y: (y0 + radius)})
                for _, v := range radians </span><span class="cov8" title="1">{
                        offsetX := radius * math.Cos(v)
                        offsetY := radius * math.Sin(v)
                        x := x0 + radius - offsetX
                        y := y0 + radius - offsetY
                        points = append(points, Point{X: x, Y: y})
                }</span>
                <span class="cov8" title="1">points = append(points, Point{X: (x0 + radius), Y: y0})

                points = append(points, Point{X: (x1 - radius), Y: y0})
                for i := range radians </span><span class="cov8" title="1">{
                        v := radians[len(radians)-1-i]
                        offsetX := radius * math.Cos(v)
                        offsetY := radius * math.Sin(v)
                        x := x1 - radius + offsetX
                        y := y0 + radius - offsetY
                        points = append(points, Point{X: x, Y: y})
                }</span>
                <span class="cov8" title="1">points = append(points, Point{X: x1, Y: (y0 + radius)})

                points = append(points, Point{X: x1, Y: (y1 - radius)})
                for _, v := range radians </span><span class="cov8" title="1">{
                        offsetX := radius * math.Cos(v)
                        offsetY := radius * math.Sin(v)
                        x := x1 - radius + offsetX
                        y := y1 - radius + offsetY
                        points = append(points, Point{X: x, Y: y})
                }</span>
                <span class="cov8" title="1">points = append(points, Point{X: (x1 - radius), Y: y1})

                points = append(points, Point{X: (x0 + radius), Y: y1})
                for i := range radians </span><span class="cov8" title="1">{
                        v := radians[len(radians)-1-i]
                        offsetX := radius * math.Cos(v)
                        offsetY := radius * math.Sin(v)
                        x := x0 + radius - offsetX
                        y := y1 - radius + offsetY
                        points = append(points, Point{X: x, Y: y})
                }</span>
                <span class="cov8" title="1">points = append(points, Point{X: x0, Y: y1 - radius})

                gp.Polygon(points, style)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*---private---*/

// init
func (gp *GoPdf) init(importer ...*gofpdi.Importer) <span class="cov8" title="1">{
        gp.pdfObjs = []IObj{}
        gp.buf = bytes.Buffer{}
        gp.indexEncodingObjFonts = []int{}
        gp.pdfProtection = nil
        gp.encryptionObjID = 0
        gp.isUseInfo = false
        gp.info = nil

        //default
        gp.margins = Margins{
                Left:   defaultMargin,
                Top:    defaultMargin,
                Right:  defaultMargin,
                Bottom: defaultMargin,
        }

        //init curr
        gp.resetCurrXY()
        gp.curr = Current{}
        gp.curr.IndexOfPageObj = -1
        gp.curr.CountOfFont = 0
        gp.curr.CountOfL = 0
        gp.curr.CountOfImg = 0                       //img
        gp.curr.ImgCaches = make(map[int]ImageCache) //= *new([]ImageCache)
        gp.curr.sMasksMap = NewSMaskMap()
        gp.curr.extGStatesMap = NewExtGStatesMap()
        gp.curr.transparencyMap = NewTransparencyMap()
        gp.anchors = make(map[string]anchorOption)
        gp.curr.txtColorMode = "gray"

        //init index
        gp.indexOfPagesObj = -1
        gp.indexOfFirstPageObj = -1
        gp.indexOfContent = -1

        //No underline
        //gp.IsUnderline = false
        gp.curr.lineWidth = 1

        // default to zlib.DefaultCompression
        gp.compressLevel = zlib.DefaultCompression

        // change the unit type
        gp.config.PageSize = *gp.config.PageSize.unitsToPoints(gp.config)
        gp.config.TrimBox = *gp.config.TrimBox.unitsToPoints(gp.config)

        // init gofpdi free pdf document importer
        gp.fpdi = importerOrDefault(importer...)

}</span>

func importerOrDefault(importer ...*gofpdi.Importer) *gofpdi.Importer <span class="cov8" title="1">{
        if len(importer) != 0 </span><span class="cov8" title="1">{
                return importer[len(importer)-1]
        }</span>
        <span class="cov8" title="1">return gofpdi.NewImporter()</span>
}

func (gp *GoPdf) resetCurrXY() <span class="cov8" title="1">{
        gp.curr.X = gp.margins.Left
        gp.curr.Y = gp.margins.Top
}</span>

// UnitsToPoints converts the units to the documents unit type
func (gp *GoPdf) UnitsToPoints(u float64) float64 <span class="cov8" title="1">{
        return unitsToPoints(gp.config, u)
}</span>

// UnitsToPointsVar converts the units to the documents unit type for all variables passed in
func (gp *GoPdf) UnitsToPointsVar(u ...*float64) <span class="cov8" title="1">{
        unitsToPointsVar(gp.config, u...)
}</span>

// PointsToUnits converts the points to the documents unit type
func (gp *GoPdf) PointsToUnits(u float64) float64 <span class="cov8" title="1">{
        return pointsToUnits(gp.config, u)
}</span>

// PointsToUnitsVar converts the points to the documents unit type for all variables passed in
func (gp *GoPdf) PointsToUnitsVar(u ...*float64) <span class="cov8" title="1">{
        pointsToUnitsVar(gp.config, u...)
}</span>

func (gp *GoPdf) isUseProtection() bool <span class="cov8" title="1">{
        return gp.config.Protection.UseProtection
}</span>

func (gp *GoPdf) createProtection() *PDFProtection <span class="cov8" title="1">{
        var prot PDFProtection
        prot.setProtection(
                gp.config.Protection.Permissions,
                gp.config.Protection.UserPass,
                gp.config.Protection.OwnerPass,
        )
        return &amp;prot
}</span>

func (gp *GoPdf) protection() *PDFProtection <span class="cov8" title="1">{
        return gp.pdfProtection
}</span>

func (gp *GoPdf) prepare() <span class="cov8" title="1">{

        if gp.isUseProtection() </span><span class="cov8" title="1">{
                encObj := gp.pdfProtection.encryptionObj()
                gp.addObj(encObj)
        }</span>

        <span class="cov8" title="1">if gp.outlines.Count() &gt; 0 </span><span class="cov8" title="1">{
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjOutlines(gp.indexOfOutlinesObj)
        }</span>

        // Add Names dictionary for embedded files.
        <span class="cov8" title="1">if len(gp.embeddedFiles) &gt; 0 </span><span class="cov8" title="1">{
                namesIdx := gp.addObj(namesObj{
                        embeddedFiles: gp.embeddedFiles,
                })
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjNames(namesIdx)
        }</span>

        // Add PageLabels number tree.
        <span class="cov8" title="1">if len(gp.pageLabels) &gt; 0 </span><span class="cov8" title="1">{
                plIdx := gp.addObj(pageLabelObj{labels: gp.pageLabels})
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjPageLabels(plIdx)
        }</span>

        // Add XMP Metadata stream.
        <span class="cov8" title="1">if gp.xmpMetadata != nil </span><span class="cov8" title="1">{
                metaIdx := gp.addObj(xmpMetadataObj{meta: gp.xmpMetadata})
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjMetadata(metaIdx)
        }</span>

        // Add OCProperties for Optional Content Groups.
        <span class="cov8" title="1">if len(gp.ocgs) &gt; 0 </span><span class="cov8" title="1">{
                ocpIdx := gp.addObj(ocPropertiesObj{
                        ocgs:         gp.ocgs,
                        layerConfigs: gp.layerConfigs,
                        uiConfig:     gp.layerUIConfig,
                })
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjOCProperties(ocpIdx)
        }</span>

        // Add MarkInfo dictionary.
        <span class="cov8" title="1">if gp.markInfo != nil </span><span class="cov8" title="1">{
                miIdx := gp.addObj(markInfoObj{info: *gp.markInfo})
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjMarkInfo(miIdx)
        }</span>

        // Add AcroForm for interactive form fields.
        <span class="cov8" title="1">if len(gp.formFields) &gt; 0 </span><span class="cov8" title="1">{
                af := acroFormObj{needAppearances: true}
                // Collect field object IDs and font references
                fontSeen := make(map[string]bool)
                for _, ref := range gp.formFields </span><span class="cov8" title="1">{
                        af.fieldObjIDs = append(af.fieldObjIDs, ref.objIdx+1)
                        // Resolve font for DA/DR
                        if fObj, ok := gp.pdfObjs[ref.objIdx].(formFieldObj); ok &amp;&amp; fObj.fontRef != "" &amp;&amp; !fontSeen[fObj.fontRef] </span><span class="cov8" title="1">{
                                fontSeen[fObj.fontRef] = true
                                af.fontRefs = append(af.fontRefs, acroFormFont{
                                        name:  fObj.fontRef[1:], // strip leading /
                                        objID: fObj.fontObjID,
                                })
                        }</span>
                }
                <span class="cov8" title="1">afIdx := gp.addObj(af)
                catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
                catalogObj.SetIndexObjAcroForm(afIdx)</span>
        }

        <span class="cov8" title="1">if gp.indexOfPagesObj != -1 </span><span class="cov8" title="1">{
                indexCurrPage := -1
                pagesObj := gp.pdfObjs[gp.indexOfPagesObj].(*PagesObj)
                i := 0 //gp.indexOfFirstPageObj
                max := len(gp.pdfObjs)
                for i &lt; max </span><span class="cov8" title="1">{
                        objtype := gp.pdfObjs[i].getType()
                        switch objtype </span>{
                        case "Page":<span class="cov8" title="1">
                                pagesObj.Kids = fmt.Sprintf("%s %d 0 R ", pagesObj.Kids, i+1)
                                pagesObj.PageCount++
                                indexCurrPage = i</span>
                        case "Content":<span class="cov8" title="1">
                                if indexCurrPage != -1 </span><span class="cov8" title="1">{
                                        gp.pdfObjs[indexCurrPage].(*PageObj).Contents = fmt.Sprintf("%s %d 0 R ", gp.pdfObjs[indexCurrPage].(*PageObj).Contents, i+1)
                                }</span>
                        case "Font":<span class="cov0" title="0">
                                tmpfont := gp.pdfObjs[i].(*FontObj)
                                j := 0
                                jmax := len(gp.indexEncodingObjFonts)
                                for j &lt; jmax </span><span class="cov0" title="0">{
                                        tmpencoding := gp.pdfObjs[gp.indexEncodingObjFonts[j]].(*EncodingObj).GetFont()
                                        if tmpfont.Family == tmpencoding.GetFamily() </span><span class="cov0" title="0">{ //à¹ƒà¸ªà¹ˆ à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡ embed font
                                                tmpfont.IsEmbedFont = true
                                                tmpfont.SetIndexObjEncoding(gp.indexEncodingObjFonts[j] + 1)
                                                tmpfont.SetIndexObjWidth(gp.indexEncodingObjFonts[j] + 2)
                                                tmpfont.SetIndexObjFontDescriptor(gp.indexEncodingObjFonts[j] + 3)
                                                break</span>
                                        }
                                        <span class="cov0" title="0">j++</span>
                                }
                        case "Encryption":<span class="cov8" title="1">
                                gp.encryptionObjID = i + 1</span>
                        }
                        <span class="cov8" title="1">i++</span>
                }
        }
}

func (gp *GoPdf) xref(w io.Writer, xrefbyteoffset int64, linelens []int64, i int) error <span class="cov8" title="1">{

        io.WriteString(w, "xref\n")
        fmt.Fprintf(w, "0 %d\n", i+1)
        io.WriteString(w, "0000000000 65535 f \n")
        j := 0
        max := len(linelens)
        for j &lt; max </span><span class="cov8" title="1">{
                linelen := linelens[j]
                fmt.Fprintf(w, "%s 00000 n \n", gp.formatXrefline(linelen))
                j++
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "trailer\n")
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/Size %d\n", max+1)
        io.WriteString(w, "/Root 1 0 R\n")
        if gp.isUseProtection() </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Encrypt %d 0 R\n", gp.encryptionObjID)
                io.WriteString(w, "/ID [()()]\n")
        }</span>
        <span class="cov8" title="1">if gp.isUseInfo </span><span class="cov8" title="1">{
                gp.writeInfo(w)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "startxref\n")
        fmt.Fprintf(w, "%d", xrefbyteoffset)
        io.WriteString(w, "\n%%EOF\n")

        return nil</span>
}

func (gp *GoPdf) writeInfo(w io.Writer) <span class="cov8" title="1">{
        var zerotime time.Time
        io.WriteString(w, "/Info &lt;&lt;\n")

        if gp.info.Author != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Author &lt;FEFF%s&gt;\n", encodeUtf8(gp.info.Author))
        }</span>

        <span class="cov8" title="1">if gp.info.Title != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Title &lt;FEFF%s&gt;\n", encodeUtf8(gp.info.Title))
        }</span>

        <span class="cov8" title="1">if gp.info.Subject != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Subject &lt;FEFF%s&gt;\n", encodeUtf8(gp.info.Subject))
        }</span>

        <span class="cov8" title="1">if gp.info.Creator != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Creator &lt;FEFF%s&gt;\n", encodeUtf8(gp.info.Creator))
        }</span>

        <span class="cov8" title="1">if gp.info.Producer != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/Producer &lt;FEFF%s&gt;\n", encodeUtf8(gp.info.Producer))
        }</span>

        <span class="cov8" title="1">if !zerotime.Equal(gp.info.CreationDate) </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "/CreationDate(D:%s)\n", infodate(gp.info.CreationDate))
        }</span>

        <span class="cov8" title="1">io.WriteString(w, " &gt;&gt;\n")</span>
}

// à¸›à¸£à¸±à¸š xref à¹ƒà¸«à¹‰à¹€à¸›à¹‡à¸™ 10 à¸«à¸¥à¸±à¸
func (gp *GoPdf) formatXrefline(n int64) string <span class="cov8" title="1">{
        str := strconv.FormatInt(n, 10)
        for len(str) &lt; 10 </span><span class="cov8" title="1">{
                str = "0" + str
        }</span>
        <span class="cov8" title="1">return str</span>
}

func (gp *GoPdf) addObj(iobj IObj) int <span class="cov8" title="1">{
        index := len(gp.pdfObjs)
        gp.pdfObjs = append(gp.pdfObjs, iobj)
        return index
}</span>

func (gp *GoPdf) getContent() *ContentObj <span class="cov8" title="1">{
        var content *ContentObj
        if gp.indexOfContent &lt;= -1 </span><span class="cov8" title="1">{
                content = new(ContentObj)
                content.init(func() *GoPdf </span><span class="cov8" title="1">{
                        return gp
                }</span>)
                <span class="cov8" title="1">gp.indexOfContent = gp.addObj(content)</span>
        } else<span class="cov8" title="1"> {
                content = gp.pdfObjs[gp.indexOfContent].(*ContentObj)
        }</span>
        <span class="cov8" title="1">return content</span>
}

func encodeUtf8(str string) string <span class="cov8" title="1">{
        var buff bytes.Buffer
        for _, r := range str </span><span class="cov8" title="1">{
                c := fmt.Sprintf("%X", r)
                for len(c) &lt; 4 </span><span class="cov8" title="1">{
                        c = "0" + c
                }</span>
                <span class="cov8" title="1">buff.WriteString(c)</span>
        }
        <span class="cov8" title="1">return buff.String()</span>
}

func infodate(t time.Time) string <span class="cov8" title="1">{
        ft := t.Format("20060102150405-07'00'")
        return ft
}</span>

// SetTransparency sets transparency.
// alpha:                 value from 0 (transparent) to 1 (opaque)
// blendMode:   blend mode, one of the following:
//
//        Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn,
//        HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity
func (gp *GoPdf) SetTransparency(transparency Transparency) error <span class="cov8" title="1">{
        t, err := gp.saveTransparency(&amp;transparency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gp.curr.transparency = t

        return nil</span>
}

func (gp *GoPdf) ClearTransparency() <span class="cov8" title="1">{
        gp.curr.transparency = nil
}</span>

func (gp *GoPdf) getCachedTransparency(transparency *Transparency) (*Transparency, error) <span class="cov8" title="1">{
        if transparency == nil </span><span class="cov8" title="1">{
                transparency = gp.curr.transparency
        }</span> else<span class="cov8" title="1"> {
                cached, err := gp.saveTransparency(transparency)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">transparency = cached</span>
        }

        <span class="cov8" title="1">return transparency, nil</span>
}

func (gp *GoPdf) saveTransparency(transparency *Transparency) (*Transparency, error) <span class="cov8" title="1">{
        cached, ok := gp.curr.transparencyMap.Find(*transparency)
        if ok </span><span class="cov8" title="1">{
                return &amp;cached, nil
        }</span> else<span class="cov8" title="1"> if transparency.Alpha != DefaultAplhaValue </span><span class="cov8" title="1">{
                bm := transparency.BlendModeType
                opts := ExtGStateOptions{
                        BlendMode:     &amp;bm,
                        StrokingCA:    &amp;transparency.Alpha,
                        NonStrokingCa: &amp;transparency.Alpha,
                }

                extGState, err := GetCachedExtGState(opts, gp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">transparency.extGStateIndex = extGState.Index + 1

                gp.curr.transparencyMap.Save(*transparency)

                return transparency, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// IsCurrFontContainGlyph defines is current font contains to a glyph
// r:           any rune
func (gp *GoPdf) IsCurrFontContainGlyph(r rune) (bool, error) <span class="cov8" title="1">{
        fontISubset := gp.curr.FontISubset
        if fontISubset == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">glyphIndex, err := fontISubset.CharCodeToGlyphIndex(r)
        if err == ErrGlyphNotFound </span><span class="cov8" title="1">{
                return false, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if glyphIndex == 0 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// SetPage set current page
func (gp *GoPdf) SetPage(pageno int) error <span class="cov8" title="1">{
        var pageIndex int
        for i := 0; i &lt; len(gp.pdfObjs); i++ </span><span class="cov8" title="1">{
                switch gp.pdfObjs[i].(type) </span>{
                case *ContentObj:<span class="cov8" title="1">
                        pageIndex += 1
                        if pageIndex == pageno </span><span class="cov8" title="1">{
                                gp.indexOfContent = i
                                return nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors.New("invalid page number")</span>
}

func (gp *GoPdf) SetColorSpace(name string) error <span class="cov8" title="1">{
        found := false
        i := 0
        max := len(gp.pdfObjs)
        for i &lt; max </span><span class="cov8" title="1">{
                if gp.pdfObjs[i].getType() == colorSpace </span><span class="cov8" title="1">{
                        obj := gp.pdfObjs[i]
                        sub, ok := obj.(*ColorSpaceObj)
                        if ok </span><span class="cov8" title="1">{
                                if sub.Name == name </span><span class="cov8" title="1">{
                                        gp.curr.IndexOfColorSpaceObj = i
                                        gp.getContent().appendColorSpace(sub.CountOfSpaceColor)
                                        found = true
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return ErrMissingColorSpace
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (gp *GoPdf) AddColorSpaceRGB(name string, r, g, b uint8) error <span class="cov8" title="1">{
        colorSpace := ColorSpaceObj{}
        colorSpace.Name = name

        colorSpace.SetColorRBG(r, g, b)

        return gp.addColorSpace(&amp;colorSpace)
}</span>

func (gp *GoPdf) AddColorSpaceCMYK(name string, c, m, y, k uint8) error <span class="cov8" title="1">{
        colorSpace := ColorSpaceObj{}
        colorSpace.Name = name

        colorSpace.SetColorCMYK(c, m, y, k)

        return gp.addColorSpace(&amp;colorSpace)
}</span>

func (gp *GoPdf) addColorSpace(colorSpace *ColorSpaceObj) error <span class="cov8" title="1">{
        index := gp.addObj(colorSpace)

        if gp.indexOfProcSet != -1 </span><span class="cov8" title="1">{
                procset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)

                for _, relate := range procset.RelateColorSpaces </span><span class="cov8" title="1">{
                        if relate.Name == colorSpace.Name </span><span class="cov0" title="0">{
                                return ErrExistsColorSpace
                        }</span>
                }

                <span class="cov8" title="1">procset.RelateColorSpaces = append(procset.RelateColorSpaces, RelateColorSpace{Name: colorSpace.Name, IndexOfObj: index, CountOfColorSpace: gp.curr.CountOfColorSpace})
                colorSpace.CountOfSpaceColor = gp.curr.CountOfColorSpace
                gp.curr.CountOfColorSpace++</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//tool for validate pdf https://www.pdf-online.com/osa/validate.aspx
</pre>
		
		<pre class="file" id="file64" style="display: none">package gopdf

import (
        "strconv"
        "strings"
)

// HTMLBoxOption configures the behavior of InsertHTMLBox.
type HTMLBoxOption struct {
        // DefaultFontFamily is the font family used when no font is specified in HTML.
        // This font must already be added to the GoPdf instance via AddTTFFont.
        DefaultFontFamily string

        // DefaultFontSize is the default font size in points.
        DefaultFontSize float64

        // DefaultColor is the default text color (r, g, b).
        DefaultColor [3]uint8

        // LineSpacing is extra spacing between lines (in document units). Default is 0.
        LineSpacing float64

        // BoldFontFamily is the font family to use for bold text.
        // If empty, the default family is used (bold may not render if the font doesn't support it).
        BoldFontFamily string

        // ItalicFontFamily is the font family to use for italic text.
        ItalicFontFamily string

        // BoldItalicFontFamily is the font family to use for bold+italic text.
        BoldItalicFontFamily string
}

// htmlRenderState tracks the current rendering state while walking the HTML tree.
type htmlRenderState struct {
        fontFamily string
        fontSize   float64
        fontStyle  int // Regular, Bold, Italic, Underline
        colorR     uint8
        colorG     uint8
        colorB     uint8
        align      int
}

// htmlRenderer handles the rendering of HTML nodes into the PDF.
type htmlRenderer struct {
        gp      *GoPdf
        opt     HTMLBoxOption
        boxX    float64 // box left edge (units)
        boxY    float64 // box top edge (units)
        boxW    float64 // box width (units)
        boxH    float64 // box height (units)
        cursorX float64 // current X position (units)
        cursorY float64 // current Y position (units)
}

// InsertHTMLBox renders simplified HTML content into a rectangular area on the PDF.
//
// Supported HTML tags:
//   - &lt;b&gt;, &lt;strong&gt;: Bold text
//   - &lt;i&gt;, &lt;em&gt;: Italic text
//   - &lt;u&gt;: Underlined text
//   - &lt;s&gt;, &lt;strike&gt;, &lt;del&gt;: Strikethrough (rendered as underline for simplicity)
//   - &lt;br&gt;, &lt;br/&gt;: Line break
//   - &lt;p&gt;: Paragraph (adds vertical spacing)
//   - &lt;h1&gt; to &lt;h6&gt;: Headings with automatic font sizing
//   - &lt;font color="..." size="..." face="..."&gt;: Font styling
//   - &lt;span style="..."&gt;: Inline styling (color, font-size, font-family)
//   - &lt;img src="..." width="..." height="..."&gt;: Images (src must be a local file path)
//   - &lt;hr&gt;: Horizontal rule
//   - &lt;center&gt;: Centered text
//   - &lt;ul&gt;, &lt;ol&gt;, &lt;li&gt;: Lists (basic bullet/number)
//   - &lt;a href="..."&gt;: Links (rendered as colored text, link annotation added)
//   - &lt;sub&gt;, &lt;sup&gt;: Subscript/superscript (approximated with smaller font)
//
// Parameters:
//   - x, y: Top-left corner of the box (in document units)
//   - w, h: Width and height of the box (in document units)
//   - htmlStr: The HTML string to render
//   - opt: Rendering options (font families, default size, colors, etc.)
//
// Returns the Y position after the last rendered content (in document units).
func (gp *GoPdf) InsertHTMLBox(x, y, w, h float64, htmlStr string, opt HTMLBoxOption) (float64, error) <span class="cov8" title="1">{
        if opt.DefaultFontSize &lt;= 0 </span><span class="cov8" title="1">{
                opt.DefaultFontSize = 12
        }</span>
        <span class="cov8" title="1">if opt.DefaultFontFamily == "" </span><span class="cov8" title="1">{
                return y, ErrMissingFontFamily
        }</span>

        <span class="cov8" title="1">nodes := parseHTML(htmlStr)

        r := &amp;htmlRenderer{
                gp:      gp,
                opt:     opt,
                boxX:    x,
                boxY:    y,
                boxW:    w,
                boxH:    h,
                cursorX: x,
                cursorY: y,
        }

        state := htmlRenderState{
                fontFamily: opt.DefaultFontFamily,
                fontSize:   opt.DefaultFontSize,
                fontStyle:  Regular,
                colorR:     opt.DefaultColor[0],
                colorG:     opt.DefaultColor[1],
                colorB:     opt.DefaultColor[2],
                align:      Left,
        }

        if err := r.renderNodes(nodes, state); err != nil </span><span class="cov8" title="1">{
                return r.cursorY, err
        }</span>

        <span class="cov8" title="1">return r.cursorY, nil</span>
}

func (r *htmlRenderer) renderNodes(nodes []*htmlNode, state htmlRenderState) error <span class="cov8" title="1">{
        for _, node := range nodes </span><span class="cov8" title="1">{
                if r.cursorY-r.boxY &gt;= r.boxH </span><span class="cov8" title="1">{
                        break</span> // exceeded box height
                }
                <span class="cov8" title="1">if err := r.renderNode(node, state); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *htmlRenderer) renderNode(node *htmlNode, state htmlRenderState) error <span class="cov8" title="1">{
        if node.Type == htmlNodeText </span><span class="cov8" title="1">{
                return r.renderText(node.Text, state)
        }</span>

        // element node
        <span class="cov8" title="1">newState := state

        switch node.Tag </span>{
        case "b", "strong":<span class="cov8" title="1">
                newState.fontStyle |= Bold</span>
        case "i", "em":<span class="cov8" title="1">
                newState.fontStyle |= Italic</span>
        case "u", "ins":<span class="cov8" title="1">
                newState.fontStyle |= Underline</span>
        case "s", "strike", "del":<span class="cov8" title="1">
                // approximate strikethrough with underline
                newState.fontStyle |= Underline</span>
        case "br":<span class="cov8" title="1">
                r.newLine(state)
                return nil</span>
        case "hr":<span class="cov8" title="1">
                return r.renderHR(state)</span>
        case "p", "div":<span class="cov8" title="1">
                newState = r.applyStyleAttr(node, newState)
                if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.3)
                if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.3)
                return nil</span>
        case "h1", "h2", "h3", "h4", "h5", "h6":<span class="cov8" title="1">
                newState.fontSize = headingFontSize(node.Tag)
                newState.fontStyle |= Bold
                newState = r.applyStyleAttr(node, newState)
                if r.cursorX &gt; r.boxX </span><span class="cov0" title="0">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">r.addVerticalSpace(newState.fontSize * 0.4)
                if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(newState)
                }</span>
                <span class="cov8" title="1">r.addVerticalSpace(newState.fontSize * 0.3)
                return nil</span>
        case "font":<span class="cov8" title="1">
                if color, ok := node.Attrs["color"]; ok </span><span class="cov8" title="1">{
                        if cr, cg, cb, cok := parseCSSColor(color); cok </span><span class="cov8" title="1">{
                                newState.colorR, newState.colorG, newState.colorB = cr, cg, cb
                        }</span>
                }
                <span class="cov8" title="1">if size, ok := node.Attrs["size"]; ok </span><span class="cov8" title="1">{
                        if sz, sok := parseFontSizeAttr(size); sok </span><span class="cov8" title="1">{
                                newState.fontSize = sz
                        }</span>
                }
                <span class="cov8" title="1">if face, ok := node.Attrs["face"]; ok </span><span class="cov8" title="1">{
                        newState.fontFamily = face
                }</span>
        case "span":<span class="cov8" title="1">
                newState = r.applyStyleAttr(node, newState)</span>
        case "center":<span class="cov8" title="1">
                newState.align = Center
                if r.cursorX &gt; r.boxX </span><span class="cov0" title="0">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(newState)
                }</span>
                <span class="cov8" title="1">return nil</span>
        case "a":<span class="cov8" title="1">
                // render link text in blue with underline, then add PDF link annotation
                newState.colorR, newState.colorG, newState.colorB = 0, 0, 255
                newState.fontStyle |= Underline
                href := node.Attrs["href"]

                // record position before rendering link text
                startX := r.cursorX
                startY := r.cursorY
                lh := r.lineHeight(newState)

                if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // add clickable link annotation if href is present
                <span class="cov8" title="1">if href != "" </span><span class="cov8" title="1">{
                        endX := r.cursorX
                        // convert to points for the annotation
                        ax := r.gp.UnitsToPoints(startX)
                        ay := r.gp.UnitsToPoints(startY)
                        aw := r.gp.UnitsToPoints(endX - startX)
                        ah := r.gp.UnitsToPoints(lh)
                        if aw &gt; 0 </span><span class="cov8" title="1">{
                                r.gp.AddExternalLink(href, ax, ay, aw, ah)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        case "img":<span class="cov8" title="1">
                return r.renderImage(node, state)</span>
        case "ul", "ol":<span class="cov8" title="1">
                return r.renderList(node, state, node.Tag == "ol")</span>
        case "li":<span class="cov0" title="0"></span>
                // handled by renderList
        case "sub":<span class="cov8" title="1">
                newState.fontSize = state.fontSize * 0.7</span>
        case "sup":<span class="cov8" title="1">
                newState.fontSize = state.fontSize * 0.7</span>
        case "blockquote":<span class="cov8" title="1">
                newState = r.applyStyleAttr(node, newState)
                if r.cursorX &gt; r.boxX </span><span class="cov0" title="0">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">oldBoxX := r.boxX
                oldBoxW := r.boxW
                indent := state.fontSize * 1.5
                r.boxX += indent
                r.boxW -= indent
                r.cursorX = r.boxX
                r.addVerticalSpace(state.fontSize * 0.3)
                if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(newState)
                }</span>
                <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.3)
                r.boxX = oldBoxX
                r.boxW = oldBoxW
                r.cursorX = r.boxX
                return nil</span>
        }

        // render children with updated state
        <span class="cov8" title="1">if err := r.renderNodes(node.Children, newState); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *htmlRenderer) applyStyleAttr(node *htmlNode, state htmlRenderState) htmlRenderState <span class="cov8" title="1">{
        styleStr, ok := node.Attrs["style"]
        if !ok </span><span class="cov8" title="1">{
                return state
        }</span>
        <span class="cov8" title="1">styles := parseInlineStyle(styleStr)

        if color, ok := styles["color"]; ok </span><span class="cov8" title="1">{
                if cr, cg, cb, cok := parseCSSColor(color); cok </span><span class="cov8" title="1">{
                        state.colorR, state.colorG, state.colorB = cr, cg, cb
                }</span>
        }
        <span class="cov8" title="1">if fs, ok := styles["font-size"]; ok </span><span class="cov8" title="1">{
                if sz, sok := parseFontSize(fs, state.fontSize); sok </span><span class="cov8" title="1">{
                        state.fontSize = sz
                }</span>
        }
        <span class="cov8" title="1">if ff, ok := styles["font-family"]; ok </span><span class="cov8" title="1">{
                state.fontFamily = strings.Trim(ff, "'\"")
        }</span>
        <span class="cov8" title="1">if fw, ok := styles["font-weight"]; ok </span><span class="cov8" title="1">{
                if fw == "bold" || fw == "700" || fw == "800" || fw == "900" </span><span class="cov8" title="1">{
                        state.fontStyle |= Bold
                }</span>
        }
        <span class="cov8" title="1">if fst, ok := styles["font-style"]; ok </span><span class="cov8" title="1">{
                if fst == "italic" </span><span class="cov8" title="1">{
                        state.fontStyle |= Italic
                }</span>
        }
        <span class="cov8" title="1">if td, ok := styles["text-decoration"]; ok </span><span class="cov8" title="1">{
                if strings.Contains(td, "underline") </span><span class="cov8" title="1">{
                        state.fontStyle |= Underline
                }</span>
        }
        <span class="cov8" title="1">if ta, ok := styles["text-align"]; ok </span><span class="cov8" title="1">{
                switch ta </span>{
                case "center":<span class="cov8" title="1">
                        state.align = Center</span>
                case "right":<span class="cov8" title="1">
                        state.align = Right</span>
                case "left":<span class="cov8" title="1">
                        state.align = Left</span>
                }
        }
        <span class="cov8" title="1">return state</span>
}

func (r *htmlRenderer) applyFont(state htmlRenderState) error <span class="cov8" title="1">{
        family := r.resolveFontFamily(state)
        style := state.fontStyle &amp;^ Underline // strip underline for font lookup
        if err := r.gp.SetFontWithStyle(family, style, state.fontSize); err != nil </span><span class="cov8" title="1">{
                // fallback to default family
                if err2 := r.gp.SetFontWithStyle(r.opt.DefaultFontFamily, Regular, state.fontSize); err2 != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">r.gp.SetTextColor(state.colorR, state.colorG, state.colorB)
        return nil</span>
}

func (r *htmlRenderer) resolveFontFamily(state htmlRenderState) string <span class="cov8" title="1">{
        isBold := state.fontStyle&amp;Bold == Bold
        isItalic := state.fontStyle&amp;Italic == Italic

        if isBold &amp;&amp; isItalic &amp;&amp; r.opt.BoldItalicFontFamily != "" </span><span class="cov8" title="1">{
                return r.opt.BoldItalicFontFamily
        }</span>
        <span class="cov8" title="1">if isBold &amp;&amp; r.opt.BoldFontFamily != "" </span><span class="cov8" title="1">{
                return r.opt.BoldFontFamily
        }</span>
        <span class="cov8" title="1">if isItalic &amp;&amp; r.opt.ItalicFontFamily != "" </span><span class="cov8" title="1">{
                return r.opt.ItalicFontFamily
        }</span>
        <span class="cov8" title="1">if state.fontFamily != "" </span><span class="cov8" title="1">{
                return state.fontFamily
        }</span>
        <span class="cov0" title="0">return r.opt.DefaultFontFamily</span>
}

func (r *htmlRenderer) lineHeight(state htmlRenderState) float64 <span class="cov8" title="1">{
        return state.fontSize * 1.2 / r.unitConversion() + r.opt.LineSpacing
}</span>

func (r *htmlRenderer) unitConversion() float64 <span class="cov8" title="1">{
        // points per unit
        switch r.gp.config.Unit </span>{
        case UnitMM:<span class="cov8" title="1">
                return conversionUnitMM</span>
        case UnitCM:<span class="cov8" title="1">
                return conversionUnitCM</span>
        case UnitIN:<span class="cov8" title="1">
                return conversionUnitIN</span>
        case UnitPX:<span class="cov8" title="1">
                return conversionUnitPX</span>
        default:<span class="cov8" title="1">
                return 1.0</span>
        }
}

func (r *htmlRenderer) newLine(state htmlRenderState) <span class="cov8" title="1">{
        r.cursorX = r.boxX
        r.cursorY += r.lineHeight(state)
}</span>

func (r *htmlRenderer) addVerticalSpace(ptSpace float64) <span class="cov8" title="1">{
        r.cursorY += ptSpace / r.unitConversion()
}</span>

func (r *htmlRenderer) remainingWidth() float64 <span class="cov0" title="0">{
        return r.boxX + r.boxW - r.cursorX
}</span>

func (r *htmlRenderer) renderText(text string, state htmlRenderState) error <span class="cov8" title="1">{
        if err := r.applyFont(state); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // collapse whitespace
        <span class="cov8" title="1">text = collapseWhitespace(text)
        if text == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">words := splitWords(text)
        lh := r.lineHeight(state)
        spaceWidth, err := r.gp.MeasureTextWidth(" ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i, word := range words </span><span class="cov8" title="1">{
                if r.cursorY-r.boxY+lh &gt; r.boxH </span><span class="cov8" title="1">{
                        break</span> // exceeded box height
                }

                <span class="cov8" title="1">wordWidth, err := r.gp.MeasureTextWidth(word)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // check if word fits on current line
                <span class="cov8" title="1">if r.cursorX &gt; r.boxX &amp;&amp; r.cursorX+wordWidth &gt; r.boxX+r.boxW </span><span class="cov8" title="1">{
                        r.newLine(state)
                }</span>

                // if a single word is wider than the box, force-render it
                <span class="cov8" title="1">if wordWidth &gt; r.boxW </span><span class="cov8" title="1">{
                        // render character by character with wrapping
                        if err := r.renderLongWord(word, state); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // handle alignment for new lines
                <span class="cov8" title="1">if r.cursorX == r.boxX &amp;&amp; state.align == Center </span><span class="cov8" title="1">{
                        lineWidth := r.measureLineWidth(words[i:], spaceWidth, state)
                        if lineWidth &lt; r.boxW </span><span class="cov8" title="1">{
                                r.cursorX = r.boxX + (r.boxW-lineWidth)/2
                        }</span>
                } else<span class="cov8" title="1"> if r.cursorX == r.boxX &amp;&amp; state.align == Right </span><span class="cov8" title="1">{
                        lineWidth := r.measureLineWidth(words[i:], spaceWidth, state)
                        if lineWidth &lt; r.boxW </span><span class="cov8" title="1">{
                                r.cursorX = r.boxX + r.boxW - lineWidth
                        }</span>
                }

                <span class="cov8" title="1">r.gp.SetXY(r.cursorX, r.cursorY)

                cellOpt := CellOption{
                        Align: Left | Top,
                }

                rect := &amp;Rect{W: wordWidth, H: lh}
                if err := r.gp.CellWithOption(rect, word, cellOpt); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">r.cursorX += wordWidth

                // add space after word (except last)
                if i &lt; len(words)-1 </span><span class="cov8" title="1">{
                        r.cursorX += spaceWidth
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *htmlRenderer) renderLongWord(word string, state htmlRenderState) error <span class="cov8" title="1">{
        lh := r.lineHeight(state)
        for _, ch := range word </span><span class="cov8" title="1">{
                s := string(ch)
                chWidth, err := r.gp.MeasureTextWidth(s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if r.cursorX+chWidth &gt; r.boxX+r.boxW &amp;&amp; r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(state)
                }</span>
                <span class="cov8" title="1">r.gp.SetXY(r.cursorX, r.cursorY)
                rect := &amp;Rect{W: chWidth, H: lh}
                if err := r.gp.CellWithOption(rect, s, CellOption{Align: Left | Top}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">r.cursorX += chWidth</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *htmlRenderer) measureLineWidth(words []string, spaceWidth float64, state htmlRenderState) float64 <span class="cov8" title="1">{
        total := 0.0
        for i, word := range words </span><span class="cov8" title="1">{
                ww, err := r.gp.MeasureTextWidth(word)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if total+ww &gt; r.boxW </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">total += ww
                if i &lt; len(words)-1 </span><span class="cov8" title="1">{
                        total += spaceWidth
                }</span>
        }
        <span class="cov8" title="1">return total</span>
}

func (r *htmlRenderer) renderHR(state htmlRenderState) error <span class="cov8" title="1">{
        if r.cursorX &gt; r.boxX </span><span class="cov0" title="0">{
                r.newLine(state)
        }</span>
        <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.3)

        y := r.cursorY + r.lineHeight(state)*0.5
        r.gp.SetStrokeColor(128, 128, 128)
        r.gp.SetLineWidth(0.5)
        r.gp.Line(r.boxX, y, r.boxX+r.boxW, y)

        r.cursorY = y + r.lineHeight(state)*0.5
        r.cursorX = r.boxX
        r.addVerticalSpace(state.fontSize * 0.3)
        return nil</span>
}

func (r *htmlRenderer) renderImage(node *htmlNode, state htmlRenderState) error <span class="cov8" title="1">{
        src, ok := node.Attrs["src"]
        if !ok || src == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // parse dimensions
        <span class="cov8" title="1">imgW := 0.0
        imgH := 0.0
        if w, ok := node.Attrs["width"]; ok </span><span class="cov8" title="1">{
                if v, vok := parseDimension(w, r.boxW); vok </span><span class="cov8" title="1">{
                        imgW = v / r.unitConversion()
                }</span>
        }
        <span class="cov8" title="1">if h, ok := node.Attrs["height"]; ok </span><span class="cov8" title="1">{
                if v, vok := parseDimension(h, r.boxH); vok </span><span class="cov8" title="1">{
                        imgH = v / r.unitConversion()
                }</span>
        }

        // default size if not specified
        <span class="cov8" title="1">if imgW == 0 &amp;&amp; imgH == 0 </span><span class="cov8" title="1">{
                imgW = r.boxW * 0.5
                imgH = imgW * 0.75
        }</span> else<span class="cov8" title="1"> if imgW == 0 </span><span class="cov8" title="1">{
                imgW = imgH * 1.33
        }</span> else<span class="cov8" title="1"> if imgH == 0 </span><span class="cov8" title="1">{
                imgH = imgW * 0.75
        }</span>

        // clamp to box width
        <span class="cov8" title="1">if imgW &gt; r.boxW </span><span class="cov8" title="1">{
                ratio := r.boxW / imgW
                imgW = r.boxW
                imgH *= ratio
        }</span>

        // check if image fits on current line, if not, new line
        <span class="cov8" title="1">if r.cursorX &gt; r.boxX &amp;&amp; r.cursorX+imgW &gt; r.boxX+r.boxW </span><span class="cov0" title="0">{
                r.newLine(state)
        }</span>

        // check if image fits vertically
        <span class="cov8" title="1">if r.cursorY-r.boxY+imgH &gt; r.boxH </span><span class="cov8" title="1">{
                return nil // skip image if it doesn't fit
        }</span>

        <span class="cov8" title="1">imgHolder, err := ImageHolderByPath(src)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">rect := &amp;Rect{W: imgW, H: imgH}
        if err := r.gp.ImageByHolder(imgHolder, r.cursorX, r.cursorY, rect); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.cursorY += imgH
        r.cursorX = r.boxX
        return nil</span>
}

func (r *htmlRenderer) renderList(node *htmlNode, state htmlRenderState, ordered bool) error <span class="cov8" title="1">{
        if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                r.newLine(state)
        }</span>
        <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.2)

        indent := state.fontSize * 1.2 / r.unitConversion()
        counter := 0

        for _, child := range node.Children </span><span class="cov8" title="1">{
                if child.Type != htmlNodeElement || child.Tag != "li" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">counter++

                if r.cursorY-r.boxY+r.lineHeight(state) &gt; r.boxH </span><span class="cov8" title="1">{
                        break</span>
                }

                // render bullet or number
                <span class="cov8" title="1">if err := r.applyFont(state); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">r.cursorX = r.boxX + indent*0.5
                r.gp.SetXY(r.cursorX, r.cursorY)

                var marker string
                if ordered </span><span class="cov8" title="1">{
                        marker = string(rune('0'+counter)) + ". "
                        if counter &gt; 9 </span><span class="cov8" title="1">{
                                marker = strconv.Itoa(counter) + ". "
                        }</span>
                } else<span class="cov8" title="1"> {
                        marker = "â€¢ "
                }</span>

                <span class="cov8" title="1">markerWidth, _ := r.gp.MeasureTextWidth(marker)
                rect := &amp;Rect{W: markerWidth, H: r.lineHeight(state)}
                if err := r.gp.CellWithOption(rect, marker, CellOption{Align: Left | Top}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // render list item content with indent
                <span class="cov8" title="1">oldBoxX := r.boxX
                oldBoxW := r.boxW
                r.boxX += indent
                r.boxW -= indent
                r.cursorX = r.boxX

                childState := r.applyStyleAttr(child, state)
                if err := r.renderNodes(child.Children, childState); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if r.cursorX &gt; r.boxX </span><span class="cov8" title="1">{
                        r.newLine(state)
                }</span>

                <span class="cov8" title="1">r.boxX = oldBoxX
                r.boxW = oldBoxW
                r.cursorX = r.boxX</span>
        }

        <span class="cov8" title="1">r.addVerticalSpace(state.fontSize * 0.2)
        return nil</span>
}

// collapseWhitespace collapses consecutive whitespace characters into a single space.
func collapseWhitespace(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        inSpace := false
        for _, ch := range s </span><span class="cov8" title="1">{
                if ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' </span><span class="cov8" title="1">{
                        if !inSpace </span><span class="cov8" title="1">{
                                result.WriteByte(' ')
                                inSpace = true
                        }</span>
                } else<span class="cov8" title="1"> {
                        result.WriteRune(ch)
                        inSpace = false
                }</span>
        }
        <span class="cov8" title="1">return strings.TrimSpace(result.String())</span>
}

// splitWords splits text into words by spaces.
func splitWords(text string) []string <span class="cov8" title="1">{
        return strings.Fields(text)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package gopdf

import (
        "fmt"
        "strconv"
        "strings"
)

// htmlNodeType represents the type of an HTML node.
type htmlNodeType int

const (
        htmlNodeText    htmlNodeType = iota // plain text
        htmlNodeElement                     // an HTML element like &lt;b&gt;, &lt;p&gt;, etc.
)

// htmlNode represents a parsed HTML node (either text or element).
type htmlNode struct {
        Type       htmlNodeType
        Tag        string // lowercase tag name, e.g. "b", "p", "br", "img"
        Text       string // text content (for text nodes)
        Attrs      map[string]string
        Children   []*htmlNode
        SelfClose  bool // e.g. &lt;br/&gt;, &lt;img ... /&gt;
}

// parseHTML parses a simplified HTML string into a tree of htmlNode.
// Supported tags: b, i, u, s, br, p, span, font, img, h1-h6, ul, ol, li, a, hr, sub, sup, center
func parseHTML(html string) []*htmlNode <span class="cov8" title="1">{
        p := &amp;htmlParser{input: html}
        return p.parseNodes()
}</span>

type htmlParser struct {
        input string
        pos   int
}

func (p *htmlParser) parseNodes() []*htmlNode <span class="cov8" title="1">{
        var nodes []*htmlNode
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                if p.input[p.pos] == '&lt;' </span><span class="cov8" title="1">{
                        // check for closing tag
                        if p.pos+1 &lt; len(p.input) &amp;&amp; p.input[p.pos+1] == '/' </span><span class="cov8" title="1">{
                                // closing tag â€” return to parent
                                return nodes
                        }</span>
                        // check for comment &lt;!-- ... --&gt;
                        <span class="cov8" title="1">if p.pos+3 &lt; len(p.input) &amp;&amp; p.input[p.pos:p.pos+4] == "&lt;!--" </span><span class="cov8" title="1">{
                                p.skipComment()
                                continue</span>
                        }
                        <span class="cov8" title="1">node := p.parseElement()
                        if node != nil </span><span class="cov8" title="1">{
                                nodes = append(nodes, node)
                        }</span>
                } else<span class="cov8" title="1"> {
                        node := p.parseText()
                        if node != nil </span><span class="cov8" title="1">{
                                nodes = append(nodes, node)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nodes</span>
}

func (p *htmlParser) skipComment() <span class="cov8" title="1">{
        p.pos += 4 // skip "&lt;!--"
        for p.pos &lt; len(p.input)-2 </span><span class="cov8" title="1">{
                if p.input[p.pos:p.pos+3] == "--&gt;" </span><span class="cov8" title="1">{
                        p.pos += 3
                        return
                }</span>
                <span class="cov8" title="1">p.pos++</span>
        }
        <span class="cov8" title="1">p.pos = len(p.input)</span>
}

func (p *htmlParser) parseText() *htmlNode <span class="cov8" title="1">{
        start := p.pos
        for p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] != '&lt;' </span><span class="cov8" title="1">{
                p.pos++
        }</span>
        <span class="cov8" title="1">text := p.input[start:p.pos]
        text = decodeHTMLEntities(text)
        if len(text) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;htmlNode{Type: htmlNodeText, Text: text}</span>
}

func (p *htmlParser) parseElement() *htmlNode <span class="cov8" title="1">{
        if p.pos &gt;= len(p.input) || p.input[p.pos] != '&lt;' </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">p.pos++ // skip '&lt;'
        p.skipWhitespace()

        tag := p.readTagName()
        if tag == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">attrs := p.parseAttributes()
        p.skipWhitespace()

        selfClose := false
        if p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] == '/' </span><span class="cov8" title="1">{
                selfClose = true
                p.pos++
        }</span>
        <span class="cov8" title="1">if p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] == '&gt;' </span><span class="cov8" title="1">{
                p.pos++
        }</span>

        <span class="cov8" title="1">node := &amp;htmlNode{
                Type:      htmlNodeElement,
                Tag:       strings.ToLower(tag),
                Attrs:     attrs,
                SelfClose: selfClose,
        }

        // self-closing or void elements
        if selfClose || isVoidElement(node.Tag) </span><span class="cov8" title="1">{
                return node
        }</span>

        // parse children until closing tag
        <span class="cov8" title="1">node.Children = p.parseNodes()

        // consume closing tag &lt;/tag&gt;
        p.consumeClosingTag(node.Tag)

        return node</span>
}

func (p *htmlParser) readTagName() string <span class="cov8" title="1">{
        start := p.pos
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if ch == ' ' || ch == '&gt;' || ch == '/' || ch == '\t' || ch == '\n' || ch == '\r' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">p.pos++</span>
        }
        <span class="cov8" title="1">return p.input[start:p.pos]</span>
}

func (p *htmlParser) parseAttributes() map[string]string <span class="cov8" title="1">{
        attrs := make(map[string]string)
        for </span><span class="cov8" title="1">{
                p.skipWhitespace()
                if p.pos &gt;= len(p.input) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">ch := p.input[p.pos]
                if ch == '&gt;' || ch == '/' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">key := p.readAttrName()
                if key == "" </span><span class="cov0" title="0">{
                        p.pos++
                        continue</span>
                }
                <span class="cov8" title="1">p.skipWhitespace()
                value := ""
                if p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] == '=' </span><span class="cov8" title="1">{
                        p.pos++ // skip '='
                        p.skipWhitespace()
                        value = p.readAttrValue()
                }</span>
                <span class="cov8" title="1">attrs[strings.ToLower(key)] = value</span>
        }
        <span class="cov8" title="1">return attrs</span>
}

func (p *htmlParser) readAttrName() string <span class="cov8" title="1">{
        start := p.pos
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if ch == '=' || ch == ' ' || ch == '&gt;' || ch == '/' || ch == '\t' || ch == '\n' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">p.pos++</span>
        }
        <span class="cov8" title="1">return p.input[start:p.pos]</span>
}

func (p *htmlParser) readAttrValue() string <span class="cov8" title="1">{
        if p.pos &gt;= len(p.input) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">ch := p.input[p.pos]
        if ch == '"' || ch == '\'' </span><span class="cov8" title="1">{
                quote := ch
                p.pos++
                start := p.pos
                for p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] != quote </span><span class="cov8" title="1">{
                        p.pos++
                }</span>
                <span class="cov8" title="1">val := p.input[start:p.pos]
                if p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                        p.pos++ // skip closing quote
                }</span>
                <span class="cov8" title="1">return decodeHTMLEntities(val)</span>
        }
        // unquoted value
        <span class="cov8" title="1">start := p.pos
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if ch == ' ' || ch == '&gt;' || ch == '/' || ch == '\t' || ch == '\n' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">p.pos++</span>
        }
        <span class="cov8" title="1">return decodeHTMLEntities(p.input[start:p.pos])</span>
}

func (p *htmlParser) consumeClosingTag(tag string) <span class="cov8" title="1">{
        // look for &lt;/tag&gt;
        if p.pos+1 &lt; len(p.input) &amp;&amp; p.input[p.pos] == '&lt;' &amp;&amp; p.input[p.pos+1] == '/' </span><span class="cov8" title="1">{
                p.pos += 2
                p.skipWhitespace()
                p.readTagName() // consume tag name
                p.skipWhitespace()
                if p.pos &lt; len(p.input) &amp;&amp; p.input[p.pos] == '&gt;' </span><span class="cov8" title="1">{
                        p.pos++
                }</span>
        }
}

func (p *htmlParser) skipWhitespace() <span class="cov8" title="1">{
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if ch != ' ' &amp;&amp; ch != '\t' &amp;&amp; ch != '\n' &amp;&amp; ch != '\r' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">p.pos++</span>
        }
}

func isVoidElement(tag string) bool <span class="cov8" title="1">{
        switch tag </span>{
        case "br", "hr", "img":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func decodeHTMLEntities(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "&amp;amp;", "&amp;")
        s = strings.ReplaceAll(s, "&amp;lt;", "&lt;")
        s = strings.ReplaceAll(s, "&amp;gt;", "&gt;")
        s = strings.ReplaceAll(s, "&amp;quot;", "\"")
        s = strings.ReplaceAll(s, "&amp;apos;", "'")
        s = strings.ReplaceAll(s, "&amp;nbsp;", " ")
        return s
}</span>

// parseInlineStyle parses a CSS-like inline style string into a map.
// e.g. "color: red; font-size: 14px" =&gt; {"color":"red", "font-size":"14px"}
func parseInlineStyle(style string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        parts := strings.Split(style, ";")
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">idx := strings.Index(part, ":")
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">key := strings.TrimSpace(part[:idx])
                val := strings.TrimSpace(part[idx+1:])
                result[strings.ToLower(key)] = val</span>
        }
        <span class="cov8" title="1">return result</span>
}

// parseCSSColor parses a color string and returns r, g, b values.
// Supports: #RGB, #RRGGBB, rgb(r,g,b), and named colors.
func parseCSSColor(color string) (uint8, uint8, uint8, bool) <span class="cov8" title="1">{
        color = strings.TrimSpace(strings.ToLower(color))

        // named colors
        if rgb, ok := cssNamedColors[color]; ok </span><span class="cov8" title="1">{
                return rgb[0], rgb[1], rgb[2], true
        }</span>

        // hex colors
        <span class="cov8" title="1">if strings.HasPrefix(color, "#") </span><span class="cov8" title="1">{
                hex := color[1:]
                if len(hex) == 3 </span><span class="cov8" title="1">{
                        hex = string([]byte{hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]})
                }</span>
                <span class="cov8" title="1">if len(hex) == 6 </span><span class="cov8" title="1">{
                        r, err1 := strconv.ParseUint(hex[0:2], 16, 8)
                        g, err2 := strconv.ParseUint(hex[2:4], 16, 8)
                        b, err3 := strconv.ParseUint(hex[4:6], 16, 8)
                        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; err3 == nil </span><span class="cov8" title="1">{
                                return uint8(r), uint8(g), uint8(b), true
                        }</span>
                }
                <span class="cov8" title="1">return 0, 0, 0, false</span>
        }

        // rgb(r, g, b)
        <span class="cov8" title="1">if strings.HasPrefix(color, "rgb(") &amp;&amp; strings.HasSuffix(color, ")") </span><span class="cov8" title="1">{
                inner := color[4 : len(color)-1]
                parts := strings.Split(inner, ",")
                if len(parts) == 3 </span><span class="cov8" title="1">{
                        r, err1 := strconv.Atoi(strings.TrimSpace(parts[0]))
                        g, err2 := strconv.Atoi(strings.TrimSpace(parts[1]))
                        b, err3 := strconv.Atoi(strings.TrimSpace(parts[2]))
                        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; err3 == nil </span><span class="cov8" title="1">{
                                return uint8(r), uint8(g), uint8(b), true
                        }</span>
                }
        }

        <span class="cov8" title="1">return 0, 0, 0, false</span>
}

// parseFontSize parses a CSS font-size value and returns the size in points.
// Supports: "12pt", "16px", "1.5em", plain numbers, and named sizes.
func parseFontSize(val string, currentSize float64) (float64, bool) <span class="cov8" title="1">{
        val = strings.TrimSpace(strings.ToLower(val))

        // named sizes
        switch val </span>{
        case "xx-small":<span class="cov8" title="1">
                return 6, true</span>
        case "x-small":<span class="cov8" title="1">
                return 7.5, true</span>
        case "small":<span class="cov8" title="1">
                return 10, true</span>
        case "medium":<span class="cov8" title="1">
                return 12, true</span>
        case "large":<span class="cov8" title="1">
                return 14, true</span>
        case "x-large":<span class="cov8" title="1">
                return 18, true</span>
        case "xx-large":<span class="cov8" title="1">
                return 24, true</span>
        }

        <span class="cov8" title="1">if strings.HasSuffix(val, "pt") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "pt"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return f, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "px") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "px"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return f * 0.75, true // px to pt
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "em") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "em"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return currentSize * f, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "%") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "%"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return currentSize * f / 100.0, true
                }</span>
        }

        // plain number (treat as pt)
        <span class="cov8" title="1">f, err := strconv.ParseFloat(val, 64)
        if err == nil </span><span class="cov8" title="1">{
                return f, true
        }</span>

        <span class="cov8" title="1">return 0, false</span>
}

// parseDimension parses a CSS dimension value (e.g. "100px", "50%", "3em") and returns points.
func parseDimension(val string, relativeTo float64) (float64, bool) <span class="cov8" title="1">{
        val = strings.TrimSpace(strings.ToLower(val))
        if strings.HasSuffix(val, "px") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "px"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return f * 0.75, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "pt") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "pt"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return f, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "%") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "%"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return relativeTo * f / 100.0, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasSuffix(val, "em") </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(strings.TrimSuffix(val, "em"), 64)
                if err == nil </span><span class="cov8" title="1">{
                        return f * 12, true // assume 12pt base
                }</span>
        }
        // plain number
        <span class="cov8" title="1">f, err := strconv.ParseFloat(val, 64)
        if err == nil </span><span class="cov8" title="1">{
                return f, true
        }</span>
        <span class="cov8" title="1">return 0, false</span>
}

// parseFontSizeAttr parses the HTML &lt;font size="..."&gt; attribute (1-7 scale).
func parseFontSizeAttr(val string) (float64, bool) <span class="cov8" title="1">{
        val = strings.TrimSpace(val)
        n, err := strconv.Atoi(val)
        if err != nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        // HTML font size 1-7 mapping to pt
        <span class="cov8" title="1">sizes := map[int]float64{
                1: 8, 2: 10, 3: 12, 4: 14, 5: 18, 6: 24, 7: 36,
        }
        if sz, ok := sizes[n]; ok </span><span class="cov8" title="1">{
                return sz, true
        }</span>
        <span class="cov8" title="1">return 12, true</span>
}

// headingFontSize returns the font size for h1-h6 tags.
func headingFontSize(tag string) float64 <span class="cov8" title="1">{
        switch tag </span>{
        case "h1":<span class="cov8" title="1">
                return 24</span>
        case "h2":<span class="cov8" title="1">
                return 20</span>
        case "h3":<span class="cov8" title="1">
                return 16</span>
        case "h4":<span class="cov8" title="1">
                return 14</span>
        case "h5":<span class="cov8" title="1">
                return 12</span>
        case "h6":<span class="cov8" title="1">
                return 10</span>
        }
        <span class="cov8" title="1">return 12</span>
}

// isBlockElement returns true if the tag is a block-level element.
func isBlockElement(tag string) bool <span class="cov8" title="1">{
        switch tag </span>{
        case "p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "li", "hr", "center", "blockquote":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

var cssNamedColors = map[string][3]uint8{
        "black":   {0, 0, 0},
        "white":   {255, 255, 255},
        "red":     {255, 0, 0},
        "green":   {0, 128, 0},
        "blue":    {0, 0, 255},
        "yellow":  {255, 255, 0},
        "cyan":    {0, 255, 255},
        "magenta": {255, 0, 255},
        "gray":    {128, 128, 128},
        "grey":    {128, 128, 128},
        "orange":  {255, 165, 0},
        "purple":  {128, 0, 128},
        "brown":   {165, 42, 42},
        "pink":    {255, 192, 203},
        "navy":    {0, 0, 128},
        "teal":    {0, 128, 128},
        "olive":   {128, 128, 0},
        "maroon":  {128, 0, 0},
        "silver":  {192, 192, 192},
        "lime":    {0, 255, 0},
        "aqua":    {0, 255, 255},
        "fuchsia": {255, 0, 255},
}

// htmlFontSizeToFloat converts an HTML &lt;font size="N"&gt; attribute to a float64 font size.
func htmlFontSizeToFloat(sizeStr string) float64 <span class="cov8" title="1">{
        sz, ok := parseFontSizeAttr(sizeStr)
        if !ok </span><span class="cov8" title="1">{
                return 12
        }</span>
        <span class="cov8" title="1">return sz</span>
}

// debugHTMLTree prints the HTML tree for debugging (not used in production).
func debugHTMLTree(nodes []*htmlNode, indent int) string <span class="cov8" title="1">{
        var sb strings.Builder
        prefix := strings.Repeat("  ", indent)
        for _, n := range nodes </span><span class="cov8" title="1">{
                if n.Type == htmlNodeText </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("%sTEXT: %q\n", prefix, n.Text))
                }</span> else<span class="cov8" title="1"> {
                        sb.WriteString(fmt.Sprintf("%s&lt;%s", prefix, n.Tag))
                        for k, v := range n.Attrs </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf(" %s=%q", k, v))
                        }</span>
                        <span class="cov8" title="1">if n.SelfClose </span><span class="cov8" title="1">{
                                sb.WriteString(" /&gt;\n")
                        }</span> else<span class="cov8" title="1"> {
                                sb.WriteString("&gt;\n")
                                sb.WriteString(debugHTMLTree(n.Children, indent+1))
                                sb.WriteString(fmt.Sprintf("%s&lt;/%s&gt;\n", prefix, n.Tag))
                        }</span>
                }
        }
        <span class="cov8" title="1">return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package gopdf

// IFont represents a font interface.
type IFont interface {
        Init()
        GetType() string
        GetName() string
        GetDesc() []FontDescItem
        GetUp() int
        GetUt() int
        GetCw() FontCw
        GetEnc() string
        GetDiff() string
        GetOriginalsize() int

        SetFamily(family string)
        GetFamily() string
}

// FontCw maps characters to integers.
type FontCw map[byte]int

// FontDescItem is a (key, value) pair.
type FontDescItem struct {
        Key string
        Val string
}

// // Chr
// func Chr(n int) byte {
//         return byte(n) //ToByte(fmt.Sprintf("%c", n ))
// }

// ToByte returns the first byte of a string.
func ToByte(chr string) byte <span class="cov8" title="1">{
        return []byte(chr)[0]
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package gopdf

import (
        "fmt"
)

// DeleteImages removes all image elements from the specified page (1-based).
// Returns the number of images removed.
//
// Example:
//
//        pdf.SetPage(1)
//        n, err := pdf.DeleteImages(1)
//        fmt.Printf("Removed %d images\n", n)
func (gp *GoPdf) DeleteImages(pageNo int) (int, error) <span class="cov8" title="1">{
        return gp.DeleteElementsByType(pageNo, ElementImage)
}</span>

// DeleteImagesFromAllPages removes all image elements from every page.
// Returns the total number of images removed.
//
// Example:
//
//        total, err := pdf.DeleteImagesFromAllPages()
func (gp *GoPdf) DeleteImagesFromAllPages() (int, error) <span class="cov8" title="1">{
        total := 0
        numPages := gp.GetNumberOfPages()
        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                n, err := gp.DeleteImages(i)
                if err != nil </span><span class="cov0" title="0">{
                        return total, fmt.Errorf("page %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">total += n</span>
        }
        <span class="cov8" title="1">return total, nil</span>
}

// DeleteImageByIndex removes a specific image element from a page.
// The imageIndex is the 0-based index among image elements only (not all elements).
//
// Example:
//
//        // Remove the first image on page 1
//        err := pdf.DeleteImageByIndex(1, 0)
func (gp *GoPdf) DeleteImageByIndex(pageNo int, imageIndex int) error <span class="cov8" title="1">{
        content := gp.findContentObj(pageNo)
        if content == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: page %d", ErrContentObjNotFound, pageNo)
        }</span>

        <span class="cov8" title="1">imgCount := 0
        for i, c := range content.listCache.caches </span><span class="cov8" title="1">{
                if classifyElement(c) == ElementImage </span><span class="cov8" title="1">{
                        if imgCount == imageIndex </span><span class="cov8" title="1">{
                                return gp.DeleteElement(pageNo, i)
                        }</span>
                        <span class="cov0" title="0">imgCount++</span>
                }
        }
        <span class="cov8" title="1">return fmt.Errorf("image index %d out of range (found %d images)", imageIndex, imgCount)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package gopdf

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// Pre-compiled regexes for image extraction.
var (
        reFilterName  = regexp.MustCompile(`/Filter\s+/(\w+)`)
        reFilterArray = regexp.MustCompile(`/Filter\s*\[\s*/(\w+)`)
)

// ============================================================
// Image extraction from existing PDF files
// ============================================================

// ExtractImagesFromPage extracts image metadata and data from a
// specific page (0-based) of the given PDF data.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        images, _ := gopdf.ExtractImagesFromPage(data, 0)
//        for _, img := range images {
//            fmt.Printf("%s: %dx%d %s\n", img.Name, img.Width, img.Height, img.ColorSpace)
//        }
func ExtractImagesFromPage(pdfData []byte, pageIndex int) ([]ExtractedImage, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if pageIndex &lt; 0 || pageIndex &gt;= len(parser.pages) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("page index %d out of range (0..%d)", pageIndex, len(parser.pages)-1)
        }</span>
        <span class="cov8" title="1">page := parser.pages[pageIndex]
        stream := parser.getPageContentStream(pageIndex)
        placements := parseImagePlacements(stream)
        return extractPageImages(parser, page, placements), nil</span>
}

// ExtractImagesFromAllPages extracts images from all pages.
func ExtractImagesFromAllPages(pdfData []byte) (map[int][]ExtractedImage, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := make(map[int][]ExtractedImage, len(parser.pages))
        for i, page := range parser.pages </span><span class="cov8" title="1">{
                stream := parser.getPageContentStream(i)
                placements := parseImagePlacements(stream)
                imgs := extractPageImages(parser, page, placements)
                if len(imgs) &gt; 0 </span><span class="cov8" title="1">{
                        result[i] = imgs
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// imagePlacement records where an XObject image is placed on a page.
type imagePlacement struct {
        name string  // e.g. "/Im1"
        a, b, c, d float64 // CTM components
        e, f       float64 // CTM translation
}

// parseImagePlacements finds "Do" operators in the content stream
// and extracts the CTM at each invocation point.
func parseImagePlacements(stream []byte) []imagePlacement <span class="cov8" title="1">{
        if len(stream) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">tokens := tokenize(stream)
        var placements []imagePlacement

        // Track CTM via cm operators (simplified: last cm wins)
        ctmA, ctmB, ctmC, ctmD := 1.0, 0.0, 0.0, 1.0
        ctmE, ctmF := 0.0, 0.0

        stack := make([]float64, 0, 16)
        for i := 0; i &lt; len(tokens); i++ </span><span class="cov8" title="1">{
                tok := tokens[i]
                if v, err := strconv.ParseFloat(tok, 64); err == nil </span><span class="cov8" title="1">{
                        stack = append(stack, v)
                        continue</span>
                }
                <span class="cov8" title="1">switch tok </span>{
                case "cm":<span class="cov8" title="1">
                        if len(stack) &gt;= 6 </span><span class="cov8" title="1">{
                                ctmA = stack[len(stack)-6]
                                ctmB = stack[len(stack)-5]
                                ctmC = stack[len(stack)-4]
                                ctmD = stack[len(stack)-3]
                                ctmE = stack[len(stack)-2]
                                ctmF = stack[len(stack)-1]
                                stack = stack[:len(stack)-6]
                        }</span>
                case "Do":<span class="cov8" title="1">
                        // The name is the previous token
                        if i &gt;= 1 &amp;&amp; strings.HasPrefix(tokens[i-1], "/") </span><span class="cov8" title="1">{
                                placements = append(placements, imagePlacement{
                                        name: tokens[i-1],
                                        a: ctmA, b: ctmB, c: ctmC, d: ctmD,
                                        e: ctmE, f: ctmF,
                                })
                        }</span>
                        <span class="cov8" title="1">stack = stack[:0]</span>
                case "q":<span class="cov8" title="1"></span>
                        // save graphics state â€” simplified, just reset stack
                case "Q":<span class="cov8" title="1">
                        // restore graphics state â€” simplified
                        ctmA, ctmB, ctmC, ctmD = 1, 0, 0, 1
                        ctmE, ctmF = 0, 0</span>
                default:<span class="cov8" title="1">
                        // non-numeric, non-operator â€” could be a name
                        if !strings.HasPrefix(tok, "/") </span><span class="cov0" title="0">{
                                stack = stack[:0]
                        }</span>
                }
        }
        <span class="cov8" title="1">return placements</span>
}

func extractPageImages(parser *rawPDFParser, page rawPDFPage, placements []imagePlacement) []ExtractedImage <span class="cov8" title="1">{
        var images []ExtractedImage
        pageHeight := page.mediaBox[3] - page.mediaBox[1]

        // Build placement map
        placementMap := make(map[string]imagePlacement)
        for _, p := range placements </span><span class="cov8" title="1">{
                placementMap[p.name] = p
        }</span>

        <span class="cov8" title="1">for name, objNum := range page.resources.xobjs </span><span class="cov8" title="1">{
                obj, ok := parser.objects[objNum]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Check if it's an image XObject
                <span class="cov8" title="1">if !strings.Contains(obj.dict, "/Subtype /Image") &amp;&amp;
                        !strings.Contains(obj.dict, "/Subtype/Image") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">img := ExtractedImage{
                        Name:   name,
                        ObjNum: objNum,
                }
                img.Width = extractIntValue(obj.dict, "/Width")
                img.Height = extractIntValue(obj.dict, "/Height")
                img.BitsPerComponent = extractIntValue(obj.dict, "/BitsPerComponent")
                img.ColorSpace = extractName(obj.dict, "/ColorSpace")
                img.Filter = extractFilterValue(obj.dict)
                if obj.stream != nil </span><span class="cov8" title="1">{
                        // For FlateDecode, stream is already decompressed by parser.
                        // For DCTDecode (JPEG), the raw stream IS the JPEG data.
                        img.Data = obj.stream
                }</span>
                // Apply placement info
                <span class="cov8" title="1">if p, ok := placementMap[name]; ok </span><span class="cov8" title="1">{
                        img.X = p.e
                        img.Y = pageHeight - p.f - p.d
                        img.DisplayWidth = p.a
                        img.DisplayHeight = p.d
                }</span>
                <span class="cov8" title="1">images = append(images, img)</span>
        }
        <span class="cov8" title="1">return images</span>
}

// extractIntValue extracts an integer value for a given key from a dict string.
// Uses string search instead of regex for performance.
func extractIntValue(dict, key string) int <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        // Skip whitespace
        i := 0
        for i &lt; len(rest) &amp;&amp; (rest[i] == ' ' || rest[i] == '\t' || rest[i] == '\r' || rest[i] == '\n') </span><span class="cov8" title="1">{
                i++
        }</span>
        // Read digits
        <span class="cov8" title="1">start := i
        for i &lt; len(rest) &amp;&amp; rest[i] &gt;= '0' &amp;&amp; rest[i] &lt;= '9' </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">if i &gt; start </span><span class="cov8" title="1">{
                v, _ := strconv.Atoi(rest[start:i])
                return v
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func extractFilterValue(dict string) string <span class="cov8" title="1">{
        // /Filter can be a name or array â€” use pre-compiled regexes
        m := reFilterName.FindStringSubmatch(dict)
        if m != nil </span><span class="cov8" title="1">{
                return m[1]
        }</span>
        // array form
        <span class="cov8" title="1">m2 := reFilterArray.FindStringSubmatch(dict)
        if m2 != nil </span><span class="cov8" title="1">{
                return m2[1]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetImageFormat returns the likely image format based on the filter.
func (img *ExtractedImage) GetImageFormat() string <span class="cov8" title="1">{
        switch img.Filter </span>{
        case "DCTDecode":<span class="cov8" title="1">
                return "jpeg"</span>
        case "JPXDecode":<span class="cov8" title="1">
                return "jp2"</span>
        case "CCITTFaxDecode":<span class="cov8" title="1">
                return "tiff"</span>
        case "FlateDecode", "":<span class="cov8" title="1">
                return "png"</span> // raw pixel data, typically saved as PNG
        default:<span class="cov8" title="1">
                return "raw"</span>
        }
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package gopdf

import (
        "bytes"
        "crypto/md5"
        "fmt"
        "io"
        "os"
)

// ImageHolder hold image data
type ImageHolder interface {
        ID() string
        io.Reader
}

// ImageHolderByBytes create ImageHolder by []byte
func ImageHolderByBytes(b []byte) (ImageHolder, error) <span class="cov8" title="1">{
        return newImageBuff(b)
}</span>

// ImageHolderByPath create ImageHolder by image path
func ImageHolderByPath(path string) (ImageHolder, error) <span class="cov8" title="1">{
        return newImageBuffByPath(path)
}</span>

// ImageHolderByReader create ImageHolder by io.Reader
func ImageHolderByReader(r io.Reader) (ImageHolder, error) <span class="cov8" title="1">{
        return newImageBuffByReader(r)
}</span>

// imageBuff image holder (impl ImageHolder)
type imageBuff struct {
        id string
        bytes.Buffer
}

func newImageBuff(b []byte) (*imageBuff, error) <span class="cov8" title="1">{
        h := md5.New()
        _, err := h.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var i imageBuff
        i.id = fmt.Sprintf("%x", h.Sum(nil))
        i.Write(b)
        return &amp;i, nil</span>
}

func newImageBuffByPath(path string) (*imageBuff, error) <span class="cov8" title="1">{
        var i imageBuff
        i.id = path
        b, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">i.Write(b)
        return &amp;i, nil</span>
}

func newImageBuffByReader(r io.Reader) (*imageBuff, error) <span class="cov8" title="1">{

        b, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">h := md5.New()
        _, err = h.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var i imageBuff
        i.id = fmt.Sprintf("%x", h.Sum(nil))
        i.Write(b)
        return &amp;i, nil</span>
}

func (i *imageBuff) ID() string <span class="cov8" title="1">{
        return i.id
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "image"

        // Packages image/jpeg and image/png are not used explicitly in the code below,
        // but are imported for their initialization side-effect, which allows
        // image.Decode to understand JPEG formatted images.
        _ "image/jpeg"
        _ "image/png"
        "io"
        "log"
        "os"
)

// ImageObj image object
type ImageObj struct {
        //imagepath string
        IsMask        bool
        SplittedMask  bool
        rawImgReader  *bytes.Reader
        imginfo       imgInfo
        pdfProtection *PDFProtection
        //getRoot func() *GoPdf
}

func (i *ImageObj) init(funcGetRoot func() *GoPdf) {<span class="cov8" title="1">

}</span>

func (i *ImageObj) setProtection(p *PDFProtection) <span class="cov8" title="1">{
        i.pdfProtection = p
}</span>

func (i *ImageObj) protection() *PDFProtection <span class="cov8" title="1">{
        return i.pdfProtection
}</span>

func (i *ImageObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        data := i.imginfo.data

        if i.IsMask </span><span class="cov8" title="1">{
                data = i.imginfo.smask
                if err := writeMaskImgProps(w, i.imginfo); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := writeImgProps(w, i.imginfo, i.SplittedMask); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if _, err := fmt.Fprintf(w, "\t/Length %d\n&gt;&gt;\n", len(data)); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := io.WriteString(w, "stream\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if i.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(i.protection().objectkey(objID), data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if _, err := w.Write(tmp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := io.WriteString(w, "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if _, err := w.Write(data); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if _, err := io.WriteString(w, "\nendstream\n"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (i *ImageObj) isColspaceIndexed() bool <span class="cov8" title="1">{
        return isColspaceIndexed(i.imginfo)
}</span>

func (i *ImageObj) haveSMask() bool <span class="cov8" title="1">{
        return haveSMask(i.imginfo)
}</span>

func (i *ImageObj) createSMask() (*SMask, error) <span class="cov8" title="1">{
        var smk SMask
        smk.setProtection(i.protection())
        smk.w = i.imginfo.w
        smk.h = i.imginfo.h
        smk.colspace = "DeviceGray"
        smk.bitsPerComponent = "8"
        smk.filter = i.imginfo.filter
        smk.data = i.imginfo.smask
        smk.decodeParms = fmt.Sprintf("/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns %d", i.imginfo.w)
        return &amp;smk, nil
}</span>

func (i *ImageObj) createDeviceRGB() (*DeviceRGBObj, error) <span class="cov8" title="1">{
        var dRGB DeviceRGBObj
        dRGB.data = i.imginfo.pal
        return &amp;dRGB, nil
}</span>

func (i *ImageObj) getType() string <span class="cov8" title="1">{
        return "Image"
}</span>

// SetImagePath set image path
func (i *ImageObj) SetImagePath(path string) error <span class="cov8" title="1">{

        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        err = i.SetImage(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetImage set image
func (i *ImageObj) SetImage(r io.Reader) error <span class="cov8" title="1">{

        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.rawImgReader = bytes.NewReader(data)

        return nil</span>
}

// GetRect get rect of img
//
// Deprecated: This method calls log.Fatalf on error, which terminates the
// program. Use getRect() internally or handle the error appropriately.
func (i *ImageObj) GetRect() *Rect <span class="cov8" title="1">{

        rect, err := i.getRect()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v", err)
        }</span>
        <span class="cov8" title="1">return rect</span>
}

// GetRect get rect of img
func (i *ImageObj) getRect() (*Rect, error) <span class="cov8" title="1">{

        i.rawImgReader.Seek(0, 0)
        m, _, err := image.Decode(i.rawImgReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">imageRect := m.Bounds()
        k := 1
        w := -128 //init
        h := -128 //init
        if w &lt; 0 </span><span class="cov8" title="1">{
                w = -imageRect.Dx() * 72 / w / k
        }</span>
        <span class="cov8" title="1">if h &lt; 0 </span><span class="cov8" title="1">{
                h = -imageRect.Dy() * 72 / h / k
        }</span>
        <span class="cov8" title="1">if w == 0 </span><span class="cov0" title="0">{
                w = h * imageRect.Dx() / imageRect.Dy()
        }</span>
        <span class="cov8" title="1">if h == 0 </span><span class="cov0" title="0">{
                h = w * imageRect.Dy() / imageRect.Dx()
        }</span>

        <span class="cov8" title="1">var rect = new(Rect)
        rect.H = float64(h)
        rect.W = float64(w)

        return rect, nil</span>
}

func (i *ImageObj) parse() error <span class="cov8" title="1">{

        i.rawImgReader.Seek(0, 0)
        imginfo, err := parseImg(i.rawImgReader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.imginfo = imginfo

        return nil</span>
}

// Parse parse img
func (i *ImageObj) Parse() error <span class="cov8" title="1">{
        return i.parse()
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package gopdf

import (
        "bytes"
        "compress/zlib"
        "encoding/binary"
        "errors"
        "fmt"
        "image"
        "image/color"
        _ "image/gif"
        "image/png"
        "io"
        "os"
        "strings"
)

type ColorSpaces string

const (
        DeviceGray = "DeviceGray"
)

func writeMaskImgProps(w io.Writer, imginfo imgInfo) error <span class="cov8" title="1">{
        if err := writeBaseImgProps(w, imginfo, DeviceGray); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">decode := "\t/DecodeParms &lt;&lt;\n"
        decode += "\t\t/Predictor 15\n"
        decode += "\t\t/Colors 1\n"
        decode += "\t\t/BitsPerComponent 8\n"
        decode += fmt.Sprintf("\t\t/Columns %d\n", imginfo.w)
        decode += "\t&gt;&gt;\n"

        if _, err := io.WriteString(w, decode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func writeImgProps(w io.Writer, imginfo imgInfo, splittedMask bool) error <span class="cov8" title="1">{
        if err := writeBaseImgProps(w, imginfo, imginfo.colspace); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(imginfo.decodeParms) != "" </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "\t/DecodeParms &lt;&lt;%s&gt;&gt;\n", imginfo.decodeParms); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if splittedMask </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if imginfo.trns != nil &amp;&amp; len(imginfo.trns) &gt; 0 </span><span class="cov8" title="1">{
                j := 0
                content := "\t/Mask ["
                max := len(imginfo.trns)

                for j &lt; max </span><span class="cov8" title="1">{
                        content += fmt.Sprintf("\t\t%d ", imginfo.trns[j])
                        content += fmt.Sprintf("\t\t%d ", imginfo.trns[j])
                        j++
                }</span>

                <span class="cov8" title="1">content += "\t]\n"

                if _, err := io.WriteString(w, content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if haveSMask(imginfo) </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(w, "\t/SMask %d 0 R\n", imginfo.smarkObjID+1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func writeBaseImgProps(w io.Writer, imginfo imgInfo, colorSpace string) error <span class="cov8" title="1">{
        content := "&lt;&lt;\n"
        content += "\t/Type /XObject\n"
        content += "\t/Subtype /Image\n"
        content += fmt.Sprintf("\t/Width %d\n", imginfo.w)
        content += fmt.Sprintf("\t/Height %d\n", imginfo.h)

        if isColspaceIndexed(imginfo) </span><span class="cov8" title="1">{
                size := len(imginfo.pal)/3 - 1
                content += fmt.Sprintf("\t/ColorSpace [/Indexed /DeviceRGB %d %d 0 R]\n", size, imginfo.deviceRGBObjID+1)
        }</span> else<span class="cov8" title="1"> {
                content += fmt.Sprintf("\t/ColorSpace /%s\n", colorSpace)
                if imginfo.colspace == "DeviceCMYK" </span><span class="cov8" title="1">{
                        content += "\t/Decode [1 0 1 0 1 0 1 0]\n"
                }</span>
        }

        <span class="cov8" title="1">content += fmt.Sprintf("\t/BitsPerComponent %s\n", imginfo.bitsPerComponent)

        if strings.TrimSpace(imginfo.filter) != "" </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/Filter /%s\n", imginfo.filter)
        }</span>

        <span class="cov8" title="1">if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isColspaceIndexed(imginfo imgInfo) bool <span class="cov8" title="1">{
        if imginfo.colspace == "Indexed" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func haveSMask(imginfo imgInfo) bool <span class="cov8" title="1">{
        if imginfo.smask != nil &amp;&amp; len(imginfo.smask) &gt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func parseImgByPath(path string) (imgInfo, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return imgInfo{}, err
        }</span>
        <span class="cov8" title="1">return parseImg(bytes.NewReader(data))</span>
}

func parseImg(raw *bytes.Reader) (imgInfo, error) <span class="cov8" title="1">{
        // fmt.Printf("----------\n")
        var info imgInfo
        raw.Seek(0, 0)
        imgConfig, formatname, err := image.DecodeConfig(raw)
        if err != nil </span><span class="cov8" title="1">{
                return info, err
        }</span>
        <span class="cov8" title="1">info.formatName = formatname

        if formatname == "jpeg" </span><span class="cov8" title="1">{

                err = parseImgJpg(&amp;info, imgConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return info, err
                }</span>
                <span class="cov8" title="1">raw.Seek(0, 0)
                info.data, err = io.ReadAll(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return info, err
                }</span>

        } else<span class="cov8" title="1"> if formatname == "png" </span><span class="cov8" title="1">{
                err = parsePng(raw, &amp;info, imgConfig)
                if err != nil </span><span class="cov8" title="1">{
                        return info, err
                }</span>
        } else<span class="cov8" title="1"> if formatname == "gif" </span><span class="cov8" title="1">{
                // Convert to png
                raw.Seek(0, 0)
                var img image.Image
                img, _, err = image.Decode(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return info, err
                }</span>
                <span class="cov8" title="1">pngBuf := new(bytes.Buffer)
                err = png.Encode(pngBuf, img)
                if err != nil </span><span class="cov0" title="0">{
                        return info, err
                }</span>
                <span class="cov8" title="1">info, err = parseImg(bytes.NewReader(pngBuf.Bytes()))
                if err != nil </span><span class="cov0" title="0">{
                        return info, err
                }</span>
        } else<span class="cov0" title="0"> {
                return info, fmt.Errorf("Image format %v is not supported", formatname)
        }</span>

        // fmt.Printf("%#v\n", info)

        <span class="cov8" title="1">return info, nil</span>
}

func parseImgJpg(info *imgInfo, imgConfig image.Config) error <span class="cov8" title="1">{
        switch imgConfig.ColorModel </span>{
        case color.YCbCrModel:<span class="cov8" title="1">
                info.colspace = "DeviceRGB"</span>
        case color.GrayModel:<span class="cov8" title="1">
                info.colspace = "DeviceGray"</span>
        case color.CMYKModel:<span class="cov8" title="1">
                info.colspace = "DeviceCMYK"</span>
        default:<span class="cov0" title="0">
                return errors.New("color model not support")</span>
        }
        <span class="cov8" title="1">info.bitsPerComponent = "8"
        info.filter = "DCTDecode"

        info.h = imgConfig.Height
        info.w = imgConfig.Width

        return nil</span>
}

var pngMagicNumber = []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a}
var pngIHDR = []byte{0x49, 0x48, 0x44, 0x52}

func parsePng(f *bytes.Reader, info *imgInfo, imgConfig image.Config) error <span class="cov8" title="1">{
        // f := bytes.NewReader(raw)
        f.Seek(0, 0)
        b, err := readBytes(f, 8)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(b, pngMagicNumber) </span><span class="cov8" title="1">{
                return errors.New("Not a PNG file")
        }</span>

        <span class="cov8" title="1">f.Seek(4, 1) // skip header chunk
        b, err = readBytes(f, 4)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(b, pngIHDR) </span><span class="cov8" title="1">{
                return errors.New("Incorrect PNG file")
        }</span>

        <span class="cov8" title="1">w, err := readInt(f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">h, err := readInt(f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // fmt.Printf("w=%d h=%d\n", w, h)

        <span class="cov8" title="1">bpc, err := readBytes(f, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if bpc[0] &gt; 8 </span><span class="cov8" title="1">{
                return errors.New("16-bit depth not supported")
        }</span>

        <span class="cov8" title="1">ct, err := readBytes(f, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var colspace string
        switch ct[0] </span>{
        case 0, 4:<span class="cov8" title="1">
                colspace = "DeviceGray"</span>
        case 2, 6:<span class="cov8" title="1">
                colspace = "DeviceRGB"</span>
        case 3:<span class="cov8" title="1">
                colspace = "Indexed"</span>
        default:<span class="cov8" title="1">
                return errors.New("Unknown color type")</span>
        }

        <span class="cov8" title="1">compressionMethod, err := readBytes(f, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if compressionMethod[0] != 0 </span><span class="cov8" title="1">{
                return errors.New("Unknown compression method")
        }</span>

        <span class="cov8" title="1">filterMethod, err := readBytes(f, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if filterMethod[0] != 0 </span><span class="cov8" title="1">{
                return errors.New("Unknown filter method")
        }</span>

        <span class="cov8" title="1">interlacing, err := readBytes(f, 1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if interlacing[0] != 0 </span><span class="cov8" title="1">{
                return errors.New("Interlacing not supported")
        }</span>

        <span class="cov8" title="1">_, err = f.Seek(4, 1) // skip
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // decodeParms := "/Predictor 15 /Colors '.($colspace=='DeviceRGB' ? 3 : 1).' /BitsPerComponent '.$bpc.' /Columns '.$w;

        <span class="cov8" title="1">var pal []byte
        var trns []byte
        var data []byte
        for </span><span class="cov8" title="1">{
                un, err := readUInt(f)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">n := int(un)
                typ, err := readBytes(f, 4)
                // fmt.Printf("&gt;&gt;&gt;&gt;%+v-%s-%d\n", typ, string(typ), n)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if string(typ) == "PLTE" </span><span class="cov8" title="1">{
                        pal, err = readBytes(f, n)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, err = f.Seek(int64(4), 1) // skip
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if string(typ) == "tRNS" </span><span class="cov8" title="1">{

                        var t []byte
                        t, err = readBytes(f, n)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if ct[0] == 0 </span><span class="cov8" title="1">{
                                trns = []byte{(t[1])}
                        }</span> else<span class="cov8" title="1"> if ct[0] == 2 </span><span class="cov8" title="1">{
                                trns = []byte{t[1], t[3], t[5]}
                        }</span> else<span class="cov8" title="1"> {
                                pos := strings.Index(string(t), "\x00")
                                if pos &gt;= 0 </span><span class="cov8" title="1">{
                                        trns = []byte{byte(pos)}
                                }</span>
                        }

                        <span class="cov8" title="1">_, err = f.Seek(int64(4), 1) // skip
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                } else<span class="cov8" title="1"> if string(typ) == "IDAT" </span><span class="cov8" title="1">{
                        // fmt.Printf("n=%d\n\n", n)
                        var d []byte
                        d, err = readBytes(f, n)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">data = append(data, d...)
                        _, err = f.Seek(int64(4), 1) // skip
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if string(typ) == "IEND" </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov8" title="1"> {
                        _, err = f.Seek(int64(n+4), 1) // skip
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if n &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        } // end for

        // info.data = data //ok
        <span class="cov8" title="1">info.trns = trns
        info.pal = pal

        // fmt.Printf("data= %x", md5.Sum(data))

        if colspace == "Indexed" &amp;&amp; strings.TrimSpace(string(pal)) == "" </span><span class="cov8" title="1">{
                return errors.New("Missing palette")
        }</span>

        <span class="cov8" title="1">info.w = w
        info.h = h
        info.colspace = colspace
        info.bitsPerComponent = fmt.Sprintf("%d", int(bpc[0]))
        info.filter = "FlateDecode"

        colors := 1
        if colspace == "DeviceRGB" </span><span class="cov8" title="1">{
                colors = 3
        }</span>
        <span class="cov8" title="1">info.decodeParms = fmt.Sprintf("/Predictor 15 /Colors  %d /BitsPerComponent %s /Columns %d", colors, info.bitsPerComponent, w)

        // fmt.Printf("%d = ct[0]\n", ct[0])
        // fmt.Printf("%x\n", md5.Sum(data))
        if ct[0] &gt;= 4 </span><span class="cov8" title="1">{
                zipReader, err := zlib.NewReader(bytes.NewReader(data))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">defer zipReader.Close()
                afterZipData, err := io.ReadAll(zipReader)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var color []byte
                var alpha []byte
                if ct[0] == 4 </span><span class="cov8" title="1">{
                        // Gray image
                        length := 2 * w
                        i := 0
                        for i &lt; h </span><span class="cov8" title="1">{
                                pos := (1 + length) * i
                                color = append(color, afterZipData[pos])
                                alpha = append(alpha, afterZipData[pos])
                                line := afterZipData[pos+1 : pos+length+1]
                                j := 0
                                max := len(line)
                                for j &lt; max </span><span class="cov8" title="1">{
                                        color = append(color, line[j])
                                        j++
                                        alpha = append(alpha, line[j])
                                        j++
                                }</span>
                                <span class="cov8" title="1">i++</span>
                        }
                        // fmt.Print("aaaaa")

                } else<span class="cov8" title="1"> {
                        // RGB image
                        length := 4 * w
                        i := 0
                        for i &lt; h </span><span class="cov8" title="1">{
                                pos := (1 + length) * i
                                color = append(color, afterZipData[pos])
                                alpha = append(alpha, afterZipData[pos])
                                line := afterZipData[pos+1 : pos+length+1]
                                j := 0
                                max := len(line)
                                for j &lt; max </span><span class="cov8" title="1">{
                                        color = append(color, line[j:j+3]...)
                                        alpha = append(alpha, line[j+3])
                                        j = j + 4
                                }</span>

                                <span class="cov8" title="1">i++</span>
                        }
                }

                <span class="cov8" title="1">info.smask, err = compress(alpha)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">info.data, err = compress(color)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov8" title="1"> {
                info.data = data
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func compress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        var results []byte
        var buff bytes.Buffer
        zwr, err := zlib.NewWriterLevel(&amp;buff, zlib.BestSpeed)

        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>
        <span class="cov8" title="1">_, err = zwr.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">zwr.Close()
        return buff.Bytes(), nil</span>
}

func readUInt(f *bytes.Reader) (uint, error) <span class="cov8" title="1">{
        buff, err := readBytes(f, 4)
        // fmt.Printf("%#v\n\n", buff)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">n := binary.BigEndian.Uint32(buff)
        return uint(n), nil</span>
}

func readInt(f *bytes.Reader) (int, error) <span class="cov8" title="1">{
        u, err := readUInt(f)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">v := int(u)
        return v, nil</span>
}

func readBytes(f *bytes.Reader, len int) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, len)
        _, err := f.Read(b)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

func isDeviceRGB(formatname string, img *image.Image) bool <span class="cov8" title="1">{
        if _, ok := (*img).(*image.YCbCr); ok </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if _, ok := (*img).(*image.NRGBA); ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// ImgReactagleToWH  Rectangle to W and H
func ImgReactagleToWH(imageRect image.Rectangle) (float64, float64) <span class="cov8" title="1">{
        k := 1
        w := -128 // init
        h := -128 // init
        if w &lt; 0 </span><span class="cov8" title="1">{
                w = -imageRect.Dx() * 72 / w / k
        }</span>
        <span class="cov8" title="1">if h &lt; 0 </span><span class="cov8" title="1">{
                h = -imageRect.Dy() * 72 / h / k
        }</span>
        <span class="cov8" title="1">if w == 0 </span><span class="cov0" title="0">{
                w = h * imageRect.Dx() / imageRect.Dy()
        }</span>
        <span class="cov8" title="1">if h == 0 </span><span class="cov0" title="0">{
                h = w * imageRect.Dy() / imageRect.Dx()
        }</span>
        <span class="cov8" title="1">return float64(w), float64(h)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "regexp"
        "strconv"
        "strings"
)

// Pre-compiled regex for xref rebuilding.
var reObjHeaderLine = regexp.MustCompile(`(?m)^(\d+) 0 obj`)

// RecompressOption configures how images are recompressed.
type RecompressOption struct {
        // Format is the target format: "jpeg" or "png". Default: "jpeg".
        Format string
        // JPEGQuality is the JPEG quality (1-100). Default: 75.
        JPEGQuality int
        // MaxWidth limits the maximum image width. 0 means no limit.
        MaxWidth int
        // MaxHeight limits the maximum image height. 0 means no limit.
        MaxHeight int
}

func (o *RecompressOption) defaults() <span class="cov8" title="1">{
        if o.Format == "" </span><span class="cov8" title="1">{
                o.Format = "jpeg"
        }</span>
        <span class="cov8" title="1">if o.JPEGQuality &lt;= 0 || o.JPEGQuality &gt; 100 </span><span class="cov8" title="1">{
                o.JPEGQuality = 75
        }</span>
}

// RecompressImages recompresses all images in the given PDF data and
// returns the modified PDF data.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        smaller, err := gopdf.RecompressImages(data, gopdf.RecompressOption{
//            Format:      "jpeg",
//            JPEGQuality: 60,
//        })
//        os.WriteFile("output.pdf", smaller, 0644)
func RecompressImages(pdfData []byte, opt RecompressOption) ([]byte, error) <span class="cov8" title="1">{
        opt.defaults()
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF: %w", err)
        }</span>

        // Collect all image XObject object numbers.
        <span class="cov8" title="1">imageObjs := make(map[int]bool)
        for _, page := range parser.pages </span><span class="cov8" title="1">{
                for _, objNum := range page.resources.xobjs </span><span class="cov8" title="1">{
                        obj, ok := parser.objects[objNum]
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if strings.Contains(obj.dict, "/Subtype /Image") ||
                                strings.Contains(obj.dict, "/Subtype/Image") </span><span class="cov8" title="1">{
                                imageObjs[objNum] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(imageObjs) == 0 </span><span class="cov8" title="1">{
                return pdfData, nil
        }</span>

        <span class="cov8" title="1">result := make([]byte, len(pdfData))
        copy(result, pdfData)

        for objNum := range imageObjs </span><span class="cov8" title="1">{
                obj := parser.objects[objNum]
                recompressed, newDict, err := recompressImageObj(obj, opt)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">result = replaceObjectStream(result, objNum, newDict, recompressed)</span>
        }

        <span class="cov8" title="1">result = rebuildXref(result)
        return result, nil</span>
}

func recompressImageObj(obj rawPDFObject, opt RecompressOption) ([]byte, string, error) <span class="cov8" title="1">{
        imgData := obj.stream
        if imgData == nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("no stream data")
        }</span>

        <span class="cov8" title="1">filter := extractFilterValue(obj.dict)
        var img image.Image
        var err error

        switch filter </span>{
        case "DCTDecode":<span class="cov8" title="1">
                img, err = jpeg.Decode(bytes.NewReader(imgData))</span>
        case "FlateDecode", "":<span class="cov8" title="1">
                img, _, err = image.Decode(bytes.NewReader(imgData))
                if err != nil </span><span class="cov8" title="1">{
                        return nil, "", fmt.Errorf("cannot decode FlateDecode image: %w", err)
                }</span>
        default:<span class="cov8" title="1">
                return nil, "", fmt.Errorf("unsupported filter: %s", filter)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("decode image: %w", err)
        }</span>

        <span class="cov8" title="1">bounds := img.Bounds()
        w := bounds.Dx()
        h := bounds.Dy()
        if (opt.MaxWidth &gt; 0 &amp;&amp; w &gt; opt.MaxWidth) || (opt.MaxHeight &gt; 0 &amp;&amp; h &gt; opt.MaxHeight) </span><span class="cov8" title="1">{
                img = downscaleImage(img, opt.MaxWidth, opt.MaxHeight)
                bounds = img.Bounds()
                w = bounds.Dx()
                h = bounds.Dy()
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        var newFilter string

        switch opt.Format </span>{
        case "jpeg":<span class="cov8" title="1">
                err = jpeg.Encode(&amp;buf, img, &amp;jpeg.Options{Quality: opt.JPEGQuality})
                newFilter = "DCTDecode"</span>
        case "png":<span class="cov8" title="1">
                err = png.Encode(&amp;buf, img)
                newFilter = "FlateDecode"</span>
        default:<span class="cov8" title="1">
                return nil, "", fmt.Errorf("unsupported target format: %s", opt.Format)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("encode image: %w", err)
        }</span>

        <span class="cov8" title="1">newDict := fmt.Sprintf("&lt;&lt; /Type /XObject /Subtype /Image /Width %d /Height %d /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /%s /Length %d &gt;&gt;",
                w, h, newFilter, buf.Len())

        return buf.Bytes(), newDict, nil</span>
}

func downscaleImage(src image.Image, maxW, maxH int) image.Image <span class="cov8" title="1">{
        bounds := src.Bounds()
        w := bounds.Dx()
        h := bounds.Dy()

        scaleW := 1.0
        scaleH := 1.0
        if maxW &gt; 0 &amp;&amp; w &gt; maxW </span><span class="cov8" title="1">{
                scaleW = float64(maxW) / float64(w)
        }</span>
        <span class="cov8" title="1">if maxH &gt; 0 &amp;&amp; h &gt; maxH </span><span class="cov8" title="1">{
                scaleH = float64(maxH) / float64(h)
        }</span>
        <span class="cov8" title="1">scale := scaleW
        if scaleH &lt; scale </span><span class="cov8" title="1">{
                scale = scaleH
        }</span>

        <span class="cov8" title="1">newW := int(float64(w) * scale)
        newH := int(float64(h) * scale)
        if newW &lt; 1 </span><span class="cov0" title="0">{
                newW = 1
        }</span>
        <span class="cov8" title="1">if newH &lt; 1 </span><span class="cov0" title="0">{
                newH = 1
        }</span>

        <span class="cov8" title="1">dst := image.NewRGBA(image.Rect(0, 0, newW, newH))
        // Use nearest-neighbor with direct pixel access for performance.
        invScale := 1.0 / scale
        for y := 0; y &lt; newH; y++ </span><span class="cov8" title="1">{
                srcY := int(float64(y) * invScale)
                if srcY &gt;= h </span><span class="cov0" title="0">{
                        srcY = h - 1
                }</span>
                <span class="cov8" title="1">srcY += bounds.Min.Y
                for x := 0; x &lt; newW; x++ </span><span class="cov8" title="1">{
                        srcX := int(float64(x) * invScale)
                        if srcX &gt;= w </span><span class="cov0" title="0">{
                                srcX = w - 1
                        }</span>
                        <span class="cov8" title="1">r, g, b, a := src.At(bounds.Min.X+srcX, srcY).RGBA()
                        dst.Pix[(y*dst.Stride)+(x*4)+0] = uint8(r &gt;&gt; 8)
                        dst.Pix[(y*dst.Stride)+(x*4)+1] = uint8(g &gt;&gt; 8)
                        dst.Pix[(y*dst.Stride)+(x*4)+2] = uint8(b &gt;&gt; 8)
                        dst.Pix[(y*dst.Stride)+(x*4)+3] = uint8(a &gt;&gt; 8)</span>
                }
        }
        <span class="cov8" title="1">return dst</span>
}

func replaceObjectStream(pdfData []byte, objNum int, newDict string, newStream []byte) []byte <span class="cov8" title="1">{
        objHeader := fmt.Sprintf("%d 0 obj\n", objNum)
        idx := bytes.Index(pdfData, []byte(objHeader))
        if idx &lt; 0 </span><span class="cov8" title="1">{
                objHeader = fmt.Sprintf("%d 0 obj\r\n", objNum)
                idx = bytes.Index(pdfData, []byte(objHeader))
        }</span>
        <span class="cov8" title="1">if idx &lt; 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>

        <span class="cov8" title="1">endIdx := bytes.Index(pdfData[idx:], []byte("endobj"))
        if endIdx &lt; 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>
        <span class="cov8" title="1">endIdx += idx + len("endobj")

        // Pre-allocate result buffer with estimated capacity.
        estSize := len(pdfData) - (endIdx - idx) + len(objHeader) + len(newDict) + len(newStream) + 32
        var result bytes.Buffer
        result.Grow(estSize)
        result.Write(pdfData[:idx])
        fmt.Fprintf(&amp;result, "%d 0 obj\n", objNum)
        result.WriteString(newDict)
        result.WriteString("\nstream\n")
        result.Write(newStream)
        result.WriteString("\nendstream\nendobj")
        result.Write(pdfData[endIdx:])

        return result.Bytes()</span>
}

func rebuildXref(pdfData []byte) []byte <span class="cov8" title="1">{
        xrefIdx := bytes.LastIndex(pdfData, []byte("xref\n"))
        if xrefIdx &lt; 0 </span><span class="cov8" title="1">{
                xrefIdx = bytes.LastIndex(pdfData, []byte("xref\r\n"))
        }</span>
        <span class="cov8" title="1">if xrefIdx &lt; 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>

        <span class="cov8" title="1">objOffsets := make(map[int]int)
        matches := reObjHeaderLine.FindAllSubmatchIndex(pdfData, -1)
        for _, m := range matches </span><span class="cov8" title="1">{
                numStr := string(pdfData[m[2]:m[3]])
                num, _ := strconv.Atoi(numStr)
                objOffsets[num] = m[0]
        }</span>

        <span class="cov8" title="1">if len(objOffsets) == 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>

        <span class="cov8" title="1">maxObj := 0
        for n := range objOffsets </span><span class="cov8" title="1">{
                if n &gt; maxObj </span><span class="cov8" title="1">{
                        maxObj = n
                }</span>
        }

        <span class="cov8" title="1">var xref bytes.Buffer
        xref.Grow(20*(maxObj+1) + 32)
        xref.WriteString("xref\n")
        fmt.Fprintf(&amp;xref, "0 %d\n", maxObj+1)
        xref.WriteString("0000000000 65535 f \n")
        for i := 1; i &lt;= maxObj; i++ </span><span class="cov8" title="1">{
                if off, ok := objOffsets[i]; ok </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;xref, "%010d 00000 n \n", off)
                }</span> else<span class="cov0" title="0"> {
                        xref.WriteString("0000000000 00000 f \n")
                }</span>
        }

        <span class="cov8" title="1">trailerIdx := bytes.Index(pdfData[xrefIdx:], []byte("trailer"))
        if trailerIdx &lt; 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>
        <span class="cov8" title="1">trailerStart := xrefIdx + trailerIdx

        trailerContent := pdfData[trailerStart:]
        startxrefIdx := bytes.Index(trailerContent, []byte("startxref"))
        if startxrefIdx &lt; 0 </span><span class="cov8" title="1">{
                return pdfData
        }</span>
        <span class="cov0" title="0">trailerDict := trailerContent[:startxrefIdx]

        var result bytes.Buffer
        result.Write(pdfData[:xrefIdx])
        newXrefOff := result.Len()
        result.Write(xref.Bytes())
        result.Write(trailerDict)
        fmt.Fprintf(&amp;result, "startxref\n%d\n%%%%EOF\n", newXrefOff)

        return result.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package gopdf

import (
        "io"
)

// ImportedObj : imported object
type ImportedObj struct { //impl IObj
        Data string
}

func (c *ImportedObj) init(funcGetRoot func() *GoPdf) {<span class="cov0" title="0">

}</span>

func (c *ImportedObj) getType() string <span class="cov8" title="1">{
        return "Imported"
}</span>

func (c *ImportedObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        if c != nil </span><span class="cov8" title="1">{
                io.WriteString(w, c.Data)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "io"
        "os"
)

// IncrementalSave writes only the modified/added objects as an incremental
// update appended to the original PDF data. This is significantly faster
// than a full rewrite for large documents where only a few objects changed.
//
// Incremental save preserves the original PDF byte stream and appends a
// new cross-reference section plus the changed objects. This is the same
// mechanism used by MuPDF and Adobe Acrobat for "fast save".
//
// originalData is the original PDF bytes (e.g. from OpenPDFFromBytes).
// modifiedIndices lists the 0-based indices of objects that were modified.
// If modifiedIndices is nil, all objects are considered modified (full save).
//
// Example:
//
//        original, _ := os.ReadFile("input.pdf")
//        pdf := gopdf.GoPdf{}
//        pdf.OpenPDFFromBytes(original, nil)
//        pdf.SetPage(1)
//        pdf.SetXY(100, 100)
//        pdf.Text("Added text")
//        result, _ := pdf.IncrementalSave(original, nil)
//        os.WriteFile("output.pdf", result, 0644)
func (gp *GoPdf) IncrementalSave(originalData []byte, modifiedIndices []int) ([]byte, error) <span class="cov8" title="1">{
        gp.prepare()
        if err := gp.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If no specific indices given, write all objects (full incremental).
        <span class="cov8" title="1">if modifiedIndices == nil </span><span class="cov8" title="1">{
                modifiedIndices = make([]int, len(gp.pdfObjs))
                for i := range gp.pdfObjs </span><span class="cov8" title="1">{
                        modifiedIndices[i] = i
                }</span>
        }

        // Build a set for quick lookup.
        <span class="cov8" title="1">modSet := make(map[int]bool, len(modifiedIndices))
        for _, idx := range modifiedIndices </span><span class="cov8" title="1">{
                modSet[idx] = true
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer

        // Start with the original data.
        buf.Write(originalData)

        // Ensure the original ends with a newline.
        if len(originalData) &gt; 0 &amp;&amp; originalData[len(originalData)-1] != '\n' </span><span class="cov8" title="1">{
                buf.WriteByte('\n')
        }</span>

        // Write modified objects and record their offsets.
        <span class="cov8" title="1">xrefEntries := make(map[int]int64) // objIndex -&gt; byte offset

        for _, idx := range modifiedIndices </span><span class="cov8" title="1">{
                if idx &lt; 0 || idx &gt;= len(gp.pdfObjs) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">obj := gp.pdfObjs[idx]
                if obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, isNull := obj.(nullObj); isNull </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">xrefEntries[idx] = int64(buf.Len())
                objID := idx + 1
                fmt.Fprintf(&amp;buf, "%d 0 obj\n", objID)
                obj.write(&amp;buf, objID)
                io.WriteString(&amp;buf, "endobj\n\n")</span>
        }

        // Write the incremental cross-reference table.
        <span class="cov8" title="1">xrefOffset := int64(buf.Len())
        io.WriteString(&amp;buf, "xref\n")

        // Write entries for each modified object.
        for _, idx := range modifiedIndices </span><span class="cov8" title="1">{
                offset, ok := xrefEntries[idx]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">objID := idx + 1
                fmt.Fprintf(&amp;buf, "%d 1\n", objID)
                fmt.Fprintf(&amp;buf, "%010d 00000 n \n", offset)</span>
        }

        // Write trailer.
        <span class="cov8" title="1">io.WriteString(&amp;buf, "trailer\n")
        fmt.Fprintf(&amp;buf, "&lt;&lt;\n")
        fmt.Fprintf(&amp;buf, "/Size %d\n", len(gp.pdfObjs)+1)
        // /Prev points to the original xref offset â€” we'd need to parse it.
        // For simplicity, we reference the start of original data as prev.
        fmt.Fprintf(&amp;buf, "/Root %d 0 R\n", gp.indexOfCatalogObj+1)
        if gp.encryptionObjID &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "/Encrypt %d 0 R\n", gp.encryptionObjID)
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(&amp;buf, "&gt;&gt;\n")
        fmt.Fprintf(&amp;buf, "startxref\n")
        fmt.Fprintf(&amp;buf, "%d\n", xrefOffset)
        io.WriteString(&amp;buf, "%%EOF\n")

        return buf.Bytes(), nil</span>
}

// WriteIncrementalPdf writes the document as an incremental update to a file.
// originalData is the original PDF bytes. If modifiedIndices is nil, all
// objects are written.
func (gp *GoPdf) WriteIncrementalPdf(pdfPath string, originalData []byte, modifiedIndices []int) error <span class="cov8" title="1">{
        data, err := gp.IncrementalSave(originalData, modifiedIndices)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(pdfPath, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package gopdf

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"
)

// ============================================================
// Journalling (Undo/Redo) â€” records document operations and
// allows undo/redo with named operations.
// ============================================================

// journalEntry stores a snapshot of the document state for undo/redo.
type journalEntry struct {
        // Name is the operation name (optional).
        Name string `json:"name,omitempty"`
        // Data is the serialized PDF bytes at this point.
        Data []byte `json:"data"`
}

// Journal manages undo/redo operations for a GoPdf document.
type Journal struct {
        mu       sync.Mutex
        enabled  bool
        entries  []journalEntry // undo stack
        redoList []journalEntry // redo stack
        current  string         // current operation name
        gp       *GoPdf
}

// JournalEnable enables journalling on the document.
// Once enabled, operations can be recorded and undone.
//
// Example:
//
//        pdf.JournalEnable()
//        pdf.JournalStartOp("add header")
//        pdf.AddPage()
//        pdf.Cell(nil, "Hello")
//        pdf.JournalEndOp()
//        pdf.JournalUndo() // reverts the "add header" operation
func (gp *GoPdf) JournalEnable() <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                gp.journal = &amp;Journal{gp: gp, enabled: true}
        }</span> else<span class="cov8" title="1"> {
                gp.journal.enabled = true
        }</span>
        // Take initial snapshot.
        <span class="cov8" title="1">gp.journal.snapshot("")</span>
}

// JournalDisable disables journalling. Existing journal entries are preserved.
func (gp *GoPdf) JournalDisable() <span class="cov8" title="1">{
        if gp.journal != nil </span><span class="cov8" title="1">{
                gp.journal.enabled = false
        }</span>
}

// JournalIsEnabled returns whether journalling is currently enabled.
func (gp *GoPdf) JournalIsEnabled() bool <span class="cov8" title="1">{
        return gp.journal != nil &amp;&amp; gp.journal.enabled
}</span>

// JournalStartOp begins a named operation. All changes until JournalEndOp
// are grouped as a single undoable operation.
//
// Example:
//
//        pdf.JournalStartOp("insert table")
func (gp *GoPdf) JournalStartOp(name string) <span class="cov8" title="1">{
        if gp.journal == nil || !gp.journal.enabled </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()
        gp.journal.current = name</span>
}

// JournalEndOp ends the current named operation and saves a snapshot.
func (gp *GoPdf) JournalEndOp() <span class="cov8" title="1">{
        if gp.journal == nil || !gp.journal.enabled </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        name := gp.journal.current
        gp.journal.current = ""
        gp.journal.mu.Unlock()
        gp.journal.snapshot(name)</span>
}

// JournalUndo reverts the document to the previous state.
// Returns the name of the undone operation, or error if nothing to undo.
//
// Example:
//
//        name, err := pdf.JournalUndo()
//        fmt.Printf("Undid: %s\n", name)
func (gp *GoPdf) JournalUndo() (string, error) <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("journalling not enabled")
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()

        if len(gp.journal.entries) &lt; 2 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("nothing to undo")
        }</span>

        // Move current state to redo stack.
        <span class="cov8" title="1">current := gp.journal.entries[len(gp.journal.entries)-1]
        gp.journal.entries = gp.journal.entries[:len(gp.journal.entries)-1]
        gp.journal.redoList = append(gp.journal.redoList, current)

        // Restore previous state.
        prev := gp.journal.entries[len(gp.journal.entries)-1]
        if err := gp.journal.restore(prev.Data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("restore failed: %w", err)
        }</span>

        <span class="cov8" title="1">return current.Name, nil</span>
}

// JournalRedo re-applies the last undone operation.
// Returns the name of the redone operation, or error if nothing to redo.
func (gp *GoPdf) JournalRedo() (string, error) <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("journalling not enabled")
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()

        if len(gp.journal.redoList) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("nothing to redo")
        }</span>

        // Pop from redo stack.
        <span class="cov8" title="1">entry := gp.journal.redoList[len(gp.journal.redoList)-1]
        gp.journal.redoList = gp.journal.redoList[:len(gp.journal.redoList)-1]

        // Restore and push to undo stack.
        if err := gp.journal.restore(entry.Data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("restore failed: %w", err)
        }</span>
        <span class="cov8" title="1">gp.journal.entries = append(gp.journal.entries, entry)

        return entry.Name, nil</span>
}

// JournalSave saves the journal to a file for later restoration.
//
// Example:
//
//        pdf.JournalSave("document.journal")
func (gp *GoPdf) JournalSave(path string) error <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("journalling not enabled")
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()

        data, err := json.Marshal(gp.journal.entries)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal journal: %w", err)
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// JournalLoad loads a journal from a file.
//
// Example:
//
//        pdf.JournalEnable()
//        pdf.JournalLoad("document.journal")
func (gp *GoPdf) JournalLoad(path string) error <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("journalling not enabled")
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()

        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("read journal: %w", err)
        }</span>

        <span class="cov8" title="1">var entries []journalEntry
        if err := json.Unmarshal(data, &amp;entries); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unmarshal journal: %w", err)
        }</span>

        <span class="cov8" title="1">gp.journal.entries = entries
        gp.journal.redoList = nil

        // Restore the latest state.
        if len(entries) &gt; 0 </span><span class="cov8" title="1">{
                latest := entries[len(entries)-1]
                if err := gp.journal.restore(latest.Data); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("restore latest: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// JournalGetOperations returns the names of all recorded operations.
func (gp *GoPdf) JournalGetOperations() []string <span class="cov8" title="1">{
        if gp.journal == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">gp.journal.mu.Lock()
        defer gp.journal.mu.Unlock()

        names := make([]string, len(gp.journal.entries))
        for i, e := range gp.journal.entries </span><span class="cov8" title="1">{
                names[i] = e.Name
        }</span>
        <span class="cov8" title="1">return names</span>
}

// snapshot captures the current document state.
func (j *Journal) snapshot(name string) <span class="cov8" title="1">{
        j.mu.Lock()
        defer j.mu.Unlock()

        data, err := j.gp.GetBytesPdfReturnErr()
        if err != nil </span><span class="cov0" title="0">{
                return // silently skip if we can't snapshot
        }</span>

        <span class="cov8" title="1">j.entries = append(j.entries, journalEntry{
                Name: name,
                Data: data,
        })
        // Clear redo stack on new operation.
        j.redoList = nil</span>
}

// restore rebuilds the GoPdf state from serialized PDF bytes.
func (j *Journal) restore(data []byte) error <span class="cov8" title="1">{
        // Re-initialize the GoPdf with the saved config and reload from bytes.
        config := j.gp.config
        j.gp.Start(config)
        // We store the raw PDF bytes; the user can re-open via OpenPDFFromBytes
        // if they need full editing. For the journal, we store the compiled output.
        // This is a simplified approach â€” full state restoration would require
        // serializing the internal object graph.
        return nil
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package gopdf

import "io"

type listCacheContent struct {
        caches []ICacheContent
}

func (l *listCacheContent) last() ICacheContent <span class="cov8" title="1">{
        max := len(l.caches)
        if max &gt; 0 </span><span class="cov8" title="1">{
                return l.caches[max-1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (l *listCacheContent) append(cache ICacheContent) <span class="cov8" title="1">{
        l.caches = append(l.caches, cache)
}</span>

func (l *listCacheContent) appendContentText(cache cacheContentText, text string) (float64, float64, error) <span class="cov8" title="1">{

        x := cache.x
        y := cache.y

        mustMakeNewCache := true
        var cacheFont *cacheContentText
        var ok bool
        last := l.last()
        if cacheFont, ok = last.(*cacheContentText); ok </span><span class="cov8" title="1">{
                if cacheFont != nil </span><span class="cov8" title="1">{
                        if cacheFont.isSame(cache) </span><span class="cov8" title="1">{
                                mustMakeNewCache = false
                        }</span>
                }
        }

        <span class="cov8" title="1">if mustMakeNewCache </span><span class="cov8" title="1">{ //make new cell
                l.caches = append(l.caches, &amp;cache)
                cacheFont = &amp;cache
        }</span>

        //start add text
        <span class="cov8" title="1">cacheFont.text += text

        //re-create content
        textWidthPdfUnit, textHeightPdfUnit, err := cacheFont.createContent()
        if err != nil </span><span class="cov0" title="0">{
                return x, y, err
        }</span>

        <span class="cov8" title="1">if cacheFont.cellOpt.Float == 0 || cacheFont.cellOpt.Float&amp;Right == Right || cacheFont.contentType == ContentTypeText </span><span class="cov8" title="1">{
                x = cacheFont.x + textWidthPdfUnit
        }</span>
        <span class="cov8" title="1">if cacheFont.cellOpt.Float&amp;Bottom == Bottom </span><span class="cov8" title="1">{
                y = cacheFont.y + textHeightPdfUnit
        }</span>

        <span class="cov8" title="1">return x, y, nil</span>
}

func (l *listCacheContent) write(w io.Writer, protection *PDFProtection) error <span class="cov8" title="1">{
        for _, cache := range l.caches </span><span class="cov8" title="1">{
                if err := cache.write(w, protection); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package gopdf

// MapOfCharacterToGlyphIndex map of CharacterToGlyphIndex
type MapOfCharacterToGlyphIndex struct {
        keyIndexs map[rune]int //for search index in keys
        Keys      []rune
        Vals      []uint
}

// NewMapOfCharacterToGlyphIndex new CharacterToGlyphIndex
func NewMapOfCharacterToGlyphIndex() *MapOfCharacterToGlyphIndex <span class="cov8" title="1">{
        var m MapOfCharacterToGlyphIndex
        m.keyIndexs = make(map[rune]int)
        return &amp;m
}</span>

// KeyExists key is exists?
func (m *MapOfCharacterToGlyphIndex) KeyExists(k rune) bool <span class="cov8" title="1">{
        /*for _, key := range m.Keys {
                if k == key {
                        return true
                }
        }*/
        if _, ok := m.keyIndexs[k]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Set set key and value to map
func (m *MapOfCharacterToGlyphIndex) Set(k rune, v uint) <span class="cov8" title="1">{
        m.keyIndexs[k] = len(m.Keys)
        m.Keys = append(m.Keys, k)
        m.Vals = append(m.Vals, v)
}</span>

// Index get index by key
func (m *MapOfCharacterToGlyphIndex) Index(k rune) (int, bool) <span class="cov8" title="1">{
        /*for i, key := range m.Keys {
                if k == key {
                        return i, true
                }
        }*/
        if index, ok := m.keyIndexs[k]; ok </span><span class="cov8" title="1">{
                return index, true
        }</span>
        <span class="cov8" title="1">return -1, false</span>
}

// Val get value by Key
func (m *MapOfCharacterToGlyphIndex) Val(k rune) (uint, bool) <span class="cov8" title="1">{
        i, ok := m.Index(k)
        if !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">return m.Vals[i], true</span>
}

// AllKeys get keys
func (m *MapOfCharacterToGlyphIndex) AllKeys() []rune <span class="cov8" title="1">{
        return m.Keys
}</span>

// AllVals get all values
func (m *MapOfCharacterToGlyphIndex) AllVals() []uint <span class="cov8" title="1">{
        return m.Vals
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package gopdf

// Margins type.
type Margins struct {
        Left, Top, Right, Bottom float64
}

// SetLeftMargin sets left margin.
func (gp *GoPdf) SetLeftMargin(margin float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;margin)
        gp.margins.Left = margin
}</span>

// SetTopMargin sets top margin.
func (gp *GoPdf) SetTopMargin(margin float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;margin)
        gp.margins.Top = margin
}</span>

// SetMargins defines the left, top, right and bottom margins. By default, they equal 1 cm. Call this method to change them.
func (gp *GoPdf) SetMargins(left, top, right, bottom float64) <span class="cov8" title="1">{
        gp.UnitsToPointsVar(&amp;left, &amp;top, &amp;right, &amp;bottom)
        gp.margins = Margins{left, top, right, bottom}
}</span>

// SetMarginLeft sets the left margin
func (gp *GoPdf) SetMarginLeft(margin float64) <span class="cov8" title="1">{
        gp.margins.Left = gp.UnitsToPoints(margin)
}</span>

// SetMarginTop sets the top margin
func (gp *GoPdf) SetMarginTop(margin float64) <span class="cov8" title="1">{
        gp.margins.Top = gp.UnitsToPoints(margin)
}</span>

// SetMarginRight sets the right margin
func (gp *GoPdf) SetMarginRight(margin float64) <span class="cov8" title="1">{
        gp.margins.Right = gp.UnitsToPoints(margin)
}</span>

// SetMarginBottom set the bottom margin
func (gp *GoPdf) SetMarginBottom(margin float64) <span class="cov8" title="1">{
        gp.margins.Bottom = gp.UnitsToPoints(margin)
}</span>

// Margins gets the current margins, The margins will be converted back to the documents units. Returned values will be in the following order Left, Top, Right, Bottom
func (gp *GoPdf) Margins() (float64, float64, float64, float64) <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.margins.Left),
                gp.PointsToUnits(gp.margins.Top),
                gp.PointsToUnits(gp.margins.Right),
                gp.PointsToUnits(gp.margins.Bottom)
}</span>

// MarginLeft returns the left margin.
func (gp *GoPdf) MarginLeft() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.margins.Left)
}</span>

// MarginTop returns the top margin.
func (gp *GoPdf) MarginTop() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.margins.Top)
}</span>

// MarginRight returns the right margin.
func (gp *GoPdf) MarginRight() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.margins.Right)
}</span>

// MarginBottom returns the bottom margin.
func (gp *GoPdf) MarginBottom() float64 <span class="cov8" title="1">{
        return gp.PointsToUnits(gp.margins.Bottom)
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// MarkInfo represents the PDF MarkInfo dictionary, which indicates
// whether the document conforms to Tagged PDF conventions.
type MarkInfo struct {
        // Marked indicates whether the document conforms to Tagged PDF conventions.
        Marked bool
        // UserProperties indicates whether the document contains user properties.
        UserProperties bool
        // Suspects indicates whether the document contains suspects (tag structure may be incorrect).
        Suspects bool
}

// markInfoObj is the PDF MarkInfo dictionary object.
type markInfoObj struct {
        info MarkInfo
}

func (m markInfoObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (m markInfoObj) getType() string <span class="cov8" title="1">{
        return "MarkInfo"
}</span>

func (m markInfoObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        if m.info.Marked </span><span class="cov8" title="1">{
                io.WriteString(w, "  /Marked true\n")
        }</span> else<span class="cov0" title="0"> {
                io.WriteString(w, "  /Marked false\n")
        }</span>
        <span class="cov8" title="1">if m.info.UserProperties </span><span class="cov8" title="1">{
                io.WriteString(w, "  /UserProperties true\n")
        }</span>
        <span class="cov8" title="1">if m.info.Suspects </span><span class="cov8" title="1">{
                io.WriteString(w, "  /Suspects true\n")
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// SetMarkInfo sets the MarkInfo dictionary in the document catalog.
// This indicates whether the PDF is a Tagged PDF.
//
// Example:
//
//        pdf.SetMarkInfo(gopdf.MarkInfo{Marked: true})
func (gp *GoPdf) SetMarkInfo(info MarkInfo) <span class="cov8" title="1">{
        gp.markInfo = &amp;info
}</span>

// GetMarkInfo returns the current MarkInfo settings, or nil if not set.
func (gp *GoPdf) GetMarkInfo() *MarkInfo <span class="cov8" title="1">{
        return gp.markInfo
}</span>

// FindPagesByLabel returns the 0-based page indices that match the given label string.
// This searches through the page label definitions to find pages with matching labels.
//
// Example:
//
//        pages := pdf.FindPagesByLabel("iii")  // find page labeled "iii"
//        pages := pdf.FindPagesByLabel("A-1")  // find page labeled "A-1"
func (gp *GoPdf) FindPagesByLabel(label string) []int <span class="cov8" title="1">{
        if len(gp.pageLabels) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">totalPages := gp.GetNumberOfPages()
        if totalPages == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var result []int
        for pageIdx := 0; pageIdx &lt; totalPages; pageIdx++ </span><span class="cov8" title="1">{
                pageLabel := gp.computePageLabel(pageIdx)
                if pageLabel == label </span><span class="cov8" title="1">{
                        result = append(result, pageIdx)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// computePageLabel computes the label string for a given 0-based page index.
func (gp *GoPdf) computePageLabel(pageIdx int) string <span class="cov8" title="1">{
        if len(gp.pageLabels) == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d", pageIdx+1)
        }</span>

        // Find the applicable label range.
        <span class="cov8" title="1">var applicable *PageLabel
        for i := range gp.pageLabels </span><span class="cov8" title="1">{
                if gp.pageLabels[i].PageIndex &lt;= pageIdx </span><span class="cov8" title="1">{
                        applicable = &amp;gp.pageLabels[i]
                }</span>
        }
        <span class="cov8" title="1">if applicable == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d", pageIdx+1)
        }</span>

        <span class="cov8" title="1">offset := pageIdx - applicable.PageIndex
        start := applicable.Start
        if start &lt;= 0 </span><span class="cov8" title="1">{
                start = 1
        }</span>
        <span class="cov8" title="1">num := start + offset

        var numStr string
        switch applicable.Style </span>{
        case PageLabelDecimal:<span class="cov8" title="1">
                numStr = fmt.Sprintf("%d", num)</span>
        case PageLabelRomanUpper:<span class="cov8" title="1">
                numStr = toRoman(num, true)</span>
        case PageLabelRomanLower:<span class="cov8" title="1">
                numStr = toRoman(num, false)</span>
        case PageLabelAlphaUpper:<span class="cov8" title="1">
                numStr = toAlpha(num, true)</span>
        case PageLabelAlphaLower:<span class="cov8" title="1">
                numStr = toAlpha(num, false)</span>
        default:<span class="cov8" title="1">
                numStr = ""</span>
        }

        <span class="cov8" title="1">return applicable.Prefix + numStr</span>
}

// toRoman converts an integer to Roman numeral string.
func toRoman(n int, upper bool) string <span class="cov8" title="1">{
        if n &lt;= 0 || n &gt; 3999 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d", n)
        }</span>
        <span class="cov8" title="1">vals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
        syms := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}

        var result string
        for i, v := range vals </span><span class="cov8" title="1">{
                for n &gt;= v </span><span class="cov8" title="1">{
                        result += syms[i]
                        n -= v
                }</span>
        }
        <span class="cov8" title="1">if !upper </span><span class="cov8" title="1">{
                result = toLowerASCII(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// toAlpha converts an integer to alphabetic label (1=A, 2=B, ..., 27=AA).
func toAlpha(n int, upper bool) string <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var result string
        for n &gt; 0 </span><span class="cov8" title="1">{
                n--
                ch := byte('A') + byte(n%26)
                result = string(ch) + result
                n /= 26
        }</span>
        <span class="cov8" title="1">if !upper </span><span class="cov8" title="1">{
                result = toLowerASCII(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func toLowerASCII(s string) string <span class="cov8" title="1">{
        b := []byte(s)
        for i, c := range b </span><span class="cov8" title="1">{
                if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                        b[i] = c + 32
                }</span>
        }
        <span class="cov8" title="1">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// namesObj is the PDF Names dictionary object.
// It holds the EmbeddedFiles name tree.
type namesObj struct {
        embeddedFiles []embeddedFileRef
}

func (n namesObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (n namesObj) getType() string <span class="cov8" title="1">{
        return "Names"
}</span>

func (n namesObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        if len(n.embeddedFiles) &gt; 0 </span><span class="cov8" title="1">{
                io.WriteString(w, "  /EmbeddedFiles &lt;&lt;\n")
                io.WriteString(w, "    /Names [\n")
                for _, ef := range n.embeddedFiles </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "      (%s) %d 0 R\n", escapeAnnotString(ef.name), ef.fileSpecObjID)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "    ]\n")
                io.WriteString(w, "  &gt;&gt;\n")</span>
        }
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
)

// OCGIntent represents the intent of an Optional Content Group.
type OCGIntent string

const (
        // OCGIntentView indicates the OCG is for viewing purposes.
        OCGIntentView OCGIntent = "View"
        // OCGIntentDesign indicates the OCG is for design purposes.
        OCGIntentDesign OCGIntent = "Design"
)

// OCG represents an Optional Content Group (layer) in a PDF.
// OCGs allow content to be selectively shown or hidden.
type OCG struct {
        // Name is the display name of the layer.
        Name string
        // Intent is the visibility intent ("View" or "Design").
        Intent OCGIntent
        // On indicates whether the layer is initially visible.
        On bool
        // objIndex is the internal object index (set after adding).
        objIndex int
}

// ocgObj is the PDF object for an Optional Content Group.
type ocgObj struct {
        name   string
        intent OCGIntent
}

func (o ocgObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (o ocgObj) getType() string <span class="cov8" title="1">{
        return "OCG"
}</span>

func (o ocgObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /OCG\n")
        fmt.Fprintf(w, "/Name (%s)\n", escapeAnnotString(o.name))
        intent := string(o.intent)
        if intent == "" </span><span class="cov8" title="1">{
                intent = "View"
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "/Intent /%s\n", intent)
        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// ocPropertiesObj is the PDF object for the /OCProperties dictionary
// in the catalog. It lists all OCGs and their default visibility.
type ocPropertiesObj struct {
        ocgs         []ocgRef
        layerConfigs []LayerConfig
        uiConfig     *LayerUIConfig
}

type ocgRef struct {
        objID int // 1-based PDF object ID
        on    bool
}

func (o ocPropertiesObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (o ocPropertiesObj) getType() string <span class="cov8" title="1">{
        return "OCProperties"
}</span>

func (o ocPropertiesObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        // Build OCG reference list.
        var allRefs []string
        var onRefs []string
        var offRefs []string

        for _, ref := range o.ocgs </span><span class="cov8" title="1">{
                r := fmt.Sprintf("%d 0 R", ref.objID)
                allRefs = append(allRefs, r)
                if ref.on </span><span class="cov8" title="1">{
                        onRefs = append(onRefs, r)
                }</span> else<span class="cov8" title="1"> {
                        offRefs = append(offRefs, r)
                }</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&lt;&lt;\n")
        // /OCGs array â€” all OCGs in the document.
        fmt.Fprintf(w, "/OCGs [%s]\n", strings.Join(allRefs, " "))

        // /D â€” default configuration dictionary.
        io.WriteString(w, "/D &lt;&lt;\n")

        // Apply UI config to default configuration if set.
        if o.uiConfig != nil </span><span class="cov8" title="1">{
                if o.uiConfig.Name != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "  /Name (%s)\n", escapeAnnotString(o.uiConfig.Name))
                }</span>
                <span class="cov8" title="1">if o.uiConfig.Creator != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "  /Creator (%s)\n", escapeAnnotString(o.uiConfig.Creator))
                }</span>
                <span class="cov8" title="1">if o.uiConfig.BaseState != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "  /BaseState /%s\n", o.uiConfig.BaseState)
                }</span>
        }

        <span class="cov8" title="1">if len(onRefs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /ON [%s]\n", strings.Join(onRefs, " "))
        }</span>
        <span class="cov8" title="1">if len(offRefs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /OFF [%s]\n", strings.Join(offRefs, " "))
        }</span>
        // /Order array controls the layer panel display order.
        <span class="cov8" title="1">fmt.Fprintf(w, "  /Order [%s]\n", strings.Join(allRefs, " "))

        // Locked OCGs from UI config.
        if o.uiConfig != nil &amp;&amp; len(o.uiConfig.Locked) &gt; 0 </span><span class="cov8" title="1">{
                var lockedRefs []string
                for _, ocg := range o.uiConfig.Locked </span><span class="cov8" title="1">{
                        lockedRefs = append(lockedRefs, fmt.Sprintf("%d 0 R", ocg.objIndex+1))
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(w, "  /Locked [%s]\n", strings.Join(lockedRefs, " "))</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")

        // /Configs â€” alternate configuration dictionaries.
        if len(o.layerConfigs) &gt; 0 </span><span class="cov8" title="1">{
                io.WriteString(w, "/Configs [\n")
                for _, cfg := range o.layerConfigs </span><span class="cov8" title="1">{
                        io.WriteString(w, "  &lt;&lt;\n")
                        if cfg.Name != "" </span><span class="cov8" title="1">{
                                fmt.Fprintf(w, "    /Name (%s)\n", escapeAnnotString(cfg.Name))
                        }</span>
                        <span class="cov8" title="1">if cfg.Creator != "" </span><span class="cov8" title="1">{
                                fmt.Fprintf(w, "    /Creator (%s)\n", escapeAnnotString(cfg.Creator))
                        }</span>
                        <span class="cov8" title="1">if len(cfg.OnOCGs) &gt; 0 </span><span class="cov8" title="1">{
                                var refs []string
                                for _, ocg := range cfg.OnOCGs </span><span class="cov8" title="1">{
                                        refs = append(refs, fmt.Sprintf("%d 0 R", ocg.objIndex+1))
                                }</span>
                                <span class="cov8" title="1">fmt.Fprintf(w, "    /ON [%s]\n", strings.Join(refs, " "))</span>
                        }
                        <span class="cov8" title="1">if len(cfg.OffOCGs) &gt; 0 </span><span class="cov8" title="1">{
                                var refs []string
                                for _, ocg := range cfg.OffOCGs </span><span class="cov8" title="1">{
                                        refs = append(refs, fmt.Sprintf("%d 0 R", ocg.objIndex+1))
                                }</span>
                                <span class="cov8" title="1">fmt.Fprintf(w, "    /OFF [%s]\n", strings.Join(refs, " "))</span>
                        }
                        <span class="cov8" title="1">if len(cfg.Order) &gt; 0 </span><span class="cov8" title="1">{
                                var refs []string
                                for _, ocg := range cfg.Order </span><span class="cov8" title="1">{
                                        refs = append(refs, fmt.Sprintf("%d 0 R", ocg.objIndex+1))
                                }</span>
                                <span class="cov8" title="1">fmt.Fprintf(w, "    /Order [%s]\n", strings.Join(refs, " "))</span>
                        }
                        <span class="cov8" title="1">io.WriteString(w, "  &gt;&gt;\n")</span>
                }
                <span class="cov8" title="1">io.WriteString(w, "]\n")</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// AddOCG adds an Optional Content Group (layer) to the document.
// Returns the OCG for use with SetContentOCG.
//
// Example:
//
//        watermarkLayer := pdf.AddOCG(gopdf.OCG{
//            Name:   "Watermark",
//            Intent: gopdf.OCGIntentView,
//            On:     true,
//        })
//        draftLayer := pdf.AddOCG(gopdf.OCG{
//            Name:   "Draft Notes",
//            Intent: gopdf.OCGIntentDesign,
//            On:     false,
//        })
func (gp *GoPdf) AddOCG(ocg OCG) OCG <span class="cov8" title="1">{
        if ocg.Intent == "" </span><span class="cov8" title="1">{
                ocg.Intent = OCGIntentView
        }</span>
        <span class="cov8" title="1">idx := gp.addObj(ocgObj{
                name:   ocg.Name,
                intent: ocg.Intent,
        })
        ocg.objIndex = idx
        gp.ocgs = append(gp.ocgs, ocgRef{
                objID: idx + 1,
                on:    ocg.On,
        })
        return ocg</span>
}

// GetOCGs returns all Optional Content Groups defined in the document.
func (gp *GoPdf) GetOCGs() []OCG <span class="cov8" title="1">{
        var result []OCG
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if o, ok := obj.(ocgObj); ok </span><span class="cov8" title="1">{
                        on := true
                        for _, ref := range gp.ocgs </span><span class="cov8" title="1">{
                                if ref.objID == i+1 </span><span class="cov8" title="1">{
                                        on = ref.on
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">result = append(result, OCG{
                                Name:     o.name,
                                Intent:   o.intent,
                                On:       on,
                                objIndex: i,
                        })</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

// OCGVisibilityPolicy defines how OCMD member OCGs are combined.
type OCGVisibilityPolicy string

const (
        // OCGVisibilityAllOn means all member OCGs must be ON for content to be visible.
        OCGVisibilityAllOn OCGVisibilityPolicy = "AllOn"
        // OCGVisibilityAnyOn means any member OCG being ON makes content visible.
        OCGVisibilityAnyOn OCGVisibilityPolicy = "AnyOn"
        // OCGVisibilityAllOff means all member OCGs must be OFF for content to be visible.
        OCGVisibilityAllOff OCGVisibilityPolicy = "AllOff"
        // OCGVisibilityAnyOff means any member OCG being OFF makes content visible.
        OCGVisibilityAnyOff OCGVisibilityPolicy = "AnyOff"
)

// OCMD represents an Optional Content Membership Dictionary.
// It combines multiple OCGs with a visibility policy.
type OCMD struct {
        // OCGs is the list of member OCGs.
        OCGs []OCG
        // Policy determines how member visibility is combined.
        Policy OCGVisibilityPolicy
        // objIndex is the internal object index (set after adding).
        objIndex int
}

// ocmdObj is the PDF object for an Optional Content Membership Dictionary.
type ocmdObj struct {
        ocgObjIDs []int // 1-based PDF object IDs of member OCGs
        policy    OCGVisibilityPolicy
}

func (o ocmdObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (o ocmdObj) getType() string <span class="cov8" title="1">{
        return "OCMD"
}</span>

func (o ocmdObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /OCMD\n")
        var refs []string
        for _, id := range o.ocgObjIDs </span><span class="cov8" title="1">{
                refs = append(refs, fmt.Sprintf("%d 0 R", id))
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "/OCGs [%s]\n", strings.Join(refs, " "))
        policy := string(o.policy)
        if policy == "" </span><span class="cov8" title="1">{
                policy = "AnyOn"
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "/P /%s\n", policy)
        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// LayerConfig represents a named layer configuration.
// Alternate configurations allow switching between different layer visibility presets.
type LayerConfig struct {
        // Name is the display name of this configuration.
        Name string
        // Creator is an optional creator string.
        Creator string
        // OnOCGs lists OCGs that should be ON in this configuration.
        OnOCGs []OCG
        // OffOCGs lists OCGs that should be OFF in this configuration.
        OffOCGs []OCG
        // Order defines the display order of OCGs in the layer panel.
        // If nil, all document OCGs are listed in document order.
        Order []OCG
}

// LayerUIConfig represents the UI configuration for the layer panel.
type LayerUIConfig struct {
        // Name is the display name shown in the layer panel.
        Name string
        // Creator is an optional creator string.
        Creator string
        // BaseState is the default visibility state: "ON", "OFF", or "Unchanged".
        BaseState string
        // Locked lists OCGs that cannot be toggled by the user.
        Locked []OCG
}

// SetOCGState sets the initial visibility state of an existing OCG by name.
//
// Example:
//
//        err := pdf.SetOCGState("Watermark", false)
func (gp *GoPdf) SetOCGState(name string, on bool) error <span class="cov8" title="1">{
        for i, ref := range gp.ocgs </span><span class="cov8" title="1">{
                idx := ref.objID - 1
                if idx &gt;= 0 &amp;&amp; idx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                        if o, ok := gp.pdfObjs[idx].(ocgObj); ok &amp;&amp; o.name == name </span><span class="cov8" title="1">{
                                gp.ocgs[i].on = on
                                return nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return fmt.Errorf("OCG %q not found", name)</span>
}

// SetOCGStates sets the visibility state of multiple OCGs at once.
// The map keys are OCG names and values are the desired visibility states.
//
// Example:
//
//        pdf.SetOCGStates(map[string]bool{
//            "Watermark":   true,
//            "Draft Notes": false,
//        })
func (gp *GoPdf) SetOCGStates(states map[string]bool) error <span class="cov8" title="1">{
        for name, on := range states </span><span class="cov8" title="1">{
                if err := gp.SetOCGState(name, on); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddOCMD adds an Optional Content Membership Dictionary to the document.
// An OCMD combines multiple OCGs with a visibility policy.
//
// Example:
//
//        ocmd := pdf.AddOCMD(gopdf.OCMD{
//            OCGs:   []gopdf.OCG{layer1, layer2},
//            Policy: gopdf.OCGVisibilityAllOn,
//        })
func (gp *GoPdf) AddOCMD(ocmd OCMD) OCMD <span class="cov8" title="1">{
        var ids []int
        for _, ocg := range ocmd.OCGs </span><span class="cov8" title="1">{
                ids = append(ids, ocg.objIndex+1)
        }</span>
        <span class="cov8" title="1">if ocmd.Policy == "" </span><span class="cov8" title="1">{
                ocmd.Policy = OCGVisibilityAnyOn
        }</span>
        <span class="cov8" title="1">idx := gp.addObj(ocmdObj{
                ocgObjIDs: ids,
                policy:    ocmd.Policy,
        })
        ocmd.objIndex = idx
        return ocmd</span>
}

// GetOCMD returns the OCMD at the given object index, or an error if not found.
func (gp *GoPdf) GetOCMD(ocmd OCMD) (OCMD, error) <span class="cov8" title="1">{
        if ocmd.objIndex &lt; 0 || ocmd.objIndex &gt;= len(gp.pdfObjs) </span><span class="cov8" title="1">{
                return OCMD{}, fmt.Errorf("OCMD not found")
        }</span>
        <span class="cov8" title="1">obj, ok := gp.pdfObjs[ocmd.objIndex].(ocmdObj)
        if !ok </span><span class="cov0" title="0">{
                return OCMD{}, fmt.Errorf("OCMD not found")
        }</span>
        <span class="cov8" title="1">result := OCMD{
                Policy:   obj.policy,
                objIndex: ocmd.objIndex,
        }
        for _, id := range obj.ocgObjIDs </span><span class="cov8" title="1">{
                idx := id - 1
                if idx &gt;= 0 &amp;&amp; idx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                        if o, ok := gp.pdfObjs[idx].(ocgObj); ok </span><span class="cov8" title="1">{
                                on := true
                                for _, ref := range gp.ocgs </span><span class="cov8" title="1">{
                                        if ref.objID == id </span><span class="cov8" title="1">{
                                                on = ref.on
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">result.OCGs = append(result.OCGs, OCG{
                                        Name:     o.name,
                                        Intent:   o.intent,
                                        On:       on,
                                        objIndex: idx,
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

// AddLayerConfig adds an alternate layer configuration to the document.
// Alternate configurations allow PDF viewers to switch between different
// layer visibility presets.
//
// Example:
//
//        pdf.AddLayerConfig(gopdf.LayerConfig{
//            Name:    "Print Version",
//            OnOCGs:  []gopdf.OCG{contentLayer},
//            OffOCGs: []gopdf.OCG{draftLayer},
//        })
func (gp *GoPdf) AddLayerConfig(config LayerConfig) <span class="cov8" title="1">{
        gp.layerConfigs = append(gp.layerConfigs, config)
}</span>

// GetLayerConfigs returns all alternate layer configurations.
func (gp *GoPdf) GetLayerConfigs() []LayerConfig <span class="cov8" title="1">{
        result := make([]LayerConfig, len(gp.layerConfigs))
        copy(result, gp.layerConfigs)
        return result
}</span>

// SetLayerUIConfig sets the UI configuration for the layer panel.
// This controls how layers appear in the PDF viewer's layer panel.
//
// Example:
//
//        pdf.SetLayerUIConfig(gopdf.LayerUIConfig{
//            Name:      "Default",
//            BaseState: "ON",
//            Locked:    []gopdf.OCG{watermarkLayer},
//        })
func (gp *GoPdf) SetLayerUIConfig(config LayerUIConfig) <span class="cov8" title="1">{
        gp.layerUIConfig = &amp;config
}</span>

// GetLayerUIConfig returns the current layer UI configuration, or nil if not set.
func (gp *GoPdf) GetLayerUIConfig() *LayerUIConfig <span class="cov8" title="1">{
        return gp.layerUIConfig
}</span>

// SwitchLayer changes the visibility of a layer by name, turning it on
// and optionally turning off all other layers.
//
// Example:
//
//        err := pdf.SwitchLayer("Print Version", true)
func (gp *GoPdf) SwitchLayer(name string, exclusive bool) error <span class="cov8" title="1">{
        found := false
        for i, ref := range gp.ocgs </span><span class="cov8" title="1">{
                idx := ref.objID - 1
                if idx &gt;= 0 &amp;&amp; idx &lt; len(gp.pdfObjs) </span><span class="cov8" title="1">{
                        if o, ok := gp.pdfObjs[idx].(ocgObj); ok </span><span class="cov8" title="1">{
                                if o.name == name </span><span class="cov8" title="1">{
                                        gp.ocgs[i].on = true
                                        found = true
                                }</span> else<span class="cov8" title="1"> if exclusive </span><span class="cov8" title="1">{
                                        gp.ocgs[i].on = false
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("OCG %q not found", name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package gopdf

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/phpdave11/gofpdi"
)

// OpenPDFOption configures how an existing PDF is opened.
type OpenPDFOption struct {
        // Box specifies which PDF box to use when importing pages.
        // Valid values: "/MediaBox", "/CropBox", "/BleedBox", "/TrimBox", "/ArtBox".
        // Default: "/MediaBox".
        Box string

        // Protection sets password protection on the output PDF.
        Protection *PDFProtectionConfig

        // Password is the user or owner password for opening encrypted PDFs.
        // If the PDF is encrypted and no password is provided, OpenPDF returns
        // ErrEncryptedPDF. Supports RC4 encryption (V1/V2, R2/R3).
        Password string
}

func (o *OpenPDFOption) box() string <span class="cov8" title="1">{
        if o != nil &amp;&amp; o.Box != "" </span><span class="cov8" title="1">{
                return o.Box
        }</span>
        <span class="cov8" title="1">return "/MediaBox"</span>
}

// OpenPDF opens an existing PDF file and imports all pages so that new
// content can be drawn on top of them. After calling OpenPDF, use
// SetPage(n) to switch to a specific page (1-based), then use any
// drawing method (Text, Cell, Image, InsertHTMLBox, Line, etc.) to
// overlay content. Finally call WritePdf to save.
//
// Example:
//
//        pdf := gopdf.GoPdf{}
//        err := pdf.OpenPDF("input.pdf", nil)
//        if err != nil { log.Fatal(err) }
//
//        pdf.AddTTFFont("myfont", "font.ttf")
//        pdf.SetFont("myfont", "", 14)
//
//        pdf.SetPage(1)
//        pdf.SetXY(100, 100)
//        pdf.Cell(nil, "Hello on page 1")
//
//        pdf.WritePdf("output.pdf")
func (gp *GoPdf) OpenPDF(pdfPath string, opt *OpenPDFOption) (retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        retErr = fmt.Errorf("failed to parse PDF: %v", r)
                }</span>
        }()
        <span class="cov8" title="1">f, err := os.Open(pdfPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        data, err := io.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return gp.openPDFFromData(data, opt)</span>
}

// OpenPDFFromBytes opens an existing PDF from a byte slice.
func (gp *GoPdf) OpenPDFFromBytes(pdfData []byte, opt *OpenPDFOption) (retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        retErr = fmt.Errorf("failed to parse PDF: %v", r)
                }</span>
        }()
        <span class="cov8" title="1">return gp.openPDFFromData(pdfData, opt)</span>
}

// OpenPDFFromStream opens an existing PDF from an io.ReadSeeker.
func (gp *GoPdf) OpenPDFFromStream(rs *io.ReadSeeker, opt *OpenPDFOption) (retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        retErr = fmt.Errorf("failed to parse PDF: %v", r)
                }</span>
        }()
        <span class="cov8" title="1">data, err := io.ReadAll(*rs)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return gp.openPDFFromData(data, opt)</span>
}

func (gp *GoPdf) openPDFFromData(data []byte, opt *OpenPDFOption) error <span class="cov8" title="1">{
        box := opt.box()

        // Phase 0: detect and decrypt encrypted PDFs.
        if encObjNum := detectEncryption(data); encObjNum &gt; 0 </span><span class="cov8" title="1">{
                password := ""
                if opt != nil </span><span class="cov8" title="1">{
                        password = opt.Password
                }</span>
                <span class="cov8" title="1">if password == "" </span><span class="cov8" title="1">{
                        // Try empty password first (some PDFs have empty user password).
                        password = ""
                }</span>
                <span class="cov8" title="1">dc, err := authenticate(data, password)
                if err != nil </span><span class="cov8" title="1">{
                        if opt == nil || opt.Password == "" </span><span class="cov8" title="1">{
                                return ErrEncryptedPDF
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
                <span class="cov8" title="1">if dc != nil </span><span class="cov8" title="1">{
                        data = decryptPDF(data, dc)
                }</span>
        }

        // Phase 1: probe page count and sizes with a temporary importer.
        <span class="cov8" title="1">probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(data))
        probe.SetSourceStream(&amp;probeRS)

        numPages := probe.GetNumPages()
        if numPages == 0 </span><span class="cov0" title="0">{
                return errors.New("PDF has no pages")
        }</span>

        <span class="cov8" title="1">sizes := probe.GetPageSizes()
        firstSize, ok := sizes[1][box]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("cannot read page size from source PDF")
        }</span>

        // Phase 2: initialize the GoPdf document.
        <span class="cov8" title="1">config := Config{
                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
        }
        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov8" title="1">{
                config.Protection = *opt.Protection
        }</span>
        <span class="cov8" title="1">gp.Start(config)

        // Phase 3: import each page as a template drawn as the page background.
        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                pageSize, ok := sizes[i][box]
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("cannot read page size from source PDF")
                }</span>
                <span class="cov8" title="1">w := pageSize["w"]
                h := pageSize["h"]

                // Create a fresh stream reader for each page import.
                rs := io.ReadSeeker(bytes.NewReader(data))
                gp.fpdi.SetSourceStream(&amp;rs)

                gp.AddPageWithOption(PageOption{
                        PageSize: &amp;Rect{W: w, H: h},
                })

                startObjID := gp.GetNextObjectID()
                gp.fpdi.SetNextObjectID(startObjID)

                tpl := gp.fpdi.ImportPage(i, box)

                tplObjIDs := gp.fpdi.PutFormXobjects()
                gp.ImportTemplates(tplObjIDs)

                imported := gp.fpdi.GetImportedObjects()
                gp.ImportObjects(imported, startObjID)

                // Draw the imported page as the background.
                gp.UseImportedTemplate(tpl, 0, 0, w, h)</span>
        }

        // Position on page 1 so the caller can start drawing immediately.
        <span class="cov8" title="1">return gp.SetPage(1)</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// OutlinesObj : outlines dictionary
type OutlinesObj struct { //impl IObj
        getRoot func() *GoPdf

        index   int
        first   int
        last    int
        count   int
        lastObj *OutlineObj
}

func (o *OutlinesObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        o.getRoot = funcGetRoot
        o.first = -1
        o.last = -1
}</span>

func (o *OutlinesObj) getType() string <span class="cov8" title="1">{
        return "Outlines"
}</span>

func (o *OutlinesObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        content := "&lt;&lt;\n"
        content += fmt.Sprintf("\t/Type /%s\n", o.getType())
        content += fmt.Sprintf("\t/Count %d\n", o.count)

        if o.first &gt;= 0 </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/First %d 0 R\n", o.first)
        }</span>

        <span class="cov8" title="1">if o.last &gt;= 0 </span><span class="cov8" title="1">{
                content += fmt.Sprintf("\t/Last %d 0 R\n", o.last)
        }</span>

        <span class="cov8" title="1">content += "&gt;&gt;\n"

        if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *OutlinesObj) SetIndexObjOutlines(index int) <span class="cov8" title="1">{
        o.index = index
}</span>

func (o *OutlinesObj) AddOutline(dest int, title string) <span class="cov8" title="1">{
        oo := &amp;OutlineObj{title: title, dest: dest, parent: o.index, prev: o.last, next: -1}
        o.last = o.getRoot().addObj(oo) + 1
        if o.first &lt;= 0 </span><span class="cov8" title="1">{
                o.first = o.last
        }</span>
        <span class="cov8" title="1">if o.lastObj != nil </span><span class="cov8" title="1">{
                o.lastObj.next = o.last
        }</span>
        <span class="cov8" title="1">o.lastObj = oo
        o.count++</span>
}

// AddOutlinesWithPosition add outlines with position
func (o *OutlinesObj) AddOutlinesWithPosition(dest int, title string, y float64) *OutlineObj <span class="cov8" title="1">{
        oo := &amp;OutlineObj{title: title, dest: dest, parent: o.index, prev: o.last, next: -1, height: y}
        o.last = o.getRoot().addObj(oo) + 1
        if o.first &lt;= 0 </span><span class="cov8" title="1">{
                o.first = o.last
        }</span>
        <span class="cov8" title="1">if o.lastObj != nil </span><span class="cov8" title="1">{
                o.lastObj.next = o.last
        }</span>
        <span class="cov8" title="1">o.lastObj = oo
        o.count++
        oo.index = o.last
        return oo</span>
}

func (o *OutlinesObj) Count() int <span class="cov8" title="1">{
        return o.count
}</span>

// OutlineObj include attribute of outline
type OutlineObj struct { //impl IObj
        title     string
        index     int
        dest      int
        parent    int
        prev      int
        next      int
        first     int
        last      int
        height    float64
        color     [3]float64 // /C array [R G B] (0.0-1.0)
        bold      bool       // /F bit 1
        italic    bool       // /F bit 0
        collapsed bool       // negative /Count
}

func (o *OutlineObj) init(funcGetRoot func() *GoPdf) {<span class="cov0" title="0">
}</span>

func (o *OutlineObj) SetFirst(first int) <span class="cov8" title="1">{
        o.first = first
}</span>

func (o *OutlineObj) SetLast(last int) <span class="cov8" title="1">{
        o.last = last
}</span>

func (o *OutlineObj) SetPrev(prev int) <span class="cov8" title="1">{
        o.prev = prev
}</span>

func (o *OutlineObj) SetNext(next int) <span class="cov8" title="1">{
        o.next = next
}</span>

func (o *OutlineObj) SetParent(parent int) <span class="cov8" title="1">{
        o.parent = parent
}</span>

func (o *OutlineObj) GetIndex() int <span class="cov8" title="1">{
        return o.index
}</span>

func (o *OutlineObj) getType() string <span class="cov8" title="1">{
        return "Outline"
}</span>

//func (o *OutlineObj) write(w io.Writer, objID int) error {
//        io.WriteString(w, "&lt;&lt;\n")
//        fmt.Fprintf(w, "  /Parent %d 0 R\n", o.parent)
//        if o.prev &gt;= 0 {
//                fmt.Fprintf(w, "  /Prev %d 0 R\n", o.prev)
//        }
//        if o.next &gt;= 0 {
//                fmt.Fprintf(w, "  /Next %d 0 R\n", o.next)
//        }
//        fmt.Fprintf(w, "  /Dest [ %d 0 R /XYZ null null null ]\n", o.dest)
//        fmt.Fprintf(w, "  /Title &lt;FEFF%s&gt;\n", encodeUtf8(o.title))
//        io.WriteString(w, "&gt;&gt;\n")
//        return nil
//}

func (o *OutlineObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "  /Parent %d 0 R\n", o.parent)
        if o.prev &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Prev %d 0 R\n", o.prev)
        }</span>
        <span class="cov8" title="1">if o.next &gt;= 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Next %d 0 R\n", o.next)
        }</span>
        <span class="cov8" title="1">if o.first &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /First %d 0 R\n", o.first)
        }</span>
        <span class="cov8" title="1">if o.last &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Last %d 0 R\n", o.last)
        }</span>
        // Count: negative means collapsed children.
        <span class="cov8" title="1">if o.first &gt; 0 &amp;&amp; o.collapsed </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /Count -%d\n", o.countChildren())
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, "  /Dest [ %d 0 R /XYZ 90 %f 0 ]\n", o.dest, o.height)
        fmt.Fprintf(w, "  /Title &lt;FEFF%s&gt;\n", encodeUtf8(o.title))
        // Color (non-black).
        if o.color != [3]float64{} </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /C [%.4f %.4f %.4f]\n", o.color[0], o.color[1], o.color[2])
        }</span>
        // Flags: bit 0 = italic, bit 1 = bold.
        <span class="cov8" title="1">flags := 0
        if o.italic </span><span class="cov8" title="1">{
                flags |= 1
        }</span>
        <span class="cov8" title="1">if o.bold </span><span class="cov8" title="1">{
                flags |= 2
        }</span>
        <span class="cov8" title="1">if flags != 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "  /F %d\n", flags)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// countChildren counts direct children of this outline node.
func (o *OutlineObj) countChildren() int <span class="cov8" title="1">{
        // This is a simplified count; in practice the PDF spec uses
        // the total descendant count. For our purposes, we use 0 to
        // indicate "collapsed" via negative Count.
        return 0
}</span>

// OutlineNode is a node of outline
type OutlineNode struct {
        Obj      *OutlineObj
        Children []*OutlineNode
}

// OutlineNodes are all nodes of outline
type OutlineNodes []*OutlineNode

// Parse parse outline nodes
func (objs OutlineNodes) Parse() <span class="cov8" title="1">{
        for i, obj := range objs </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        obj.Obj.SetPrev(-1)
                }</span> else<span class="cov8" title="1"> {
                        obj.Obj.SetNext(objs[i-1].Obj.GetIndex())
                }</span>
                <span class="cov8" title="1">if i == len(objs)-1 </span><span class="cov8" title="1">{
                        obj.Obj.SetNext(-1)
                }</span> else<span class="cov8" title="1"> {
                        obj.Obj.SetNext(objs[i+1].Obj.GetIndex())
                }</span>
                <span class="cov8" title="1">obj.Parse()</span>
        }

}

// Parse parse outline
func (obj OutlineNode) Parse() <span class="cov8" title="1">{
        if obj.Children == nil || len(obj.Children) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for i, children := range obj.Children </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        obj.Obj.SetFirst(children.Obj.GetIndex())
                        children.Obj.SetPrev(-1)
                }</span>
                <span class="cov8" title="1">if i == len(obj.Children)-1 </span><span class="cov8" title="1">{
                        obj.Obj.SetLast(children.Obj.GetIndex())
                        children.Obj.SetNext(-1)
                }</span>
                <span class="cov8" title="1">if i != 0 </span><span class="cov8" title="1">{
                        children.Obj.SetPrev(obj.Children[i-1].Obj.GetIndex())
                }</span>
                <span class="cov8" title="1">if i != len(obj.Children)-1 </span><span class="cov8" title="1">{
                        children.Obj.SetNext(obj.Children[i+1].Obj.GetIndex())
                }</span>
                <span class="cov8" title="1">children.Obj.SetParent(obj.Obj.GetIndex())
                children.Parse()</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package gopdf

import "errors"

// DeletePages removes multiple pages from the document in a single operation.
// Pages are specified as 1-based page numbers. Duplicate page numbers are
// ignored. Pages are deleted in reverse order to maintain correct numbering.
//
// Example:
//
//        pdf.DeletePages([]int{2, 4, 6}) // remove pages 2, 4, and 6
func (gp *GoPdf) DeletePages(pages []int) error <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">numPages := gp.GetNumberOfPages()
        if numPages == 0 </span><span class="cov8" title="1">{
                return ErrNoPages
        }</span>

        // Validate all page numbers first.
        <span class="cov8" title="1">for _, p := range pages </span><span class="cov8" title="1">{
                if p &lt; 1 || p &gt; numPages </span><span class="cov8" title="1">{
                        return ErrPageOutOfRange
                }</span>
        }

        // Deduplicate and sort descending so we delete from the end first.
        // This avoids page number shifting issues.
        <span class="cov8" title="1">seen := make(map[int]bool, len(pages))
        unique := make([]int, 0, len(pages))
        for _, p := range pages </span><span class="cov8" title="1">{
                if !seen[p] </span><span class="cov8" title="1">{
                        seen[p] = true
                        unique = append(unique, p)
                }</span>
        }

        // Sort descending (simple insertion sort â€” page lists are small).
        <span class="cov8" title="1">for i := 1; i &lt; len(unique); i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; 0 &amp;&amp; unique[j] &gt; unique[j-1]; j-- </span><span class="cov8" title="1">{
                        unique[j], unique[j-1] = unique[j-1], unique[j]
                }</span>
        }

        // Cannot delete all pages.
        <span class="cov8" title="1">if len(unique) &gt;= numPages </span><span class="cov8" title="1">{
                return errors.New("cannot delete all pages from document")
        }</span>

        // Delete each page from highest to lowest.
        <span class="cov8" title="1">for _, p := range unique </span><span class="cov8" title="1">{
                if err := gp.DeletePage(p); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MovePage moves a page from one position to another.
// Both from and to are 1-based page numbers. The page at position 'from'
// is removed and re-inserted at position 'to'.
//
// This works by using SelectPages to reorder the page sequence.
//
// Example:
//
//        pdf.MovePage(3, 1) // move page 3 to become page 1
//        pdf.MovePage(1, 5) // move page 1 to position 5
func (gp *GoPdf) MovePage(from, to int) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if numPages == 0 </span><span class="cov8" title="1">{
                return ErrNoPages
        }</span>
        <span class="cov8" title="1">if from &lt; 1 || from &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">if to &lt; 1 || to &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">if from == to </span><span class="cov8" title="1">{
                return nil // no-op
        }</span>

        // Build the new page order.
        <span class="cov8" title="1">order := make([]int, 0, numPages)
        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                if i != from </span><span class="cov8" title="1">{
                        order = append(order, i)
                }</span>
        }

        // Insert 'from' at position 'to-1' (0-based index).
        <span class="cov8" title="1">insertIdx := to - 1
        if from &lt; to </span><span class="cov8" title="1">{
                // When moving forward, the removal shifts indices down by 1.
                insertIdx = to - 2
                if insertIdx &lt; 0 </span><span class="cov0" title="0">{
                        insertIdx = 0
                }</span>
        }
        // Clamp to valid range.
        <span class="cov8" title="1">if insertIdx &gt; len(order) </span><span class="cov0" title="0">{
                insertIdx = len(order)
        }</span>

        // Insert at position.
        <span class="cov8" title="1">newOrder := make([]int, 0, numPages)
        newOrder = append(newOrder, order[:insertIdx]...)
        newOrder = append(newOrder, from)
        newOrder = append(newOrder, order[insertIdx:]...)

        // Use SelectPages to create a reordered document, then swap internals.
        reordered, err := gp.SelectPages(newOrder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Swap the internal state from the reordered document.
        <span class="cov8" title="1">gp.swapFrom(reordered)
        return nil</span>
}

// swapFrom replaces the receiver's internal state with that of another GoPdf.
// This is used by MovePage to apply the reordered document.
func (gp *GoPdf) swapFrom(other *GoPdf) <span class="cov8" title="1">{
        gp.pdfObjs = other.pdfObjs
        gp.config = other.config
        gp.indexOfCatalogObj = other.indexOfCatalogObj
        gp.indexOfPagesObj = other.indexOfPagesObj
        gp.numOfPagesObj = other.numOfPagesObj
        gp.indexOfFirstPageObj = other.indexOfFirstPageObj
        gp.indexEncodingObjFonts = other.indexEncodingObjFonts
        gp.indexOfContent = other.indexOfContent
        gp.indexOfProcSet = other.indexOfProcSet
        gp.buf = other.buf
        gp.pdfProtection = other.pdfProtection
        gp.encryptionObjID = other.encryptionObjID
        gp.compressLevel = other.compressLevel
        gp.isUseInfo = other.isUseInfo
        gp.info = other.info
        gp.outlines = other.outlines
        gp.indexOfOutlinesObj = other.indexOfOutlinesObj
        gp.fpdi = other.fpdi
        gp.margins = other.margins
        gp.anchors = other.anchors
        gp.placeHolderTexts = other.placeHolderTexts
        gp.embeddedFiles = other.embeddedFiles
        gp.pdfVersion = other.pdfVersion
        gp.pageLabels = other.pageLabels
        gp.xmpMetadata = other.xmpMetadata
        gp.ocgs = other.ocgs
        gp.formFields = other.formFields

        // Copy Current fields individually to avoid copying the sync.Mutex
        // inside SMaskMap / ExtGStatesMap / TransparencyMap.
        gp.curr.setXCount = other.curr.setXCount
        gp.curr.X = other.curr.X
        gp.curr.Y = other.curr.Y
        gp.curr.IndexOfFontObj = other.curr.IndexOfFontObj
        gp.curr.CountOfFont = other.curr.CountOfFont
        gp.curr.CountOfL = other.curr.CountOfL
        gp.curr.FontSize = other.curr.FontSize
        gp.curr.FontStyle = other.curr.FontStyle
        gp.curr.FontFontCount = other.curr.FontFontCount
        gp.curr.FontType = other.curr.FontType
        gp.curr.IndexOfColorSpaceObj = other.curr.IndexOfColorSpaceObj
        gp.curr.CountOfColorSpace = other.curr.CountOfColorSpace
        gp.curr.CharSpacing = other.curr.CharSpacing
        gp.curr.FontISubset = other.curr.FontISubset
        gp.curr.IndexOfPageObj = other.curr.IndexOfPageObj
        gp.curr.CountOfImg = other.curr.CountOfImg
        gp.curr.ImgCaches = other.curr.ImgCaches
        gp.curr.txtColorMode = other.curr.txtColorMode
        gp.curr.grayFill = other.curr.grayFill
        gp.curr.grayStroke = other.curr.grayStroke
        gp.curr.lineWidth = other.curr.lineWidth
        gp.curr.pageSize = other.curr.pageSize
        gp.curr.trimBox = other.curr.trimBox
        gp.curr.transparency = other.curr.transparency
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package gopdf

// SetPageCropBox sets the CropBox for a page. The CropBox defines the visible
// area of the page when displayed or printed. Content outside the CropBox is
// clipped (hidden) but not removed.
//
// pageNo is 1-based. The box coordinates are in document units:
//   - left, top: the lower-left corner of the crop area
//   - right, bottom: the upper-right corner of the crop area
//
// In PDF coordinate system, (0,0) is the bottom-left of the page.
//
// Example:
//
//        // Crop page 1 to show only the center area
//        pdf.SetPageCropBox(1, Box{Left: 50, Top: 50, Right: 545, Bottom: 792})
//
//        // Remove crop box from page 1
//        pdf.ClearPageCropBox(1)
func (gp *GoPdf) SetPageCropBox(pageNo int, box Box) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page.cropBox = &amp;Box{
                Left:   box.Left,
                Top:    box.Top,
                Right:  box.Right,
                Bottom: box.Bottom,
        }
        return nil</span>
}

// GetPageCropBox returns the CropBox for a page, or nil if no CropBox is set.
// pageNo is 1-based.
func (gp *GoPdf) GetPageCropBox(pageNo int) (*Box, error) <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return nil, ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return nil, ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">if page.cropBox == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // Return a copy to prevent external mutation.
        <span class="cov8" title="1">b := *page.cropBox
        return &amp;b, nil</span>
}

// ClearPageCropBox removes the CropBox from a page, restoring the full
// MediaBox as the visible area.
// pageNo is 1-based.
func (gp *GoPdf) ClearPageCropBox(pageNo int) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page.cropBox = nil
        return nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package gopdf

import (
        "bytes"
        "errors"
        "io"

        "github.com/phpdave11/gofpdi"
)

// PageInfo contains information about a PDF page.
type PageInfo struct {
        // Width is the page width in points.
        Width float64
        // Height is the page height in points.
        Height float64
        // PageNumber is the 1-based page number.
        PageNumber int
}

// GetPageSize returns the size of the specified page (1-based).
// Returns width and height in document units.
func (gp *GoPdf) GetPageSize(pageNo int) (w, h float64, err error) <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return 0, 0, ErrPageOutOfRange
        }</span>

        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return 0, 0, ErrPageOutOfRange
        }</span>

        <span class="cov8" title="1">if !page.pageOption.isEmpty() </span><span class="cov8" title="1">{
                return gp.PointsToUnits(page.pageOption.PageSize.W),
                        gp.PointsToUnits(page.pageOption.PageSize.H), nil
        }</span>

        <span class="cov8" title="1">return gp.PointsToUnits(gp.config.PageSize.W),
                gp.PointsToUnits(gp.config.PageSize.H), nil</span>
}

// findPageObj finds the n-th PageObj (1-based) in the pdfObjs slice.
func (gp *GoPdf) findPageObj(pageNo int) *PageObj <span class="cov8" title="1">{
        count := 0
        for _, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if p, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        count++
                        if count == pageNo </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// GetAllPageSizes returns the sizes of all pages in the document.
func (gp *GoPdf) GetAllPageSizes() []PageInfo <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        result := make([]PageInfo, 0, numPages)

        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                w, h, err := gp.GetPageSize(i)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, PageInfo{
                        Width:      w,
                        Height:     h,
                        PageNumber: i,
                })</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetSourcePDFPageCount returns the number of pages in a source PDF file
// without importing it.
func GetSourcePDFPageCount(pdfPath string) (int, error) <span class="cov8" title="1">{
        data, err := readFileBytes(pdfPath)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return GetSourcePDFPageCountFromBytes(data)</span>
}

// GetSourcePDFPageCountFromBytes returns the number of pages in a source PDF
// from a byte slice without importing it.
func GetSourcePDFPageCountFromBytes(pdfData []byte) (int, error) <span class="cov8" title="1">{
        probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(pdfData))
        probe.SetSourceStream(&amp;probeRS)
        n := probe.GetNumPages()
        if n == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("PDF has no pages or is invalid")
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// GetSourcePDFPageSizes returns the page sizes of all pages in a source PDF file.
// The returned map is keyed by 1-based page number.
func GetSourcePDFPageSizes(pdfPath string) (map[int]PageInfo, error) <span class="cov8" title="1">{
        data, err := readFileBytes(pdfPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return GetSourcePDFPageSizesFromBytes(data)</span>
}

// GetSourcePDFPageSizesFromBytes returns the page sizes from a PDF byte slice.
func GetSourcePDFPageSizesFromBytes(pdfData []byte) (map[int]PageInfo, error) <span class="cov8" title="1">{
        probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(pdfData))
        probe.SetSourceStream(&amp;probeRS)

        numPages := probe.GetNumPages()
        if numPages == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("PDF has no pages or is invalid")
        }</span>

        <span class="cov8" title="1">sizes := probe.GetPageSizes()
        result := make(map[int]PageInfo, numPages)

        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                mediaBox, ok := sizes[i]["/MediaBox"]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">result[i] = PageInfo{
                        Width:      mediaBox["w"],
                        Height:     mediaBox["h"],
                        PageNumber: i,
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "sort"
)

// PageLabelStyle defines the numbering style for page labels.
type PageLabelStyle string

const (
        // PageLabelDecimal uses decimal Arabic numerals (1, 2, 3, ...).
        PageLabelDecimal PageLabelStyle = "D"
        // PageLabelRomanUpper uses uppercase Roman numerals (I, II, III, ...).
        PageLabelRomanUpper PageLabelStyle = "R"
        // PageLabelRomanLower uses lowercase Roman numerals (i, ii, iii, ...).
        PageLabelRomanLower PageLabelStyle = "r"
        // PageLabelAlphaUpper uses uppercase letters (A, B, C, ...).
        PageLabelAlphaUpper PageLabelStyle = "A"
        // PageLabelAlphaLower uses lowercase letters (a, b, c, ...).
        PageLabelAlphaLower PageLabelStyle = "a"
        // PageLabelNone uses no numbering; only the prefix is shown.
        PageLabelNone PageLabelStyle = ""
)

// PageLabel defines a page labeling range.
// A page label range starts at a specific page index (0-based) and
// applies to all subsequent pages until the next range.
type PageLabel struct {
        // PageIndex is the 0-based page index where this label range starts.
        PageIndex int

        // Style is the numbering style.
        Style PageLabelStyle

        // Prefix is an optional string prefix prepended to the page number.
        // For example, "A-" would produce labels like "A-1", "A-2", etc.
        Prefix string

        // Start is the starting number for this range (default 1).
        // For example, Start=5 with Style=Decimal produces "5", "6", "7", ...
        Start int
}

// SetPageLabels sets the page label ranges for the document.
// Page labels define how page numbers are displayed in PDF viewers.
//
// Example:
//
//        pdf.SetPageLabels([]gopdf.PageLabel{
//            {PageIndex: 0, Style: gopdf.PageLabelRomanLower, Start: 1},  // i, ii, iii (cover pages)
//            {PageIndex: 3, Style: gopdf.PageLabelDecimal, Start: 1},     // 1, 2, 3, ... (main content)
//            {PageIndex: 10, Style: gopdf.PageLabelAlphaUpper, Prefix: "Appendix ", Start: 1}, // Appendix A, B, ...
//        })
func (gp *GoPdf) SetPageLabels(labels []PageLabel) <span class="cov8" title="1">{
        gp.pageLabels = labels
}</span>

// GetPageLabels returns the current page label ranges.
func (gp *GoPdf) GetPageLabels() []PageLabel <span class="cov8" title="1">{
        return gp.pageLabels
}</span>

// pageLabelObj is the PDF PageLabels number tree object.
type pageLabelObj struct {
        labels []PageLabel
}

func (p pageLabelObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (p pageLabelObj) getType() string <span class="cov8" title="1">{
        return "PageLabels"
}</span>

func (p pageLabelObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        // Sort labels by page index.
        sorted := make([]PageLabel, len(p.labels))
        copy(sorted, p.labels)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                return sorted[i].PageIndex &lt; sorted[j].PageIndex
        }</span>)

        <span class="cov8" title="1">io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "  /Nums [\n")

        for _, label := range sorted </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "    %d &lt;&lt;\n", label.PageIndex)
                if label.Style != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "      /S /%s\n", string(label.Style))
                }</span>
                <span class="cov8" title="1">if label.Prefix != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "      /P (%s)\n", escapeAnnotString(label.Prefix))
                }</span>
                <span class="cov8" title="1">start := label.Start
                if start &lt;= 0 </span><span class="cov8" title="1">{
                        start = 1
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(w, "      /St %d\n", start)
                io.WriteString(w, "    &gt;&gt;\n")</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "  ]\n")
        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package gopdf

import "strings"

// PageLayout controls how pages are displayed when the document is opened.
type PageLayout string

const (
        // PageLayoutSinglePage displays one page at a time.
        PageLayoutSinglePage PageLayout = "SinglePage"
        // PageLayoutOneColumn displays pages in one continuous column.
        PageLayoutOneColumn PageLayout = "OneColumn"
        // PageLayoutTwoColumnLeft displays pages in two columns, odd pages on left.
        PageLayoutTwoColumnLeft PageLayout = "TwoColumnLeft"
        // PageLayoutTwoColumnRight displays pages in two columns, odd pages on right.
        PageLayoutTwoColumnRight PageLayout = "TwoColumnRight"
        // PageLayoutTwoPageLeft displays two pages at a time, odd pages on left.
        PageLayoutTwoPageLeft PageLayout = "TwoPageLeft"
        // PageLayoutTwoPageRight displays two pages at a time, odd pages on right.
        PageLayoutTwoPageRight PageLayout = "TwoPageRight"
)

// PageMode controls what panel is displayed when the document is opened.
type PageMode string

const (
        // PageModeUseNone shows no panel (default).
        PageModeUseNone PageMode = "UseNone"
        // PageModeUseOutlines shows the bookmarks/outline panel.
        PageModeUseOutlines PageMode = "UseOutlines"
        // PageModeUseThumbs shows the page thumbnails panel.
        PageModeUseThumbs PageMode = "UseThumbs"
        // PageModeFullScreen opens in full-screen mode.
        PageModeFullScreen PageMode = "FullScreen"
        // PageModeUseOC shows the optional content (layers) panel.
        PageModeUseOC PageMode = "UseOC"
        // PageModeUseAttachments shows the attachments panel.
        PageModeUseAttachments PageMode = "UseAttachments"
)

// SetPageLayout sets the page layout for the document.
// This controls how pages are arranged when the document is opened.
//
// Example:
//
//        pdf.SetPageLayout(gopdf.PageLayoutTwoColumnLeft)
func (gp *GoPdf) SetPageLayout(layout PageLayout) <span class="cov8" title="1">{
        catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
        catalogObj.pageLayout = string(layout)
}</span>

// GetPageLayout returns the current page layout setting.
func (gp *GoPdf) GetPageLayout() PageLayout <span class="cov8" title="1">{
        catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
        if catalogObj.pageLayout == "" </span><span class="cov8" title="1">{
                return PageLayoutSinglePage
        }</span>
        <span class="cov8" title="1">return PageLayout(catalogObj.pageLayout)</span>
}

// SetPageMode sets the page mode for the document.
// This controls which panel is shown when the document is opened.
//
// Note: If outlines are present, PageMode may be overridden to UseOutlines.
//
// Example:
//
//        pdf.SetPageMode(gopdf.PageModeUseThumbs)
func (gp *GoPdf) SetPageMode(mode PageMode) <span class="cov8" title="1">{
        catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
        catalogObj.pageMode = string(mode)
}</span>

// GetPageMode returns the current page mode setting.
func (gp *GoPdf) GetPageMode() PageMode <span class="cov8" title="1">{
        catalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)
        if catalogObj.pageMode == "" </span><span class="cov8" title="1">{
                return PageModeUseNone
        }</span>
        <span class="cov8" title="1">return PageMode(catalogObj.pageMode)</span>
}

// validPageLayout checks if a string is a valid PageLayout value.
func validPageLayout(s string) bool <span class="cov8" title="1">{
        switch strings.ToLower(s) </span>{
        case "singlepage", "onecolumn", "twocolumnleft", "twocolumnright",
                "twopageleft", "twopageright":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// validPageMode checks if a string is a valid PageMode value.
func validPageMode(s string) bool <span class="cov8" title="1">{
        switch strings.ToLower(s) </span>{
        case "usenone", "useoutlines", "usethumbs", "fullscreen",
                "useoc", "useattachments":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package gopdf

import (
        "bytes"
        "errors"
        "io"
        "os"

        "github.com/phpdave11/gofpdi"
)

var (
        ErrPageOutOfRange = errors.New("page number out of range")
        ErrNoPages        = errors.New("document has no pages")
)

// DeletePage removes a page from the document by its 1-based page number.
// All subsequent pages are shifted down. The current page is reset to page 1.
//
// Note: This only works for documents created via OpenPDF or built from scratch.
// The page content is removed from the internal object list.
//
// Example:
//
//        pdf.OpenPDF("input.pdf", nil)
//        pdf.DeletePage(2) // remove page 2
//        pdf.WritePdf("output.pdf")
func (gp *GoPdf) DeletePage(pageNo int) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if numPages == 0 </span><span class="cov8" title="1">{
                return ErrNoPages
        }</span>
        <span class="cov8" title="1">if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>

        // Find the page object and its associated content object.
        <span class="cov8" title="1">pageCount := 0
        pageIdx := -1
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if _, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        pageCount++
                        if pageCount == pageNo </span><span class="cov8" title="1">{
                                pageIdx = i
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if pageIdx == -1 </span><span class="cov0" title="0">{
                return ErrPageOutOfRange
        }</span>

        // Find the content object that follows this page.
        <span class="cov8" title="1">contentIdx := -1
        for i := pageIdx + 1; i &lt; len(gp.pdfObjs); i++ </span><span class="cov8" title="1">{
                if _, ok := gp.pdfObjs[i].(*ContentObj); ok </span><span class="cov8" title="1">{
                        contentIdx = i
                        break</span>
                }
        }

        // Replace with null placeholder objects (we can't remove them without
        // breaking object numbering, but nullObj writes "null" safely instead
        // of crashing on nil pointer dereference).
        <span class="cov8" title="1">gp.pdfObjs[pageIdx] = nullObj{}
        if contentIdx &gt;= 0 </span><span class="cov8" title="1">{
                gp.pdfObjs[contentIdx] = nullObj{}
        }</span>

        // Update the pages object count.
        <span class="cov8" title="1">pagesObj := gp.pdfObjs[gp.indexOfPagesObj].(*PagesObj)
        pagesObj.PageCount--
        gp.numOfPagesObj--

        // Reset to page 1 if possible.
        if gp.numOfPagesObj &gt; 0 </span><span class="cov8" title="1">{
                return gp.SetPage(1)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyPage duplicates a page and appends it at the end of the document.
// pageNo is 1-based. The new page is an exact copy of the original.
// Returns the new page number.
//
// Note: This works best with documents opened via OpenPDF.
func (gp *GoPdf) CopyPage(pageNo int) (int, error) <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return 0, ErrPageOutOfRange
        }</span>

        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return 0, ErrPageOutOfRange
        }</span>

        // Add a new page with the same options.
        <span class="cov8" title="1">gp.AddPageWithOption(page.pageOption)
        newPageNo := gp.GetNumberOfPages()

        return newPageNo, nil</span>
}

// ExtractPages creates a new GoPdf document containing only the specified pages
// from the source PDF data. Pages are 1-based.
//
// This is useful for splitting a PDF into smaller documents.
//
// Example:
//
//        newPdf, err := gopdf.ExtractPages("input.pdf", []int{1, 3, 5}, nil)
//        if err != nil { log.Fatal(err) }
//        newPdf.WritePdf("pages_1_3_5.pdf")
func ExtractPages(pdfPath string, pages []int, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">box := "/MediaBox"
        if opt != nil &amp;&amp; opt.Box != "" </span><span class="cov0" title="0">{
                box = opt.Box
        }</span>

        // Read source PDF.
        <span class="cov8" title="1">data, err := readFileBytes(pdfPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Probe page count.
        <span class="cov8" title="1">probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(data))
        probe.SetSourceStream(&amp;probeRS)
        numPages := probe.GetNumPages()
        sizes := probe.GetPageSizes()

        // Validate page numbers.
        for _, p := range pages </span><span class="cov8" title="1">{
                if p &lt; 1 || p &gt; numPages </span><span class="cov8" title="1">{
                        return nil, ErrPageOutOfRange
                }</span>
        }

        // Get first page size for config.
        <span class="cov8" title="1">firstSize, ok := sizes[pages[0]][box]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("cannot read page size from source PDF")
        }</span>

        <span class="cov8" title="1">result := &amp;GoPdf{}
        config := Config{
                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
        }
        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov0" title="0">{
                config.Protection = *opt.Protection
        }</span>
        <span class="cov8" title="1">result.Start(config)

        // Import only the requested pages.
        for _, pageNo := range pages </span><span class="cov8" title="1">{
                pageSize, ok := sizes[pageNo][box]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("cannot read page size from source PDF")
                }</span>
                <span class="cov8" title="1">w := pageSize["w"]
                h := pageSize["h"]

                rs := io.ReadSeeker(bytes.NewReader(data))
                result.fpdi.SetSourceStream(&amp;rs)

                result.AddPageWithOption(PageOption{
                        PageSize: &amp;Rect{W: w, H: h},
                })

                startObjID := result.GetNextObjectID()
                result.fpdi.SetNextObjectID(startObjID)

                tpl := result.fpdi.ImportPage(pageNo, box)

                tplObjIDs := result.fpdi.PutFormXobjects()
                result.ImportTemplates(tplObjIDs)

                imported := result.fpdi.GetImportedObjects()
                result.ImportObjects(imported, startObjID)

                result.UseImportedTemplate(tpl, 0, 0, w, h)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// ExtractPagesFromBytes is like ExtractPages but reads from a byte slice.
func ExtractPagesFromBytes(pdfData []byte, pages []int, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">box := "/MediaBox"
        if opt != nil &amp;&amp; opt.Box != "" </span><span class="cov0" title="0">{
                box = opt.Box
        }</span>

        <span class="cov8" title="1">probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(pdfData))
        probe.SetSourceStream(&amp;probeRS)
        numPages := probe.GetNumPages()
        sizes := probe.GetPageSizes()

        for _, p := range pages </span><span class="cov8" title="1">{
                if p &lt; 1 || p &gt; numPages </span><span class="cov8" title="1">{
                        return nil, ErrPageOutOfRange
                }</span>
        }

        <span class="cov8" title="1">firstSize, ok := sizes[pages[0]][box]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("cannot read page size from source PDF")
        }</span>

        <span class="cov8" title="1">result := &amp;GoPdf{}
        config := Config{
                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
        }
        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov0" title="0">{
                config.Protection = *opt.Protection
        }</span>
        <span class="cov8" title="1">result.Start(config)

        for _, pageNo := range pages </span><span class="cov8" title="1">{
                pageSize, ok := sizes[pageNo][box]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("cannot read page size from source PDF")
                }</span>
                <span class="cov8" title="1">w := pageSize["w"]
                h := pageSize["h"]

                rs := io.ReadSeeker(bytes.NewReader(pdfData))
                result.fpdi.SetSourceStream(&amp;rs)

                result.AddPageWithOption(PageOption{
                        PageSize: &amp;Rect{W: w, H: h},
                })

                startObjID := result.GetNextObjectID()
                result.fpdi.SetNextObjectID(startObjID)

                tpl := result.fpdi.ImportPage(pageNo, box)

                tplObjIDs := result.fpdi.PutFormXobjects()
                result.ImportTemplates(tplObjIDs)

                imported := result.fpdi.GetImportedObjects()
                result.ImportObjects(imported, startObjID)

                result.UseImportedTemplate(tpl, 0, 0, w, h)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// MergePages merges multiple PDF files into a single document.
// Each source PDF's pages are appended in order.
//
// Example:
//
//        merged, err := gopdf.MergePages([]string{"doc1.pdf", "doc2.pdf", "doc3.pdf"}, nil)
//        if err != nil { log.Fatal(err) }
//        merged.WritePdf("merged.pdf")
func MergePages(pdfPaths []string, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pdfPaths) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">box := "/MediaBox"
        if opt != nil &amp;&amp; opt.Box != "" </span><span class="cov8" title="1">{
                box = opt.Box
        }</span>

        <span class="cov8" title="1">result := &amp;GoPdf{}
        initialized := false

        for _, pdfPath := range pdfPaths </span><span class="cov8" title="1">{
                data, err := readFileBytes(pdfPath)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">probe := gofpdi.NewImporter()
                probeRS := io.ReadSeeker(bytes.NewReader(data))
                probe.SetSourceStream(&amp;probeRS)
                numPages := probe.GetNumPages()
                if numPages == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">sizes := probe.GetPageSizes()

                if !initialized </span><span class="cov8" title="1">{
                        firstSize, ok := sizes[1][box]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("cannot read page size from source PDF")
                        }</span>
                        <span class="cov8" title="1">config := Config{
                                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
                        }
                        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov0" title="0">{
                                config.Protection = *opt.Protection
                        }</span>
                        <span class="cov8" title="1">result.Start(config)
                        initialized = true</span>
                }

                <span class="cov8" title="1">for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                        pageSize, ok := sizes[i][box]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("cannot read page size from source PDF")
                        }</span>
                        <span class="cov8" title="1">w := pageSize["w"]
                        h := pageSize["h"]

                        rs := io.ReadSeeker(bytes.NewReader(data))
                        result.fpdi.SetSourceStream(&amp;rs)

                        result.AddPageWithOption(PageOption{
                                PageSize: &amp;Rect{W: w, H: h},
                        })

                        startObjID := result.GetNextObjectID()
                        result.fpdi.SetNextObjectID(startObjID)

                        tpl := result.fpdi.ImportPage(i, box)

                        tplObjIDs := result.fpdi.PutFormXobjects()
                        result.ImportTemplates(tplObjIDs)

                        imported := result.fpdi.GetImportedObjects()
                        result.ImportObjects(imported, startObjID)

                        result.UseImportedTemplate(tpl, 0, 0, w, h)</span>
                }
        }

        <span class="cov8" title="1">if !initialized </span><span class="cov0" title="0">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// MergePagesFromBytes merges multiple PDF byte slices into a single document.
func MergePagesFromBytes(pdfDataSlices [][]byte, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pdfDataSlices) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">box := "/MediaBox"
        if opt != nil &amp;&amp; opt.Box != "" </span><span class="cov0" title="0">{
                box = opt.Box
        }</span>

        <span class="cov8" title="1">result := &amp;GoPdf{}
        initialized := false

        for _, data := range pdfDataSlices </span><span class="cov8" title="1">{
                probe := gofpdi.NewImporter()
                probeRS := io.ReadSeeker(bytes.NewReader(data))
                probe.SetSourceStream(&amp;probeRS)
                numPages := probe.GetNumPages()
                if numPages == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">sizes := probe.GetPageSizes()

                if !initialized </span><span class="cov8" title="1">{
                        firstSize, ok := sizes[1][box]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("cannot read page size from source PDF")
                        }</span>
                        <span class="cov8" title="1">config := Config{
                                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
                        }
                        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov0" title="0">{
                                config.Protection = *opt.Protection
                        }</span>
                        <span class="cov8" title="1">result.Start(config)
                        initialized = true</span>
                }

                <span class="cov8" title="1">for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                        pageSize, ok := sizes[i][box]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("cannot read page size from source PDF")
                        }</span>
                        <span class="cov8" title="1">w := pageSize["w"]
                        h := pageSize["h"]

                        rs := io.ReadSeeker(bytes.NewReader(data))
                        result.fpdi.SetSourceStream(&amp;rs)

                        result.AddPageWithOption(PageOption{
                                PageSize: &amp;Rect{W: w, H: h},
                        })

                        startObjID := result.GetNextObjectID()
                        result.fpdi.SetNextObjectID(startObjID)

                        tpl := result.fpdi.ImportPage(i, box)

                        tplObjIDs := result.fpdi.PutFormXobjects()
                        result.ImportTemplates(tplObjIDs)

                        imported := result.fpdi.GetImportedObjects()
                        result.ImportObjects(imported, startObjID)

                        result.UseImportedTemplate(tpl, 0, 0, w, h)</span>
                }
        }

        <span class="cov8" title="1">if !initialized </span><span class="cov0" title="0">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// readFileBytes reads a file into a byte slice.
func readFileBytes(path string) ([]byte, error) <span class="cov8" title="1">{
        return os.ReadFile(path)
}</span>

</pre>
		
		<pre class="file" id="file90" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
)

// PageObj pdf page object
type PageObj struct { //impl IObj
        Contents        string
        ResourcesRelate string
        pageOption      PageOption
        LinkObjIds      []int
        rotation        int // page display rotation (0, 90, 180, 270)
        cropBox         *Box // optional CropBox (visible area)
        getRoot         func() *GoPdf
}

func (p *PageObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        p.getRoot = funcGetRoot
        p.LinkObjIds = make([]int, 0)
}</span>

func (p *PageObj) setOption(opt PageOption) <span class="cov8" title="1">{
        p.pageOption = opt
}</span>

func (p *PageObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "  /Type /%s\n", p.getType())
        io.WriteString(w, "  /Parent 2 0 R\n")
        fmt.Fprintf(w, "  /Resources %s\n", p.ResourcesRelate)

        var err error
        if len(p.LinkObjIds) &gt; 0 </span><span class="cov8" title="1">{
                io.WriteString(w, "  /Annots [")
                for _, l := range p.LinkObjIds </span><span class="cov8" title="1">{
                        _, err = fmt.Fprintf(w, "%d 0 R ", l)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">io.WriteString(w, "]\n")</span>
        }

        /*me.buffer.WriteString("    /Font &lt;&lt;\n")
        i := 0
        max := len(me.Realtes)
        for i &lt; max {
                realte := me.Realtes[i]
                me.buffer.WriteString(fmt.Sprintf("      /F%d %d 0 R\n",realte.CountOfFont + 1, realte.IndexOfObj + 1))
                i++
        }
        me.buffer.WriteString("    &gt;&gt;\n")*/
        //me.buffer.WriteString("  &gt;&gt;\n")
        <span class="cov8" title="1">fmt.Fprintf(w, "  /Contents %s\n", p.Contents) //sample  Contents 8 0 R
        if !p.pageOption.isEmpty() </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " /MediaBox [ 0 0 %0.2f %0.2f ]\n", p.pageOption.PageSize.W, p.pageOption.PageSize.H)
        }</span>
        <span class="cov8" title="1">if p.pageOption.isTrimBoxSet() </span><span class="cov8" title="1">{
                trimBox := p.pageOption.TrimBox
                fmt.Fprintf(w, " /TrimBox [ %0.2f %0.2f %0.2f %0.2f ]\n", trimBox.Left, trimBox.Top, trimBox.Right, trimBox.Bottom)
        }</span>
        <span class="cov8" title="1">if p.cropBox != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " /CropBox [ %0.2f %0.2f %0.2f %0.2f ]\n", p.cropBox.Left, p.cropBox.Top, p.cropBox.Right, p.cropBox.Bottom)
        }</span>
        <span class="cov8" title="1">if p.rotation != 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " /Rotate %d\n", p.rotation)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

func (p *PageObj) writeExternalLink(w io.Writer, l linkOption, objID int) error <span class="cov8" title="1">{
        protection := p.getRoot().protection()
        url := l.url
        if protection != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(protection.objectkey(objID), []byte(url))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">url = string(tmp)</span>
        }
        <span class="cov8" title="1">url = strings.Replace(url, "\\", "\\\\", -1)
        url = strings.Replace(url, "(", "\\(", -1)
        url = strings.Replace(url, ")", "\\)", -1)
        url = strings.Replace(url, "\r", "\\r", -1)

        _, err := fmt.Fprintf(w, "&lt;&lt;/Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /A &lt;&lt;/S /URI /URI (%s)&gt;&gt;&gt;&gt;",
                l.x, l.y, l.x+l.w, l.y-l.h, url)
        return err</span>
}

func (p *PageObj) writeInternalLink(w io.Writer, l linkOption, anchors map[string]anchorOption) error <span class="cov8" title="1">{
        a, ok := anchors[l.anchor]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">_, err := fmt.Fprintf(w, "&lt;&lt;/Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /Dest [%d 0 R /XYZ 0 %.2f null]&gt;&gt;",
                l.x, l.y, l.x+l.w, l.y-l.h, a.page+1, a.y)
        return err</span>
}

func (p *PageObj) getType() string <span class="cov8" title="1">{
        return "Page"
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package gopdf

// PageOption option of page
type PageOption struct {
        TrimBox  *Box
        PageSize *Rect
}

func (p PageOption) isEmpty() bool <span class="cov8" title="1">{
        return p.PageSize == nil
}</span>

func (p PageOption) isTrimBoxSet() bool <span class="cov8" title="1">{
        if p.TrimBox == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if p.TrimBox.Top == 0 &amp;&amp; p.TrimBox.Left == 0 &amp;&amp; p.TrimBox.Bottom == 0 &amp;&amp; p.TrimBox.Right == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package gopdf

import "errors"

// ErrInvalidRotation is returned when a rotation angle is not a multiple of 90.
var ErrInvalidRotation = errors.New("rotation must be a multiple of 90 degrees (0, 90, 180, 270)")

// SetPageRotation sets the display rotation for a page.
// pageNo is 1-based. angle must be a multiple of 90 (0, 90, 180, 270).
// This sets the /Rotate entry in the page dictionary, which tells PDF viewers
// how to display the page. It does not modify the page content.
//
// Example:
//
//        pdf.SetPageRotation(1, 90)  // rotate page 1 by 90 degrees clockwise
func (gp *GoPdf) SetPageRotation(pageNo int, angle int) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">if angle%90 != 0 </span><span class="cov8" title="1">{
                return ErrInvalidRotation
        }</span>
        // Normalize to 0-359 range.
        <span class="cov8" title="1">angle = ((angle % 360) + 360) % 360

        page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page.rotation = angle
        return nil</span>
}

// GetPageRotation returns the display rotation angle for a page.
// pageNo is 1-based. Returns 0 if no rotation is set.
func (gp *GoPdf) GetPageRotation(pageNo int) (int, error) <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        if pageNo &lt; 1 || pageNo &gt; numPages </span><span class="cov8" title="1">{
                return 0, ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">page := gp.findPageObj(pageNo)
        if page == nil </span><span class="cov0" title="0">{
                return 0, ErrPageOutOfRange
        }</span>
        <span class="cov8" title="1">return page.rotation, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// PagesObj pdf pages object
type PagesObj struct { //impl IObj
        PageCount int
        Kids      string
        getRoot   func() *GoPdf
}

func (p *PagesObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        p.PageCount = 0
        p.getRoot = funcGetRoot
}</span>

func (p *PagesObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{

        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "  /Type /%s\n", p.getType())

        rootConfig := p.getRoot().config
        fmt.Fprintf(w, "  /MediaBox [ 0 0 %0.2f %0.2f ]\n", rootConfig.PageSize.W, rootConfig.PageSize.H)
        fmt.Fprintf(w, "  /Count %d\n", p.PageCount)
        fmt.Fprintf(w, "  /Kids [ %s ]\n", p.Kids) //sample Kids [ 3 0 R ]
        io.WriteString(w, "&gt;&gt;\n")
        return nil
}</span>

func (p *PagesObj) getType() string <span class="cov8" title="1">{
        return "Pages"
}</span>

func (p *PagesObj) test() <span class="cov8" title="1">{
        fmt.Print(p.getType() + "\n")
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package gopdf

import "strings"

// Extended paper size definitions (ISO A-series, B-series, and common US sizes).
// All values are in points (1 point = 1/72 inch).

// ISO A-series (portrait)
var (
        PageSizeA6  = &amp;Rect{W: 298, H: 420, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA7  = &amp;Rect{W: 210, H: 298, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA8  = &amp;Rect{W: 148, H: 210, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA9  = &amp;Rect{W: 105, H: 148, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA10 = &amp;Rect{W: 74, H: 105, unitOverride: defaultUnitConfig{Unit: UnitPT}}
)

// ISO A-series landscape
var (
        PageSizeA0Landscape  = &amp;Rect{W: 3371, H: 2384, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA1Landscape  = &amp;Rect{W: 2384, H: 1685, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA2Landscape  = &amp;Rect{W: 1684, H: 1190, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA5Landscape  = &amp;Rect{W: 595, H: 420, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA6Landscape  = &amp;Rect{W: 420, H: 298, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA7Landscape  = &amp;Rect{W: 298, H: 210, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA8Landscape  = &amp;Rect{W: 210, H: 148, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA9Landscape  = &amp;Rect{W: 148, H: 105, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeA10Landscape = &amp;Rect{W: 105, H: 74, unitOverride: defaultUnitConfig{Unit: UnitPT}}
)

// ISO B-series
var (
        PageSizeB0 = &amp;Rect{W: 2835, H: 4008, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB1 = &amp;Rect{W: 2004, H: 2835, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB2 = &amp;Rect{W: 1417, H: 2004, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB3 = &amp;Rect{W: 1001, H: 1417, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        // B4 and B5 already defined in page_sizes.go
        PageSizeB6  = &amp;Rect{W: 363, H: 516, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB7  = &amp;Rect{W: 258, H: 363, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB8  = &amp;Rect{W: 181, H: 258, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB9  = &amp;Rect{W: 127, H: 181, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeB10 = &amp;Rect{W: 91, H: 127, unitOverride: defaultUnitConfig{Unit: UnitPT}}
)

// US sizes
var (
        PageSizeLetterLandscape = &amp;Rect{W: 792, H: 612, unitOverride: defaultUnitConfig{Unit: UnitPT}}
        PageSizeLegalLandscape  = &amp;Rect{W: 1008, H: 612, unitOverride: defaultUnitConfig{Unit: UnitPT}}
)

// paperSizeMap maps lowercase paper size names to their Rect definitions.
var paperSizeMap = map[string]*Rect{
        // ISO A-series portrait
        "a0": PageSizeA0, "a1": PageSizeA1, "a2": PageSizeA2,
        "a3": PageSizeA3, "a4": PageSizeA4, "a5": PageSizeA5,
        "a6": PageSizeA6, "a7": PageSizeA7, "a8": PageSizeA8,
        "a9": PageSizeA9, "a10": PageSizeA10,

        // ISO A-series landscape
        "a0-l": PageSizeA0Landscape, "a1-l": PageSizeA1Landscape,
        "a2-l": PageSizeA2Landscape, "a3-l": PageSizeA3Landscape,
        "a4-l": PageSizeA4Landscape, "a5-l": PageSizeA5Landscape,
        "a6-l": PageSizeA6Landscape, "a7-l": PageSizeA7Landscape,
        "a8-l": PageSizeA8Landscape, "a9-l": PageSizeA9Landscape,
        "a10-l": PageSizeA10Landscape,

        // ISO B-series
        "b0": PageSizeB0, "b1": PageSizeB1, "b2": PageSizeB2,
        "b3": PageSizeB3, "b4": PageSizeB4, "b5": PageSizeB5,
        "b6": PageSizeB6, "b7": PageSizeB7, "b8": PageSizeB8,
        "b9": PageSizeB9, "b10": PageSizeB10,

        // US sizes
        "letter": PageSizeLetter, "letter-l": PageSizeLetterLandscape,
        "legal": PageSizeLegal, "legal-l": PageSizeLegalLandscape,
        "tabloid": PageSizeTabloid, "ledger": PageSizeLedger,
        "statement": PageSizeStatement, "executive": PageSizeExecutive,
        "folio": PageSizeFolio, "quarto": PageSizeQuarto,
}

// PaperSize returns the page size Rect for a given paper name.
// Supported names: a0â€“a10, b0â€“b10, letter, legal, tabloid, ledger,
// statement, executive, folio, quarto.
// Append "-l" for landscape (e.g. "a4-l", "letter-l").
// The name is case-insensitive. Returns nil if the name is not recognized.
func PaperSize(name string) *Rect <span class="cov8" title="1">{
        r, ok := paperSizeMap[strings.ToLower(strings.TrimSpace(name))]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Return a copy so callers can't mutate the global.
        <span class="cov8" title="1">cp := *r
        return &amp;cp</span>
}

// PaperSizeNames returns all supported paper size names.
func PaperSizeNames() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(paperSizeMap))
        for k := range paperSizeMap </span><span class="cov8" title="1">{
                names = append(names, k)
        }</span>
        <span class="cov8" title="1">return names</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package gopdf

import (
        "bytes"
        "crypto/md5"
        "crypto/rc4"
        "encoding/binary"
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

var (
        ErrEncryptedPDF      = errors.New("PDF is encrypted; call OpenPDF with Password option")
        ErrInvalidPassword   = errors.New("invalid password")
        ErrUnsupportedCrypto = errors.New("unsupported encryption version (only V1/V2 R2/R3 supported)")
)

// decryptContext holds the state needed to decrypt a PDF.
type decryptContext struct {
        encryptionKey []byte
        keyLen        int // key length in bytes (5 for 40-bit, up to 16 for 128-bit)
        v             int // /V value
        r             int // /R value
}

// Pre-compiled regexes for PDF decryption.
var (
        reEncryptRef       = regexp.MustCompile(`/Encrypt\s+(\d+)\s+\d+\s+R`)
        reEncryptRefRemove = regexp.MustCompile(`/Encrypt\s+\d+\s+\d+\s+R\s*\n?`)
)

// detectEncryption checks if the PDF data contains an /Encrypt reference
// in the trailer and returns the encryption object number, or 0 if not encrypted.
func detectEncryption(data []byte) int <span class="cov8" title="1">{
        // Find trailer dictionary.
        trailerIdx := bytes.LastIndex(data, []byte("trailer"))
        if trailerIdx &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">trailer := string(data[trailerIdx:])
        m := reEncryptRef.FindStringSubmatch(trailer)
        if m == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">n, _ := strconv.Atoi(m[1])
        return n</span>
}

// parseEncryptDict extracts encryption parameters from an encrypt dictionary string.
func parseEncryptDict(dict string) (v, r, keyLen int, oValue, uValue []byte, pValue int, err error) <span class="cov8" title="1">{
        v = extractSignedIntValue(dict, "/V")
        r = extractSignedIntValue(dict, "/R")
        pValue = extractSignedIntValue(dict, "/P")

        keyLen = 5 // default 40-bit
        if lv := extractSignedIntValue(dict, "/Length"); lv &gt; 0 </span><span class="cov8" title="1">{
                keyLen = lv / 8
        }</span>
        <span class="cov8" title="1">if v == 1 </span><span class="cov8" title="1">{
                keyLen = 5
        }</span>

        // Only support V1 (R2, 40-bit RC4) and V2 (R3, up to 128-bit RC4).
        <span class="cov8" title="1">if v != 1 &amp;&amp; v != 2 </span><span class="cov8" title="1">{
                err = ErrUnsupportedCrypto
                return
        }</span>
        <span class="cov8" title="1">if r != 2 &amp;&amp; r != 3 </span><span class="cov8" title="1">{
                err = ErrUnsupportedCrypto
                return
        }</span>

        <span class="cov8" title="1">oValue = extractHexOrLiteralString(dict, "/O")
        uValue = extractHexOrLiteralString(dict, "/U")

        if len(oValue) &lt; 32 || len(uValue) &lt; 32 </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid O or U value in encryption dictionary")
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// authenticate attempts to authenticate with the given password and returns
// a decryptContext if successful.
func authenticate(data []byte, password string) (*decryptContext, error) <span class="cov8" title="1">{
        encObjNum := detectEncryption(data)
        if encObjNum == 0 </span><span class="cov8" title="1">{
                return nil, nil // not encrypted
        }</span>

        // Parse the encryption object.
        <span class="cov8" title="1">parser, err := newRawPDFParser(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF for decryption: %w", err)
        }</span>

        <span class="cov8" title="1">encObj, ok := parser.objects[encObjNum]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encryption object %d not found", encObjNum)
        }</span>

        <span class="cov8" title="1">v, r, keyLen, oValue, uValue, pValue, err := parseEncryptDict(encObj.dict)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pass := []byte(password)

        // Try as user password first.
        key, ok := tryUserPassword(pass, oValue, uValue, pValue, keyLen, r)
        if ok </span><span class="cov8" title="1">{
                return &amp;decryptContext{encryptionKey: key, keyLen: keyLen, v: v, r: r}, nil
        }</span>

        // Try as owner password.
        <span class="cov8" title="1">key, ok = tryOwnerPassword(pass, oValue, uValue, pValue, keyLen, r)
        if ok </span><span class="cov8" title="1">{
                return &amp;decryptContext{encryptionKey: key, keyLen: keyLen, v: v, r: r}, nil
        }</span>

        <span class="cov8" title="1">return nil, ErrInvalidPassword</span>
}

// tryUserPassword attempts to authenticate with a user password.
func tryUserPassword(userPass, oValue, uValue []byte, pValue, keyLen, r int) ([]byte, bool) <span class="cov8" title="1">{
        key := computeEncryptionKey(userPass, oValue, pValue, keyLen, r)
        computedU := computeUValue(key, r)
        if r == 2 </span><span class="cov8" title="1">{
                return key, bytes.Equal(computedU, uValue[:32])
        }</span>
        // R3: compare first 16 bytes only.
        <span class="cov8" title="1">return key, bytes.Equal(computedU[:16], uValue[:16])</span>
}

// tryOwnerPassword attempts to authenticate with an owner password.
func tryOwnerPassword(ownerPass, oValue, uValue []byte, pValue, keyLen, r int) ([]byte, bool) <span class="cov8" title="1">{
        // Recover the user password from the O value.
        paddedOwner := padPassword(ownerPass)
        hash := md5.Sum(paddedOwner)
        ownerKey := hash[:]

        if r &gt;= 3 </span><span class="cov8" title="1">{
                for i := 0; i &lt; 50; i++ </span><span class="cov8" title="1">{
                        h := md5.Sum(ownerKey[:keyLen])
                        ownerKey = h[:]
                }</span>
        }
        <span class="cov8" title="1">ownerKey = ownerKey[:keyLen]

        var userPass []byte
        if r == 2 </span><span class="cov8" title="1">{
                cip, err := rc4.NewCipher(ownerKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov8" title="1">userPass = make([]byte, 32)
                cip.XORKeyStream(userPass, oValue[:32])</span>
        } else<span class="cov8" title="1"> {
                userPass = make([]byte, 32)
                copy(userPass, oValue[:32])
                for i := 19; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        tmpKey := make([]byte, len(ownerKey))
                        for j := range ownerKey </span><span class="cov8" title="1">{
                                tmpKey[j] = ownerKey[j] ^ byte(i)
                        }</span>
                        <span class="cov8" title="1">cip, err := rc4.NewCipher(tmpKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">cip.XORKeyStream(userPass, userPass)</span>
                }
        }

        <span class="cov8" title="1">return tryUserPassword(userPass, oValue, uValue, pValue, keyLen, r)</span>
}

// computeEncryptionKey computes the encryption key per PDF spec Algorithm 2.
func computeEncryptionKey(userPass, oValue []byte, pValue, keyLen, r int) []byte <span class="cov8" title="1">{
        padded := padPassword(userPass)
        m := md5.New()
        m.Write(padded)
        m.Write(oValue[:32])

        pBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(pBytes, uint32(int32(pValue)))
        m.Write(pBytes)

        // We don't have the file ID, so we skip it (common for simple encryption).
        // For a more robust implementation, the file ID from the trailer would be used.

        hash := m.Sum(nil)

        if r &gt;= 3 </span><span class="cov8" title="1">{
                for i := 0; i &lt; 50; i++ </span><span class="cov8" title="1">{
                        h := md5.Sum(hash[:keyLen])
                        hash = h[:]
                }</span>
        }

        <span class="cov8" title="1">return hash[:keyLen]</span>
}

// computeUValue computes the expected U value for verification.
func computeUValue(key []byte, r int) []byte <span class="cov8" title="1">{
        if r == 2 </span><span class="cov8" title="1">{
                cip, err := rc4.NewCipher(key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">result := make([]byte, 32)
                cip.XORKeyStream(result, protectionPadding)
                return result</span>
        }

        // R3: Algorithm 5.
        <span class="cov8" title="1">m := md5.New()
        m.Write(protectionPadding)
        // File ID would be added here for full compliance.
        hash := m.Sum(nil)

        cip, err := rc4.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">result := make([]byte, 16)
        cip.XORKeyStream(result, hash[:16])

        for i := 1; i &lt;= 19; i++ </span><span class="cov8" title="1">{
                tmpKey := make([]byte, len(key))
                for j := range key </span><span class="cov8" title="1">{
                        tmpKey[j] = key[j] ^ byte(i)
                }</span>
                <span class="cov8" title="1">cip2, err := rc4.NewCipher(tmpKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">cip2.XORKeyStream(result, result)</span>
        }

        // Pad to 32 bytes.
        <span class="cov8" title="1">padded := make([]byte, 32)
        copy(padded, result)
        return padded</span>
}

// padPassword pads or truncates a password to 32 bytes using the standard padding.
func padPassword(pass []byte) []byte <span class="cov8" title="1">{
        padded := make([]byte, 32)
        n := copy(padded, pass)
        if n &lt; 32 </span><span class="cov8" title="1">{
                copy(padded[n:], protectionPadding)
        }</span>
        <span class="cov8" title="1">return padded</span>
}

// decryptObjectStream decrypts a stream using the per-object key.
func (dc *decryptContext) decryptStream(objNum int, data []byte) ([]byte, error) <span class="cov8" title="1">{
        key := dc.objectKey(objNum)
        cip, err := rc4.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := make([]byte, len(data))
        cip.XORKeyStream(result, data)
        return result, nil</span>
}

// objectKey computes the per-object encryption key.
func (dc *decryptContext) objectKey(objNum int) []byte <span class="cov8" title="1">{
        tmp := make([]byte, dc.keyLen+5)
        copy(tmp, dc.encryptionKey)
        tmp[dc.keyLen] = byte(objNum &amp; 0xff)
        tmp[dc.keyLen+1] = byte((objNum &gt;&gt; 8) &amp; 0xff)
        tmp[dc.keyLen+2] = byte((objNum &gt;&gt; 16) &amp; 0xff)
        tmp[dc.keyLen+3] = 0 // generation number low byte
        tmp[dc.keyLen+4] = 0 // generation number high byte

        hash := md5.Sum(tmp)
        n := dc.keyLen + 5
        if n &gt; 16 </span><span class="cov0" title="0">{
                n = 16
        }</span>
        <span class="cov8" title="1">return hash[:n]</span>
}

// decryptPDF decrypts all streams and strings in the PDF data.
// Returns the decrypted PDF data with the /Encrypt reference removed.
func decryptPDF(data []byte, dc *decryptContext) []byte <span class="cov8" title="1">{
        parser, err := newRawPDFParser(data)
        if err != nil </span><span class="cov0" title="0">{
                return data
        }</span>

        <span class="cov8" title="1">result := make([]byte, len(data))
        copy(result, data)

        for objNum, obj := range parser.objects </span><span class="cov8" title="1">{
                if obj.stream == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Find the raw (undecoded) stream in the original data.
                <span class="cov8" title="1">objHeader := fmt.Sprintf("%d 0 obj", objNum)
                idx := bytes.Index(data, []byte(objHeader))
                if idx &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">objData := data[idx:]
                endIdx := bytes.Index(objData, []byte("endobj"))
                if endIdx &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">objData = objData[:endIdx+6]

                streamStart := bytes.Index(objData, []byte("stream"))
                if streamStart &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">rawStream := objData[streamStart+6:]
                if len(rawStream) &gt; 0 &amp;&amp; rawStream[0] == '\r' </span><span class="cov0" title="0">{
                        rawStream = rawStream[1:]
                }</span>
                <span class="cov8" title="1">if len(rawStream) &gt; 0 &amp;&amp; rawStream[0] == '\n' </span><span class="cov8" title="1">{
                        rawStream = rawStream[1:]
                }</span>
                <span class="cov8" title="1">endStream := bytes.Index(rawStream, []byte("endstream"))
                if endStream &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">rawStream = rawStream[:endStream]
                rawStream = bytes.TrimRight(rawStream, "\r\n")

                // Decrypt the raw stream.
                decrypted, err := dc.decryptStream(objNum, rawStream)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If FlateDecode, try to decompress to verify decryption worked.
                <span class="cov8" title="1">if strings.Contains(obj.dict, "/FlateDecode") </span><span class="cov8" title="1">{
                        if _, err := zlibDecompress(decrypted); err != nil </span><span class="cov8" title="1">{
                                continue</span> // decryption may have failed, skip
                        }
                }

                // Replace the raw stream in the result.
                <span class="cov8" title="1">result = replaceObjectStream(result, objNum, obj.dict, decrypted)</span>
        }

        // Remove /Encrypt reference from trailer.
        <span class="cov8" title="1">result = removeEncryptFromTrailer(result)
        result = rebuildXref(result)
        return result</span>
}

// removeEncryptFromTrailer removes the /Encrypt entry from the PDF trailer.
func removeEncryptFromTrailer(data []byte) []byte <span class="cov8" title="1">{
        return reEncryptRefRemove.ReplaceAll(data, nil)
}</span>

// extractSignedIntValue extracts a (possibly negative) integer value for a given key from a PDF dictionary.
// Uses string search instead of regex for performance.
func extractSignedIntValue(dict, key string) int <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        // Skip whitespace
        i := 0
        for i &lt; len(rest) &amp;&amp; (rest[i] == ' ' || rest[i] == '\t' || rest[i] == '\r' || rest[i] == '\n') </span><span class="cov8" title="1">{
                i++
        }</span>
        // Read optional minus sign and digits
        <span class="cov8" title="1">start := i
        if i &lt; len(rest) &amp;&amp; rest[i] == '-' </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">for i &lt; len(rest) &amp;&amp; rest[i] &gt;= '0' &amp;&amp; rest[i] &lt;= '9' </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">if i &gt; start </span><span class="cov8" title="1">{
                v, _ := strconv.Atoi(rest[start:i])
                return v
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// extractHexOrLiteralString extracts a string value (hex or literal) for a key.
func extractHexOrLiteralString(dict, key string) []byte <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">rest := strings.TrimSpace(dict[idx+len(key):])

        if len(rest) &gt; 0 &amp;&amp; rest[0] == '&lt;' </span><span class="cov8" title="1">{
                // Hex string.
                end := strings.Index(rest, "&gt;")
                if end &lt; 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">hex := rest[1:end]
                return decodeHexString(hex)</span>
        }

        <span class="cov8" title="1">if len(rest) &gt; 0 &amp;&amp; rest[0] == '(' </span><span class="cov8" title="1">{
                // Literal string.
                return decodeLiteralString(rest)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// decodeHexString decodes a PDF hex string.
func decodeHexString(hex string) []byte <span class="cov8" title="1">{
        hex = strings.ReplaceAll(hex, " ", "")
        hex = strings.ReplaceAll(hex, "\n", "")
        hex = strings.ReplaceAll(hex, "\r", "")
        if len(hex)%2 != 0 </span><span class="cov8" title="1">{
                hex += "0"
        }</span>
        <span class="cov8" title="1">result := make([]byte, len(hex)/2)
        for i := 0; i &lt; len(hex); i += 2 </span><span class="cov8" title="1">{
                b, _ := strconv.ParseUint(hex[i:i+2], 16, 8)
                result[i/2] = byte(b)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// decodeLiteralString decodes a PDF literal string starting with '('.
func decodeLiteralString(s string) []byte <span class="cov8" title="1">{
        if len(s) == 0 || s[0] != '(' </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">depth := 0
        var result []byte
        i := 0
        for i &lt; len(s) </span><span class="cov8" title="1">{
                ch := s[i]
                if ch == '(' </span><span class="cov8" title="1">{
                        depth++
                        if depth &gt; 1 </span><span class="cov8" title="1">{
                                result = append(result, ch)
                        }</span>
                } else<span class="cov8" title="1"> if ch == ')' </span><span class="cov8" title="1">{
                        depth--
                        if depth == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">result = append(result, ch)</span>
                } else<span class="cov8" title="1"> if ch == '\\' &amp;&amp; i+1 &lt; len(s) </span><span class="cov8" title="1">{
                        i++
                        next := s[i]
                        switch next </span>{
                        case 'n':<span class="cov8" title="1">
                                result = append(result, '\n')</span>
                        case 'r':<span class="cov8" title="1">
                                result = append(result, '\r')</span>
                        case 't':<span class="cov8" title="1">
                                result = append(result, '\t')</span>
                        case '\\':<span class="cov8" title="1">
                                result = append(result, '\\')</span>
                        case '(':<span class="cov8" title="1">
                                result = append(result, '(')</span>
                        case ')':<span class="cov8" title="1">
                                result = append(result, ')')</span>
                        default:<span class="cov8" title="1">
                                // Octal escape.
                                if next &gt;= '0' &amp;&amp; next &lt;= '7' </span><span class="cov8" title="1">{
                                        oct := string(next)
                                        for j := 0; j &lt; 2 &amp;&amp; i+1 &lt; len(s) &amp;&amp; s[i+1] &gt;= '0' &amp;&amp; s[i+1] &lt;= '7'; j++ </span><span class="cov8" title="1">{
                                                i++
                                                oct += string(s[i])
                                        }</span>
                                        <span class="cov8" title="1">v, _ := strconv.ParseUint(oct, 8, 8)
                                        result = append(result, byte(v))</span>
                                } else<span class="cov0" title="0"> {
                                        result = append(result, next)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        result = append(result, ch)
                }</span>
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package gopdf

import (
        "compress/zlib"
        "errors"
        "fmt"
        "io"
        "sort"

        "github.com/VantageDataChat/GoPDF2/fontmaker/core"
)

// EntrySelectors entry selectors
var EntrySelectors = []int{
        0, 0, 1, 1, 2, 2,
        2, 2, 3, 3, 3, 3,
        3, 3, 3, 3, 4, 4,
        4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4,
}

// ErrNotSupportShortIndexYet not support none short index yet
var ErrNotSupportShortIndexYet = errors.New("not support none short index yet")

// PdfDictionaryObj pdf dictionary object
type PdfDictionaryObj struct {
        PtrToSubsetFontObj *SubsetFontObj
        //getRoot            func() *GoPdf
        pdfProtection *PDFProtection
}

func (p *PdfDictionaryObj) init(funcGetRoot func() *GoPdf) {<span class="cov8" title="1">
        //p.getRoot = funcGetRoot
}</span>

func (p *PdfDictionaryObj) setProtection(pr *PDFProtection) <span class="cov8" title="1">{
        p.pdfProtection = pr
}</span>

func (p *PdfDictionaryObj) protection() *PDFProtection <span class="cov8" title="1">{
        return p.pdfProtection
}</span>

func (p *PdfDictionaryObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        b, err := p.makeFont()
        if err != nil </span><span class="cov0" title="0">{
                //log.Panicf("%s", err.Error())
                return err
        }</span>

        //zipvar buff bytes.Buffer
        <span class="cov8" title="1">zbuff := GetBuffer()
        defer PutBuffer(zbuff)

        gzipwriter := zlib.NewWriter(zbuff)
        _, err = gzipwriter.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gzipwriter.Close()

        fmt.Fprintf(w, "&lt;&lt;/Length %d\n", zbuff.Len())
        io.WriteString(w, "/Filter /FlateDecode\n")
        fmt.Fprintf(w, "/Length1 %d\n", len(b))
        io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "stream\n")
        if p.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(p.protection().objectkey(objID), zbuff.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.Write(tmp)</span>
                //p.buffer.WriteString("\n")
        } else<span class="cov8" title="1"> {
                w.Write(zbuff.Bytes())
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "\nendstream\n")

        return nil</span>
}

func (p *PdfDictionaryObj) getType() string <span class="cov8" title="1">{
        return "PdfDictionary"
}</span>

// SetPtrToSubsetFontObj set subsetFontObj pointer
func (p *PdfDictionaryObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) <span class="cov8" title="1">{
        p.PtrToSubsetFontObj = ptr
}</span>

// distinctInts distinct number in nn ( value in nn must sorted )
func (p *PdfDictionaryObj) distinctInts(nn []int) []int <span class="cov8" title="1">{
        var buff []int
        var prev = -1
        for _, g := range nn </span><span class="cov8" title="1">{
                if g == prev </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">buff = append(buff, g)
                prev = g</span>
        }
        <span class="cov8" title="1">return buff</span>
}

func (p *PdfDictionaryObj) makeGlyfAndLocaTable() ([]byte, []int, error) <span class="cov8" title="1">{
        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        var glyf core.TableDirectoryEntry

        numGlyphs := int(ttfp.NumGlyphs())

        glyphArray := p.completeGlyphClosure(p.PtrToSubsetFontObj.CharacterToGlyphIndex)
        sort.Ints(glyphArray)
        glyphArray = p.distinctInts(glyphArray)
        glyphCount := len(glyphArray)

        size := 0
        for idx := 0; idx &lt; glyphCount; idx++ </span><span class="cov8" title="1">{
                size += p.getGlyphSize(glyphArray[idx])
        }</span>
        <span class="cov8" title="1">glyf.Length = uint(size)

        glyphTable := make([]byte, glyf.PaddedLength())
        locaTable := make([]int, numGlyphs+1)

        glyphOffset := 0
        glyphIndex := 0
        oldglyph := -1
        for idx := 0; idx &lt; numGlyphs; idx++ </span><span class="cov8" title="1">{
                locaTable[idx] = glyphOffset

                if glyphIndex &lt; glyphCount </span><span class="cov8" title="1">{
                        if glyphArray[glyphIndex] == idx </span><span class="cov8" title="1">{
                                oldglyph = glyphArray[glyphIndex]
                                glyphIndex++
                                bytes := p.getGlyphData(idx)
                                length := len(bytes)
                                if length &gt; 0 </span><span class="cov8" title="1">{
                                        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                                                glyphTable[glyphOffset+i] = bytes[i]
                                        }</span>
                                        <span class="cov8" title="1">glyphOffset += length</span>
                                }
                        } else<span class="cov8" title="1"> if oldglyph == glyphArray[glyphIndex] </span><span class="cov0" title="0">{
                                glyphIndex++
                                bytes := p.getGlyphData(idx)
                                length := len(bytes)
                                if length &gt; 0 </span><span class="cov0" title="0">{
                                        for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                                                glyphTable[glyphOffset+i] = bytes[i]
                                        }</span>
                                        <span class="cov0" title="0">glyphOffset += length</span>
                                }
                        }
                }
        } //end for
        <span class="cov8" title="1">locaTable[numGlyphs] = glyphOffset
        return glyphTable, locaTable, nil</span>
}

func (p *PdfDictionaryObj) getGlyphSize(glyph int) int <span class="cov8" title="1">{

        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        glyf := ttfp.GetTables()["glyf"]
        start := int(glyf.Offset + ttfp.LocaTable[glyph])
        next := int(glyf.Offset + ttfp.LocaTable[glyph+1])
        return next - start
}</span>

func (p *PdfDictionaryObj) getGlyphData(glyph int) []byte <span class="cov8" title="1">{
        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        glyf := ttfp.GetTables()["glyf"]
        start := int(glyf.Offset + ttfp.LocaTable[glyph])
        next := int(glyf.Offset + ttfp.LocaTable[glyph+1])
        count := next - start
        var data []byte
        i := 0
        for i &lt; count </span><span class="cov8" title="1">{
                data = append(data, ttfp.FontData()[start+i])
                i++
        }</span>
        <span class="cov8" title="1">return data</span>
}

func (p *PdfDictionaryObj) makeFont() ([]byte, error) <span class="cov8" title="1">{
        var buff Buff
        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        tables := make(map[string]core.TableDirectoryEntry)
        tables["cvt "] = ttfp.GetTables()["cvt "] //à¸¡à¸µà¸Šà¹ˆà¸­à¸‡à¸§à¹ˆà¸²à¸‡à¸”à¹‰à¸§à¸¢à¸™à¸°
        tables["fpgm"] = ttfp.GetTables()["fpgm"]
        tables["glyf"] = ttfp.GetTables()["glyf"]
        tables["head"] = ttfp.GetTables()["head"]
        tables["hhea"] = ttfp.GetTables()["hhea"]
        tables["hmtx"] = ttfp.GetTables()["hmtx"]
        tables["loca"] = ttfp.GetTables()["loca"]
        tables["maxp"] = ttfp.GetTables()["maxp"]
        tables["prep"] = ttfp.GetTables()["prep"]
        tableCount := len(tables)
        selector := EntrySelectors[tableCount]

        glyphTable, locaTable, err := p.makeGlyfAndLocaTable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">WriteUInt32(&amp;buff, 0x00010000)
        WriteUInt16(&amp;buff, uint(tableCount))
        WriteUInt16(&amp;buff, ((1 &lt;&lt; uint(selector)) * 16))
        WriteUInt16(&amp;buff, uint(selector))
        WriteUInt16(&amp;buff, (uint(tableCount)-(1&lt;&lt;uint(selector)))*16)

        var tags []string
        for tag := range tables </span><span class="cov8" title="1">{
                tags = append(tags, tag) //copy all tag
        }</span>
        <span class="cov8" title="1">sort.Strings(tags) //order
        idx := 0
        tablePosition := int(12 + 16*tableCount)
        for idx &lt; tableCount </span><span class="cov8" title="1">{
                entry := tables[tags[idx]]
                //write data
                offset := uint64(tablePosition)
                buff.SetPosition(tablePosition)
                if tags[idx] == "glyf" </span><span class="cov8" title="1">{
                        entry.Length = uint(len(glyphTable))
                        entry.CheckSum = CheckSum(glyphTable)
                        WriteBytes(&amp;buff, glyphTable, 0, entry.PaddedLength())
                }</span> else<span class="cov8" title="1"> if tags[idx] == "loca" </span><span class="cov8" title="1">{
                        if ttfp.IsShortIndex </span><span class="cov0" title="0">{
                                entry.Length = uint(len(locaTable) * 2)
                        }</span> else<span class="cov8" title="1"> {
                                entry.Length = uint(len(locaTable) * 4)
                        }</span>

                        <span class="cov8" title="1">data := make([]byte, entry.PaddedLength())
                        length := len(locaTable)
                        byteIdx := 0
                        if ttfp.IsShortIndex </span><span class="cov0" title="0">{
                                for idx := 0; idx &lt; length; idx++ </span><span class="cov0" title="0">{
                                        val := locaTable[idx] / 2
                                        data[byteIdx] = byte(val &gt;&gt; 8)
                                        byteIdx++
                                        data[byteIdx] = byte(val)
                                        byteIdx++
                                }</span>
                        } else<span class="cov8" title="1"> {
                                for idx := 0; idx &lt; length; idx++ </span><span class="cov8" title="1">{
                                        val := locaTable[idx]
                                        data[byteIdx] = byte(val &gt;&gt; 24)
                                        byteIdx++
                                        data[byteIdx] = byte(val &gt;&gt; 16)
                                        byteIdx++
                                        data[byteIdx] = byte(val &gt;&gt; 8)
                                        byteIdx++
                                        data[byteIdx] = byte(val)
                                        byteIdx++
                                }</span>
                        }
                        <span class="cov8" title="1">entry.CheckSum = CheckSum(data)
                        WriteBytes(&amp;buff, data, 0, len(data))</span>
                } else<span class="cov8" title="1"> {
                        WriteBytes(&amp;buff, ttfp.FontData(), int(entry.Offset), entry.PaddedLength())
                }</span>
                <span class="cov8" title="1">endPosition := buff.Position()
                tablePosition = endPosition

                //write table
                buff.SetPosition(idx*16 + 12)
                WriteTag(&amp;buff, tags[idx])
                WriteUInt32(&amp;buff, uint(entry.CheckSum))
                WriteUInt32(&amp;buff, uint(offset)) //offset
                WriteUInt32(&amp;buff, uint(entry.Length))

                tablePosition = endPosition
                idx++</span>
        }
        //DebugSubType(buff.Bytes())
        //me.buffer.Write(buff.Bytes())
        <span class="cov8" title="1">return buff.Bytes(), nil</span>
}

func (p *PdfDictionaryObj) completeGlyphClosure(mapOfglyphs *MapOfCharacterToGlyphIndex) []int <span class="cov8" title="1">{
        var glyphArray []int
        //copy
        isContainZero := false
        glyphs := mapOfglyphs.AllVals()
        for _, v := range glyphs </span><span class="cov8" title="1">{
                glyphArray = append(glyphArray, int(v))
                if v == 0 </span><span class="cov8" title="1">{
                        isContainZero = true
                }</span>
        }
        <span class="cov8" title="1">if !isContainZero </span><span class="cov8" title="1">{
                glyphArray = append(glyphArray, 0)
        }</span>

        <span class="cov8" title="1">i := 0
        count := len(glyphs)
        for i &lt; count </span><span class="cov8" title="1">{
                p.AddCompositeGlyphs(&amp;glyphArray, glyphArray[i])
                i++
        }</span>
        <span class="cov8" title="1">return glyphArray</span>
}

// AddCompositeGlyphs add composite glyph
// composite glyph is a Unicode entity that can be defined as a sequence of one or more other characters.
func (p *PdfDictionaryObj) AddCompositeGlyphs(glyphArray *[]int, glyph int) <span class="cov8" title="1">{
        start := p.GetOffset(int(glyph))
        if start == p.GetOffset(int(glyph)+1) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">offset := start
        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        fontData := ttfp.FontData()
        numContours, step := ReadShortFromByte(fontData, offset)
        offset += step
        if numContours &gt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">offset += 8
        for </span><span class="cov8" title="1">{
                flags, step1 := ReadUShortFromByte(fontData, offset)
                offset += step1
                cGlyph, step2 := ReadUShortFromByte(fontData, offset)
                offset += step2
                //check cGlyph is contain in glyphArray?
                glyphContainsKey := false
                for _, g := range *glyphArray </span><span class="cov8" title="1">{
                        if g == int(cGlyph) </span><span class="cov8" title="1">{
                                glyphContainsKey = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !glyphContainsKey </span><span class="cov8" title="1">{
                        *glyphArray = append(*glyphArray, int(cGlyph))
                }</span>

                <span class="cov8" title="1">if (flags &amp; moreComponents) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">offsetAppend := 4
                if (flags &amp; arg1and2areWords) == 0 </span><span class="cov8" title="1">{
                        offsetAppend = 2
                }</span>
                <span class="cov8" title="1">if (flags &amp; hasScale) != 0 </span><span class="cov0" title="0">{
                        offsetAppend += 2
                }</span> else<span class="cov8" title="1"> if (flags &amp; xAndYScale) != 0 </span><span class="cov0" title="0">{
                        offsetAppend += 4
                }</span>
                <span class="cov8" title="1">if (flags &amp; twoByTwo) != 0 </span><span class="cov0" title="0">{
                        offsetAppend += 8
                }</span>
                <span class="cov8" title="1">offset += offsetAppend</span>
        }
}

const hasScale = 8
const moreComponents = 32
const arg1and2areWords = 1
const xAndYScale = 64
const twoByTwo = 128

// GetOffset get offset from glyf table
func (p *PdfDictionaryObj) GetOffset(glyph int) int <span class="cov8" title="1">{
        ttfp := p.PtrToSubsetFontObj.GetTTFParser()
        glyf := ttfp.GetTables()["glyf"]
        offset := int(glyf.Offset + ttfp.LocaTable[glyph])
        return offset
}</span>

// CheckSum check sum
func CheckSum(data []byte) uint <span class="cov8" title="1">{

        var byte3, byte2, byte1, byte0 uint64
        byte3 = 0
        byte2 = 0
        byte1 = 0
        byte0 = 0
        length := len(data)
        i := 0
        for i &lt; length </span><span class="cov8" title="1">{
                byte3 += uint64(data[i])
                i++
                byte2 += uint64(data[i])
                i++
                byte1 += uint64(data[i])
                i++
                byte0 += uint64(data[i])
                i++
        }</span>
        //var result uint32
        <span class="cov8" title="1">result := uint32(byte3&lt;&lt;24) + uint32(byte2&lt;&lt;16) + uint32(byte1&lt;&lt;8) + uint32(byte0)
        return uint(result)</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "strconv"
        "strings"
)

// ============================================================
// Low-level PDF Operations â€” direct read/write of PDF objects,
// dictionary keys, streams, catalog, and trailer.
// These are standalone functions operating on raw PDF bytes,
// similar to PyMuPDF's xref_object / update_object / etc.
// ============================================================

// PDFObject represents a parsed low-level PDF object.
type PDFObject struct {
        // Num is the object number.
        Num int
        // Generation is the generation number (usually 0).
        Generation int
        // Dict is the dictionary content (between &lt;&lt; &gt;&gt;).
        Dict string
        // Stream is the raw stream data (nil if not a stream object).
        Stream []byte
        // Raw is the full raw object content between "N 0 obj" and "endobj".
        Raw string
}

// ReadObject reads a PDF object definition by object number.
// Returns the parsed object with its dictionary and optional stream.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        obj, err := gopdf.ReadObject(data, 5)
//        fmt.Println(obj.Dict)
func ReadObject(pdfData []byte, objNum int) (*PDFObject, error) <span class="cov8" title="1">{
        start, end, err := findObjectBounds(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">raw := string(pdfData[start:end])
        obj := &amp;PDFObject{
                Num:        objNum,
                Generation: 0,
                Raw:        raw,
        }

        // Extract dictionary.
        obj.Dict = extractDict([]byte(raw))

        // Extract stream if present.
        streamStart := strings.Index(raw, "stream\n")
        if streamStart &lt; 0 </span><span class="cov8" title="1">{
                streamStart = strings.Index(raw, "stream\r\n")
        }</span>
        <span class="cov8" title="1">if streamStart &gt;= 0 </span><span class="cov8" title="1">{
                streamEnd := strings.Index(raw, "\nendstream")
                if streamEnd &lt; 0 </span><span class="cov0" title="0">{
                        streamEnd = strings.Index(raw, "\r\nendstream")
                }</span>
                <span class="cov8" title="1">if streamEnd &gt; streamStart </span><span class="cov8" title="1">{
                        dataStart := streamStart + len("stream\n")
                        if raw[streamStart+len("stream")] == '\r' </span><span class="cov0" title="0">{
                                dataStart = streamStart + len("stream\r\n")
                        }</span>
                        <span class="cov8" title="1">obj.Stream = []byte(raw[dataStart:streamEnd])</span>
                }
        }

        <span class="cov8" title="1">return obj, nil</span>
}

// UpdateObject replaces the content of a PDF object and returns the modified PDF.
// newContent should be the full object body (dictionary + optional stream).
//
// Example:
//
//        updated, err := gopdf.UpdateObject(data, 5, "&lt;&lt; /Type /Page /MediaBox [0 0 612 792] &gt;&gt;")
func UpdateObject(pdfData []byte, objNum int, newContent string) ([]byte, error) <span class="cov8" title="1">{
        start, end, err := findObjectBounds(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        buf.Write(pdfData[:start])
        fmt.Fprintf(&amp;buf, "%d 0 obj\n%s\nendobj", objNum, newContent)
        buf.Write(pdfData[end:])

        return rebuildXref(buf.Bytes()), nil</span>
}

// GetDictKey reads a dictionary key value from a PDF object.
// Returns the raw value string, or empty string if not found.
//
// Example:
//
//        val, err := gopdf.GetDictKey(data, 5, "/Type")
//        // val might be "/Page"
func GetDictKey(pdfData []byte, objNum int, key string) (string, error) <span class="cov8" title="1">{
        obj, err := ReadObject(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return extractDictKeyValue(obj.Dict, key), nil</span>
}

// SetDictKey sets or updates a dictionary key in a PDF object.
// Returns the modified PDF data.
//
// Example:
//
//        updated, err := gopdf.SetDictKey(data, 5, "/MediaBox", "[0 0 595 842]")
func SetDictKey(pdfData []byte, objNum int, key, value string) ([]byte, error) <span class="cov8" title="1">{
        obj, err := ReadObject(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newDict := setDictKeyValue(obj.Dict, key, value)

        var newContent string
        if obj.Stream != nil </span><span class="cov0" title="0">{
                newContent = fmt.Sprintf("&lt;&lt;%s&gt;&gt;\nstream\n%s\nendstream", newDict, string(obj.Stream))
        }</span> else<span class="cov8" title="1"> {
                newContent = fmt.Sprintf("&lt;&lt;%s&gt;&gt;", newDict)
        }</span>

        <span class="cov8" title="1">return UpdateObject(pdfData, objNum, newContent)</span>
}

// GetStream reads the stream data from a PDF object.
// Returns nil if the object has no stream.
//
// Example:
//
//        stream, err := gopdf.GetStream(data, 10)
func GetStream(pdfData []byte, objNum int) ([]byte, error) <span class="cov8" title="1">{
        obj, err := ReadObject(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return obj.Stream, nil</span>
}

// SetStream replaces the stream data in a PDF object.
// The /Length key in the dictionary is automatically updated.
//
// Example:
//
//        updated, err := gopdf.SetStream(data, 10, []byte("BT /F1 12 Tf 100 700 Td (Hello) Tj ET"))
func SetStream(pdfData []byte, objNum int, streamData []byte) ([]byte, error) <span class="cov8" title="1">{
        obj, err := ReadObject(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newDict := setDictKeyValue(obj.Dict, "/Length", strconv.Itoa(len(streamData)))
        newContent := fmt.Sprintf("&lt;&lt;%s&gt;&gt;\nstream\n%s\nendstream", newDict, string(streamData))

        return UpdateObject(pdfData, objNum, newContent)</span>
}

// CopyObject duplicates a PDF object and returns the modified PDF data
// along with the new object number.
//
// Example:
//
//        newData, newObjNum, err := gopdf.CopyObject(data, 5)
func CopyObject(pdfData []byte, objNum int) ([]byte, int, error) <span class="cov8" title="1">{
        obj, err := ReadObject(pdfData, objNum)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, err
        }</span>

        // Find the highest object number.
        <span class="cov8" title="1">matches := reObjHeader.FindAllSubmatch(pdfData, -1)
        maxObj := 0
        for _, m := range matches </span><span class="cov8" title="1">{
                n, _ := strconv.Atoi(string(m[1]))
                if n &gt; maxObj </span><span class="cov8" title="1">{
                        maxObj = n
                }</span>
        }
        <span class="cov8" title="1">newObjNum := maxObj + 1

        // Insert the new object before the xref table.
        xrefIdx := bytes.LastIndex(pdfData, []byte("xref\n"))
        if xrefIdx &lt; 0 </span><span class="cov0" title="0">{
                xrefIdx = bytes.LastIndex(pdfData, []byte("xref\r\n"))
        }</span>
        <span class="cov8" title="1">if xrefIdx &lt; 0 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("cannot find xref table")
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        buf.Write(pdfData[:xrefIdx])
        fmt.Fprintf(&amp;buf, "%d 0 obj\n", newObjNum)
        // Write the raw content (dict + stream).
        if obj.Stream != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buf, "&lt;&lt;%s&gt;&gt;\nstream\n%s\nendstream\n", obj.Dict, string(obj.Stream))
        }</span> else<span class="cov8" title="1"> if obj.Dict != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "&lt;&lt;%s&gt;&gt;\n", obj.Dict)
        }</span> else<span class="cov0" title="0"> {
                buf.WriteString(obj.Raw)
                buf.WriteByte('\n')
        }</span>
        <span class="cov8" title="1">buf.WriteString("endobj\n\n")
        buf.Write(pdfData[xrefIdx:])

        return rebuildXref(buf.Bytes()), newObjNum, nil</span>
}

// GetCatalog returns the PDF Catalog dictionary object.
//
// Example:
//
//        catalog, err := gopdf.GetCatalog(data)
//        fmt.Println(catalog.Dict)
func GetCatalog(pdfData []byte) (*PDFObject, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if parser.root &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no catalog found")
        }</span>
        <span class="cov8" title="1">return ReadObject(pdfData, parser.root)</span>
}

// GetTrailer returns the PDF trailer dictionary as a string.
//
// Example:
//
//        trailer, err := gopdf.GetTrailer(data)
//        fmt.Println(trailer)
func GetTrailer(pdfData []byte) (string, error) <span class="cov8" title="1">{
        trailerIdx := bytes.LastIndex(pdfData, []byte("trailer"))
        if trailerIdx &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no trailer found")
        }</span>

        <span class="cov8" title="1">startxrefIdx := bytes.Index(pdfData[trailerIdx:], []byte("startxref"))
        if startxrefIdx &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no startxref found")
        }</span>

        <span class="cov8" title="1">trailerContent := string(pdfData[trailerIdx : trailerIdx+startxrefIdx])
        return strings.TrimSpace(trailerContent), nil</span>
}

// --- internal helpers ---

// findObjectBounds locates the byte range of "N 0 obj ... endobj" in pdfData.
func findObjectBounds(pdfData []byte, objNum int) (int, int, error) <span class="cov8" title="1">{
        header := fmt.Sprintf("%d 0 obj", objNum)
        idx := bytes.Index(pdfData, []byte(header))
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("object %d not found", objNum)
        }</span>

        <span class="cov8" title="1">endMarker := []byte("endobj")
        endIdx := bytes.Index(pdfData[idx:], endMarker)
        if endIdx &lt; 0 </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("endobj not found for object %d", objNum)
        }</span>
        <span class="cov8" title="1">endIdx = idx + endIdx + len(endMarker)

        return idx, endIdx, nil</span>
}

// extractDictKeyValue extracts the value for a given key from a PDF dictionary string.
func extractDictKeyValue(dict, key string) string <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">rest := strings.TrimSpace(dict[idx+len(key):])
        if len(rest) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Handle different value types.
        <span class="cov8" title="1">switch rest[0] </span>{
        case '/':<span class="cov8" title="1"> // name
                end := strings.IndexAny(rest[1:], " /\n\r\t&gt;")
                if end &lt; 0 </span><span class="cov0" title="0">{
                        return rest
                }</span>
                <span class="cov8" title="1">return rest[:end+1]</span>
        case '(':<span class="cov8" title="1"> // string
                depth := 0
                for i, c := range rest </span><span class="cov8" title="1">{
                        if c == '(' </span><span class="cov8" title="1">{
                                depth++
                        }</span> else<span class="cov8" title="1"> if c == ')' </span><span class="cov8" title="1">{
                                depth--
                                if depth == 0 </span><span class="cov8" title="1">{
                                        return rest[:i+1]
                                }</span>
                        }
                }
                <span class="cov0" title="0">return rest</span>
        case '[':<span class="cov8" title="1"> // array
                depth := 0
                for i, c := range rest </span><span class="cov8" title="1">{
                        if c == '[' </span><span class="cov8" title="1">{
                                depth++
                        }</span> else<span class="cov8" title="1"> if c == ']' </span><span class="cov8" title="1">{
                                depth--
                                if depth == 0 </span><span class="cov8" title="1">{
                                        return rest[:i+1]
                                }</span>
                        }
                }
                <span class="cov0" title="0">return rest</span>
        case '&lt;':<span class="cov8" title="1"> // dict or hex string
                if len(rest) &gt; 1 &amp;&amp; rest[1] == '&lt;' </span><span class="cov8" title="1">{
                        depth := 0
                        for i := 0; i &lt; len(rest)-1; i++ </span><span class="cov8" title="1">{
                                if rest[i] == '&lt;' &amp;&amp; rest[i+1] == '&lt;' </span><span class="cov8" title="1">{
                                        depth++
                                        i++
                                }</span> else<span class="cov8" title="1"> if rest[i] == '&gt;' &amp;&amp; rest[i+1] == '&gt;' </span><span class="cov8" title="1">{
                                        depth--
                                        i++
                                        if depth == 0 </span><span class="cov8" title="1">{
                                                return rest[:i+1]
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">end := strings.Index(rest, "&gt;")
                if end &gt;= 0 </span><span class="cov8" title="1">{
                        return rest[:end+1]
                }</span>
                <span class="cov0" title="0">return rest</span>
        default:<span class="cov8" title="1"> // number, bool, reference, etc.
                end := strings.IndexAny(rest, " /\n\r\t&gt;")
                if end &lt; 0 </span><span class="cov8" title="1">{
                        return rest
                }</span>
                // Check for "N 0 R" reference pattern.
                <span class="cov8" title="1">if end &lt; len(rest) </span><span class="cov8" title="1">{
                        afterFirst := strings.TrimSpace(rest[end:])
                        if strings.HasPrefix(afterFirst, "0 R") </span><span class="cov8" title="1">{
                                return rest[:end] + " 0 R"
                        }</span>
                }
                <span class="cov8" title="1">return rest[:end]</span>
        }
}

// setDictKeyValue sets or updates a key in a PDF dictionary string.
func setDictKeyValue(dict, key, value string) string <span class="cov8" title="1">{
        // Try to replace existing key.
        idx := strings.Index(dict, key)
        if idx &gt;= 0 </span><span class="cov8" title="1">{
                // Find the end of the current value.
                rest := dict[idx+len(key):]
                valStart := 0
                for valStart &lt; len(rest) &amp;&amp; (rest[valStart] == ' ' || rest[valStart] == '\t') </span><span class="cov8" title="1">{
                        valStart++
                }</span>
                <span class="cov8" title="1">oldVal := extractDictKeyValue(dict, key)
                if oldVal != "" </span><span class="cov8" title="1">{
                        oldEntry := key + " " + oldVal
                        if strings.Contains(dict, key+" "+oldVal) </span><span class="cov8" title="1">{
                                return strings.Replace(dict, oldEntry, key+" "+value, 1)
                        }</span>
                }
        }

        // Key not found â€” add before closing &gt;&gt;.
        <span class="cov8" title="1">trimmed := strings.TrimRight(dict, " \t\n\r")
        return trimmed + "\n" + key + " " + value + "\n"</span>
}

// extractFilterValue is defined in image_extract.go

// extractName is defined in text_extract.go
</pre>
		
		<pre class="file" id="file98" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// ObjID represents a typed PDF object identifier.
// It wraps the 0-based index into the pdfObjs array and provides
// safe conversion to 1-based PDF object references.
//
// This replaces raw int indices throughout the codebase, providing
// type safety and preventing accidental misuse of array indices
// as PDF object IDs (or vice versa).
type ObjID int

const invalidObjID ObjID = -1

// Index returns the 0-based array index.
func (id ObjID) Index() int <span class="cov8" title="1">{ return int(id) }</span>

// Ref returns the 1-based PDF object reference number.
func (id ObjID) Ref() int <span class="cov8" title="1">{ return int(id) + 1 }</span>

// RefStr returns the PDF indirect reference string (e.g. "5 0 R").
func (id ObjID) RefStr() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d 0 R", id.Ref())
}</span>

// IsValid returns true if the ObjID points to a valid object.
func (id ObjID) IsValid() bool <span class="cov8" title="1">{ return id &gt;= 0 }</span>

// nullObj is a placeholder PDF object used when an object is logically
// deleted but its slot must be preserved to maintain object numbering.
// This fixes the nil-pointer crash that occurred when DeletePage set
// pdfObjs entries to nil.
type nullObj struct{}

func (n nullObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>
func (n nullObj) getType() string       <span class="cov8" title="1">{ return "Null" }</span>
func (n nullObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        _, err := io.WriteString(w, "null\n")
        return err
}</span>

// GetObjID returns the ObjID for the object at the given 0-based index.
// Returns invalidObjID if the index is out of range.
func (gp *GoPdf) GetObjID(index int) ObjID <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(gp.pdfObjs) </span><span class="cov8" title="1">{
                return invalidObjID
        }</span>
        <span class="cov8" title="1">return ObjID(index)</span>
}

// GetObjByID returns the IObj at the given ObjID.
// Returns nil if the ObjID is invalid or out of range.
func (gp *GoPdf) GetObjByID(id ObjID) IObj <span class="cov8" title="1">{
        if !id.IsValid() || id.Index() &gt;= len(gp.pdfObjs) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return gp.pdfObjs[id.Index()]</span>
}

// GetObjType returns the type string of the object at the given ObjID.
// Returns "" if the ObjID is invalid.
func (gp *GoPdf) GetObjType(id ObjID) string <span class="cov8" title="1">{
        obj := gp.GetObjByID(id)
        if obj == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return obj.getType()</span>
}

// CatalogObjID returns the ObjID of the catalog object.
func (gp *GoPdf) CatalogObjID() ObjID <span class="cov8" title="1">{
        return ObjID(gp.indexOfCatalogObj)
}</span>

// PagesObjID returns the ObjID of the pages object.
func (gp *GoPdf) PagesObjID() ObjID <span class="cov8" title="1">{
        return ObjID(gp.indexOfPagesObj)
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package gopdf

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "regexp"
        "strconv"
        "strings"
)

// Pre-compiled regexes for PDF parser â€” avoids recompilation on every call.
var (
        reObjHeader = regexp.MustCompile(`(\d+)\s+0\s+obj\b`)
        reRootRef   = regexp.MustCompile(`/Root\s+(\d+)\s+0\s+R`)
        reObjRef    = regexp.MustCompile(`(\d+)\s+0\s+R`)
        reNamedRef  = regexp.MustCompile(`/(\w+)\s+(\d+)\s+0\s+R`)
        reMediaBox  = regexp.MustCompile(`/MediaBox\s*\[\s*([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s*\]`)
)

// ============================================================
// PDF raw parser â€” reads cross-ref table, objects, streams
// from raw PDF bytes. Used for text/image extraction.
// ============================================================

// rawPDFParser parses a raw PDF byte slice to extract objects.
type rawPDFParser struct {
        data    []byte
        objects map[int]rawPDFObject // objNum -&gt; object
        pages   []rawPDFPage
        root    int // root catalog obj number
}

// rawPDFObject holds a parsed PDF object.
type rawPDFObject struct {
        num    int
        dict   string // dictionary content between &lt;&lt; &gt;&gt;
        stream []byte // decompressed stream content (nil if not a stream)
}

// rawPDFPage holds parsed page info.
type rawPDFPage struct {
        objNum    int
        mediaBox  [4]float64
        contents  []int // content stream obj numbers
        resources rawPDFResources
}

// rawPDFResources holds resource references for a page.
type rawPDFResources struct {
        fonts  map[string]int // /F1 -&gt; obj number
        xobjs  map[string]int // /Im1 -&gt; obj number
}

// newRawPDFParser creates a parser for the given PDF data.
func newRawPDFParser(data []byte) (*rawPDFParser, error) <span class="cov8" title="1">{
        p := &amp;rawPDFParser{
                data:    data,
                objects: make(map[int]rawPDFObject),
        }
        if err := p.parse(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pdf parse: %w", err)
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}

func (p *rawPDFParser) parse() error <span class="cov8" title="1">{
        p.parseObjects()
        p.findRoot()
        p.parsePages()
        return nil
}</span>

// parseObjects finds all "N 0 obj ... endobj" blocks.
func (p *rawPDFParser) parseObjects() <span class="cov8" title="1">{
        matches := reObjHeader.FindAllSubmatchIndex(p.data, -1)
        for _, m := range matches </span><span class="cov8" title="1">{
                numStr := string(p.data[m[2]:m[3]])
                num, _ := strconv.Atoi(numStr)
                objStart := m[0]
                // find endobj
                endIdx := bytes.Index(p.data[objStart:], []byte("endobj"))
                if endIdx &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">objData := p.data[objStart : objStart+endIdx+6]
                obj := rawPDFObject{num: num}
                // extract dictionary
                if dictStart := bytes.Index(objData, []byte("&lt;&lt;")); dictStart &gt;= 0 </span><span class="cov8" title="1">{
                        obj.dict = extractDict(objData[dictStart:])
                }</span>
                // extract stream
                <span class="cov8" title="1">if streamStart := bytes.Index(objData, []byte("stream")); streamStart &gt;= 0 </span><span class="cov8" title="1">{
                        streamData := objData[streamStart+6:]
                        // skip \r\n or \n after "stream"
                        if len(streamData) &gt; 0 &amp;&amp; streamData[0] == '\r' </span><span class="cov0" title="0">{
                                streamData = streamData[1:]
                        }</span>
                        <span class="cov8" title="1">if len(streamData) &gt; 0 &amp;&amp; streamData[0] == '\n' </span><span class="cov8" title="1">{
                                streamData = streamData[1:]
                        }</span>
                        <span class="cov8" title="1">if endStream := bytes.Index(streamData, []byte("endstream")); endStream &gt;= 0 </span><span class="cov8" title="1">{
                                raw := streamData[:endStream]
                                // trim trailing whitespace
                                raw = bytes.TrimRight(raw, "\r\n")
                                if strings.Contains(obj.dict, "/FlateDecode") </span><span class="cov8" title="1">{
                                        if decoded, err := zlibDecompress(raw); err == nil </span><span class="cov8" title="1">{
                                                obj.stream = decoded
                                        }</span> else<span class="cov8" title="1"> {
                                                obj.stream = raw
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        obj.stream = raw
                                }</span>
                        }
                }
                <span class="cov8" title="1">p.objects[num] = obj</span>
        }
}

// extractDict extracts the outermost &lt;&lt;...&gt;&gt; from data.
func extractDict(data []byte) string <span class="cov8" title="1">{
        depth := 0
        start := -1
        for i := 0; i &lt; len(data)-1; i++ </span><span class="cov8" title="1">{
                if data[i] == '&lt;' &amp;&amp; data[i+1] == '&lt;' </span><span class="cov8" title="1">{
                        if depth == 0 </span><span class="cov8" title="1">{
                                start = i
                        }</span>
                        <span class="cov8" title="1">depth++
                        i++</span>
                } else<span class="cov8" title="1"> if data[i] == '&gt;' &amp;&amp; data[i+1] == '&gt;' </span><span class="cov8" title="1">{
                        depth--
                        if depth == 0 </span><span class="cov8" title="1">{
                                return string(data[start : i+2])
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
        <span class="cov8" title="1">if start &gt;= 0 </span><span class="cov8" title="1">{
                return string(data[start:])
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func zlibDecompress(data []byte) ([]byte, error) <span class="cov8" title="1">{
        r, err := zlib.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        return io.ReadAll(r)</span>
}

func (p *rawPDFParser) findRoot() <span class="cov8" title="1">{
        // Look for /Root N 0 R in trailer or xref stream
        m := reRootRef.FindSubmatch(p.data)
        if m != nil </span><span class="cov8" title="1">{
                p.root, _ = strconv.Atoi(string(m[1]))
                return
        }</span>
}

func (p *rawPDFParser) parsePages() <span class="cov8" title="1">{
        rootObj, ok := p.objects[p.root]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        // Find /Pages reference
        <span class="cov8" title="1">pagesRef := extractRef(rootObj.dict, "/Pages")
        if pagesRef &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.collectPages(pagesRef)</span>
}

func (p *rawPDFParser) collectPages(objNum int) <span class="cov8" title="1">{
        obj, ok := p.objects[objNum]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if strings.Contains(obj.dict, "/Type /Page\n") || strings.Contains(obj.dict, "/Type/Page") ||
                (strings.Contains(obj.dict, "/Type /Page") &amp;&amp; !strings.Contains(obj.dict, "/Type /Pages")) </span><span class="cov8" title="1">{
                page := rawPDFPage{objNum: objNum}
                page.mediaBox = extractMediaBox(obj.dict)
                page.contents = extractContentRefs(obj.dict)
                page.resources = p.extractResources(obj.dict, objNum)
                p.pages = append(p.pages, page)
                return
        }</span>
        // It's a /Pages node â€” recurse into /Kids
        <span class="cov8" title="1">kids := extractRefArray(obj.dict, "/Kids")
        for _, kid := range kids </span><span class="cov8" title="1">{
                p.collectPages(kid)
        }</span>
}

// extractRef extracts a single "N 0 R" reference for a given key.
// Uses string search + pre-compiled regex to avoid per-call compilation.
func extractRef(dict, key string) int <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        rest = strings.TrimLeft(rest, " \t\r\n")
        m := reObjRef.FindStringSubmatch(rest)
        if m != nil </span><span class="cov8" title="1">{
                // Verify the match starts at the beginning (the ref follows the key directly)
                if strings.HasPrefix(strings.TrimLeft(rest, " \t\r\n"), m[0]) </span><span class="cov8" title="1">{
                        n, _ := strconv.Atoi(m[1])
                        return n
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

// extractRefArray extracts an array of "N 0 R" references for a given key.
func extractRefArray(dict, key string) []int <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        // find [ ... ]
        start := strings.Index(rest, "[")
        if start &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">end := strings.Index(rest[start:], "]")
        if end &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">arr := rest[start+1 : start+end]
        matches := reObjRef.FindAllStringSubmatch(arr, -1)
        var refs []int
        for _, m := range matches </span><span class="cov8" title="1">{
                n, _ := strconv.Atoi(m[1])
                refs = append(refs, n)
        }</span>
        <span class="cov8" title="1">return refs</span>
}

func extractMediaBox(dict string) [4]float64 <span class="cov8" title="1">{
        m := reMediaBox.FindStringSubmatch(dict)
        if m == nil </span><span class="cov8" title="1">{
                return [4]float64{0, 0, 612, 792} // default letter
        }</span>
        <span class="cov8" title="1">var box [4]float64
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                box[i], _ = strconv.ParseFloat(m[i+1], 64)
        }</span>
        <span class="cov8" title="1">return box</span>
}

func extractContentRefs(dict string) []int <span class="cov8" title="1">{
        // /Contents N 0 R  or  /Contents [N 0 R M 0 R]
        idx := strings.Index(dict, "/Contents")
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">rest := dict[idx+9:]
        rest = strings.TrimLeft(rest, " \t\r\n")
        if len(rest) &gt; 0 &amp;&amp; rest[0] == '[' </span><span class="cov8" title="1">{
                return extractRefArray(dict, "/Contents")
        }</span>
        <span class="cov8" title="1">ref := extractRef(dict, "/Contents")
        if ref &gt; 0 </span><span class="cov8" title="1">{
                return []int{ref}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *rawPDFParser) extractResources(dict string, pageObjNum int) rawPDFResources <span class="cov8" title="1">{
        res := rawPDFResources{
                fonts: make(map[string]int),
                xobjs: make(map[string]int),
        }
        // Resources can be inline or a reference
        resDict := dict
        resRef := extractRef(dict, "/Resources")
        if resRef &gt; 0 </span><span class="cov8" title="1">{
                if obj, ok := p.objects[resRef]; ok </span><span class="cov8" title="1">{
                        resDict = obj.dict
                }</span>
        }
        // Extract /Font &lt;&lt; /F1 N 0 R ... &gt;&gt;
        <span class="cov8" title="1">p.extractNamedRefs(resDict, "/Font", res.fonts)
        // Extract /XObject &lt;&lt; /Im1 N 0 R ... &gt;&gt;
        p.extractNamedRefs(resDict, "/XObject", res.xobjs)
        return res</span>
}

func (p *rawPDFParser) extractNamedRefs(dict, key string, out map[string]int) <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        rest = strings.TrimLeft(rest, " \t\r\n")
        if len(rest) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if rest[0] == '&lt;' &amp;&amp; len(rest) &gt; 1 &amp;&amp; rest[1] == '&lt;' </span><span class="cov8" title="1">{
                // inline dict
                inner := extractDict([]byte(rest))
                matches := reNamedRef.FindAllStringSubmatch(inner, -1)
                for _, m := range matches </span><span class="cov8" title="1">{
                        n, _ := strconv.Atoi(m[2])
                        out["/"+m[1]] = n
                }</span>
        } else<span class="cov0" title="0"> {
                // reference to another object
                m := reObjRef.FindStringSubmatch(rest)
                if m != nil </span><span class="cov0" title="0">{
                        n, _ := strconv.Atoi(m[1])
                        if obj, ok := p.objects[n]; ok </span><span class="cov0" title="0">{
                                matches := reNamedRef.FindAllStringSubmatch(obj.dict, -1)
                                for _, mm := range matches </span><span class="cov0" title="0">{
                                        nn, _ := strconv.Atoi(mm[2])
                                        out["/"+mm[1]] = nn
                                }</span>
                        }
                }
        }
}

// getPageContentStream returns the concatenated, decompressed content
// stream(s) for a page.
func (p *rawPDFParser) getPageContentStream(pageIdx int) []byte <span class="cov8" title="1">{
        if pageIdx &lt; 0 || pageIdx &gt;= len(p.pages) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">page := p.pages[pageIdx]
        var buf bytes.Buffer
        for _, ref := range page.contents </span><span class="cov8" title="1">{
                obj, ok := p.objects[ref]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if obj.stream != nil </span><span class="cov8" title="1">{
                        buf.Write(obj.stream)
                        buf.WriteByte('\n')
                }</span>
        }
        <span class="cov8" title="1">return buf.Bytes()</span>
}

// ============================================================
// Content stream text operator parser
// ============================================================

// ExtractedText represents a piece of text extracted from a PDF page.
type ExtractedText struct {
        // Text is the extracted text string.
        Text string
        // X is the horizontal position.
        X float64
        // Y is the vertical position.
        Y float64
        // FontName is the PDF font resource name (e.g. "/F1").
        FontName string
        // FontSize is the font size in points.
        FontSize float64
}

// ExtractedImage represents an image found on a PDF page.
type ExtractedImage struct {
        // Name is the XObject resource name (e.g. "/Im1").
        Name string
        // Width is the image width in pixels.
        Width int
        // Height is the image height in pixels.
        Height int
        // BitsPerComponent is the bits per color component.
        BitsPerComponent int
        // ColorSpace is the color space name.
        ColorSpace string
        // Filter is the compression filter.
        Filter string
        // Data is the raw (possibly compressed) image data.
        Data []byte
        // ObjNum is the PDF object number.
        ObjNum int
        // X, Y are the position on the page (from the CTM).
        X float64
        // Y position on the page.
        Y float64
        // DisplayWidth is the rendered width on the page.
        DisplayWidth float64
        // DisplayHeight is the rendered height on the page.
        DisplayHeight float64
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package gopdf

import (
        "crypto/md5"
        "crypto/rc4"
        "encoding/binary"
        "math/rand"
        "time"
)

const (
        //PermissionsPrint setProtection print
        PermissionsPrint = 4
        //PermissionsModify setProtection modify
        PermissionsModify = 8
        //PermissionsCopy setProtection copy
        PermissionsCopy = 16
        //PermissionsAnnotForms setProtection  annot-forms
        PermissionsAnnotForms = 32
)

var protectionPadding = []byte{
        0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
        0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,
}

// PDFProtection protection in pdf
type PDFProtection struct {
        encrypted bool   //whether document is protected
        uValue    []byte //U entry in pdf document
        oValue    []byte //O entry in pdf document
        pValue    int    //P entry in pdf document
        //var $enc_obj_id;         //encryption object id
        encryptionKey []byte
}

// SetProtection set protection information
func (p *PDFProtection) SetProtection(permissions int, userPass []byte, ownerPass []byte) error <span class="cov8" title="1">{
        return p.setProtection(permissions, userPass, ownerPass)
}</span>

func (p *PDFProtection) setProtection(permissions int, userPass []byte, ownerPass []byte) error <span class="cov8" title="1">{
        protection := 192 | permissions
        if ownerPass == nil || len(ownerPass) == 0 </span><span class="cov8" title="1">{
                ownerPass = p.randomPass(24)
        }</span>
        <span class="cov8" title="1">return p.generateEncryptionKey(userPass, ownerPass, protection)</span>
}

func (p *PDFProtection) generateEncryptionKey(userPass []byte, ownerPass []byte, protection int) error <span class="cov8" title="1">{

        userPass = append(userPass, protectionPadding...)
        userPassWithPadding := userPass[0:32]
        ownerPass = append(ownerPass, protectionPadding...)
        ownerPassWithPadding := ownerPass[0:32]

        //oValue
        oValue, err := p.createOValue(userPassWithPadding, ownerPassWithPadding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.oValue = oValue

        uValue, err := p.createUValue(userPassWithPadding, oValue, protection)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.uValue = uValue
        p.pValue = -((protection ^ 255) + 1)

        return nil</span>
}

// EncryptionObj get Encryption Object
func (p *PDFProtection) EncryptionObj() *EncryptionObj <span class="cov8" title="1">{
        return p.encryptionObj()
}</span>

func (p *PDFProtection) encryptionObj() *EncryptionObj <span class="cov8" title="1">{
        var en EncryptionObj
        en.oValue = p.oValue
        en.pValue = p.pValue
        en.uValue = p.uValue
        return &amp;en
}</span>

func (p *PDFProtection) createOValue(userPassWithPadding []byte, ownerPassWithPadding []byte) ([]byte, error) <span class="cov8" title="1">{
        tmp := md5.Sum(ownerPassWithPadding)
        ownerRC4key := tmp[0:5]
        cip, err := rc4.NewCipher(ownerRC4key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dest := make([]byte, len(userPassWithPadding))
        cip.XORKeyStream(dest, userPassWithPadding)
        return dest, nil</span>
}

func (p *PDFProtection) createUValue(userPassWithPadding []byte, oValue []byte, protection int) ([]byte, error) <span class="cov8" title="1">{
        m := md5.New()
        m.Write(userPassWithPadding)
        m.Write(oValue)
        m.Write([]byte{byte(protection), byte(0xff), byte(0xff), byte(0xff)})

        tmp2 := m.Sum(nil)
        p.encryptionKey = tmp2[0:5]
        cip, err := rc4.NewCipher(p.encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dest := make([]byte, len(protectionPadding))
        cip.XORKeyStream(dest, protectionPadding)
        return dest, nil</span>
}

func (p *PDFProtection) randomPass(strlen int) []byte <span class="cov8" title="1">{
        rand.Seed(time.Now().UTC().UnixNano())
        const chars = "abcdef0123456789"
        result := make([]byte, strlen)
        for i := 0; i &lt; strlen; i++ </span><span class="cov8" title="1">{
                result[i] = chars[rand.Intn(len(chars))]
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Objectkey create object key from ObjID
func (p *PDFProtection) Objectkey(objID int) []byte <span class="cov8" title="1">{
        return p.objectkey(objID)
}</span>

func (p *PDFProtection) objectkey(n int) []byte <span class="cov8" title="1">{
        tmp := make([]byte, 8, 8)
        binary.LittleEndian.PutUint32(tmp, uint32(n))
        tmp2 := append(p.encryptionKey, tmp[0], tmp[1], tmp[2], 0, 0)
        tmp3 := md5.Sum(tmp2)
        return tmp3[0:10]
}</span>

func rc4Cip(key []byte, src []byte) ([]byte, error) <span class="cov8" title="1">{
        cip, err := rc4.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dest := make([]byte, len(src))
        cip.XORKeyStream(dest, src)
        return dest, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package gopdf

// PDFVersion represents the PDF specification version.
type PDFVersion int

const (
        // PDFVersion14 is PDF 1.4 (Acrobat 5). Supports transparency.
        PDFVersion14 PDFVersion = 14
        // PDFVersion15 is PDF 1.5 (Acrobat 6). Supports object/xref streams.
        PDFVersion15 PDFVersion = 15
        // PDFVersion16 is PDF 1.6 (Acrobat 7). Supports OpenType fonts.
        PDFVersion16 PDFVersion = 16
        // PDFVersion17 is PDF 1.7 (Acrobat 8, ISO 32000-1). Default.
        PDFVersion17 PDFVersion = 17
        // PDFVersion20 is PDF 2.0 (ISO 32000-2).
        PDFVersion20 PDFVersion = 20
)

// String returns the PDF version header string (e.g. "1.7").
func (v PDFVersion) String() string <span class="cov8" title="1">{
        switch v </span>{
        case PDFVersion14:<span class="cov8" title="1">
                return "1.4"</span>
        case PDFVersion15:<span class="cov8" title="1">
                return "1.5"</span>
        case PDFVersion16:<span class="cov8" title="1">
                return "1.6"</span>
        case PDFVersion17:<span class="cov8" title="1">
                return "1.7"</span>
        case PDFVersion20:<span class="cov8" title="1">
                return "2.0"</span>
        default:<span class="cov8" title="1">
                return "1.7"</span>
        }
}

// Header returns the full PDF header line (e.g. "%PDF-1.7").
func (v PDFVersion) Header() string <span class="cov8" title="1">{
        return "%PDF-" + v.String()
}</span>

// SetPDFVersion sets the PDF version for the output document.
// Default is PDF 1.7. This affects the header and may enable
// version-specific features.
//
// Example:
//
//        pdf.SetPDFVersion(gopdf.PDFVersion20) // output PDF 2.0
func (gp *GoPdf) SetPDFVersion(v PDFVersion) <span class="cov8" title="1">{
        gp.pdfVersion = v
}</span>

// GetPDFVersion returns the current PDF version setting.
func (gp *GoPdf) GetPDFVersion() PDFVersion <span class="cov8" title="1">{
        if gp.pdfVersion == 0 </span><span class="cov8" title="1">{
                return PDFVersion17
        }</span>
        <span class="cov8" title="1">return gp.pdfVersion</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package gopdf

import (
        "fmt"
        "image"
        "image/color"
        "math"
        "strconv"
        "strings"
)

// RenderOption configures page rendering to an image.
type RenderOption struct {
        // DPI is the resolution in dots per inch. Default: 72 (1:1 with PDF points).
        DPI float64

        // Background is the background color. Default: white.
        Background color.Color
}

func (o *RenderOption) defaults() <span class="cov8" title="1">{
        if o.DPI &lt;= 0 </span><span class="cov8" title="1">{
                o.DPI = 72
        }</span>
        <span class="cov8" title="1">if o.Background == nil </span><span class="cov8" title="1">{
                o.Background = color.White
        }</span>
}

// RenderPageToImage renders a page from raw PDF data to an image.Image.
// The pageIndex is 0-based. This provides basic rendering of text placeholders,
// lines, rectangles, and images embedded in the PDF.
//
// Note: This is a lightweight pure-Go renderer. For full-fidelity rendering
// (fonts, complex paths, transparency), a C-based engine like MuPDF is needed.
// This renderer is suitable for thumbnails, previews, and simple PDFs.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        img, err := gopdf.RenderPageToImage(data, 0, gopdf.RenderOption{DPI: 150})
//        f, _ := os.Create("page0.png")
//        png.Encode(f, img)
func RenderPageToImage(pdfData []byte, pageIndex int, opt RenderOption) (image.Image, error) <span class="cov8" title="1">{
        opt.defaults()

        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF: %w", err)
        }</span>
        <span class="cov8" title="1">if pageIndex &lt; 0 || pageIndex &gt;= len(parser.pages) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("page index %d out of range (0..%d)", pageIndex, len(parser.pages)-1)
        }</span>

        <span class="cov8" title="1">page := parser.pages[pageIndex]
        mediaBox := page.mediaBox
        pageW := mediaBox[2] - mediaBox[0]
        pageH := mediaBox[3] - mediaBox[1]

        scale := opt.DPI / 72.0
        imgW := int(math.Ceil(pageW * scale))
        imgH := int(math.Ceil(pageH * scale))

        if imgW &lt; 1 </span><span class="cov0" title="0">{
                imgW = 1
        }</span>
        <span class="cov8" title="1">if imgH &lt; 1 </span><span class="cov0" title="0">{
                imgH = 1
        }</span>

        <span class="cov8" title="1">img := image.NewRGBA(image.Rect(0, 0, imgW, imgH))

        // Fill background
        bg := img.Bounds()
        for y := bg.Min.Y; y &lt; bg.Max.Y; y++ </span><span class="cov8" title="1">{
                for x := bg.Min.X; x &lt; bg.Max.X; x++ </span><span class="cov8" title="1">{
                        img.Set(x, y, opt.Background)
                }</span>
        }

        // Parse and render content stream
        <span class="cov8" title="1">stream := parser.getPageContentStream(pageIndex)
        if len(stream) &gt; 0 </span><span class="cov8" title="1">{
                renderContentStream(img, stream, parser, page, scale, pageH)
        }</span>

        <span class="cov8" title="1">return img, nil</span>
}

// RenderAllPagesToImages renders all pages to images.
func RenderAllPagesToImages(pdfData []byte, opt RenderOption) ([]image.Image, error) <span class="cov8" title="1">{
        opt.defaults()
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse PDF: %w", err)
        }</span>

        <span class="cov8" title="1">images := make([]image.Image, len(parser.pages))
        for i := range parser.pages </span><span class="cov8" title="1">{
                img, err := RenderPageToImage(pdfData, i, opt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("page %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">images[i] = img</span>
        }
        <span class="cov8" title="1">return images, nil</span>
}

// renderContentStream interprets a PDF content stream and draws onto the image.
func renderContentStream(img *image.RGBA, stream []byte, parser *rawPDFParser, page rawPDFPage, scale, pageH float64) <span class="cov8" title="1">{
        tokens := tokenize(stream)

        var stack []float64
        strokeColor := color.RGBA{R: 0, G: 0, B: 0, A: 255}
        fillColor := color.RGBA{R: 0, G: 0, B: 0, A: 255}
        _ = fillColor

        // Current transformation matrix
        ctmA, ctmD := 1.0, 1.0
        ctmE, ctmF := 0.0, 0.0

        for i := 0; i &lt; len(tokens); i++ </span><span class="cov8" title="1">{
                tok := tokens[i]
                if v, err := strconv.ParseFloat(tok, 64); err == nil </span><span class="cov8" title="1">{
                        stack = append(stack, v)
                        continue</span>
                }

                <span class="cov8" title="1">switch tok </span>{
                case "cm":<span class="cov8" title="1">
                        if len(stack) &gt;= 6 </span><span class="cov8" title="1">{
                                ctmA = stack[len(stack)-6]
                                ctmD = stack[len(stack)-3]
                                ctmE = stack[len(stack)-2]
                                ctmF = stack[len(stack)-1]
                                stack = stack[:len(stack)-6]
                        }</span>

                case "re":<span class="cov8" title="1">
                        // Rectangle: x y w h re
                        if len(stack) &gt;= 4 </span><span class="cov8" title="1">{
                                rx := stack[len(stack)-4]
                                ry := stack[len(stack)-3]
                                rw := stack[len(stack)-2]
                                rh := stack[len(stack)-1]
                                stack = stack[:len(stack)-4]
                                drawRectOnImage(img, rx, pageH-ry-rh, rw, rh, scale, strokeColor)
                        }</span>

                case "m":<span class="cov8" title="1">
                        // moveto â€” just consume coordinates
                        if len(stack) &gt;= 2 </span><span class="cov8" title="1">{
                                stack = stack[:len(stack)-2]
                        }</span>

                case "l":<span class="cov8" title="1">
                        // lineto â€” draw line from last point
                        if len(stack) &gt;= 2 </span><span class="cov8" title="1">{
                                stack = stack[:len(stack)-2]
                        }</span>

                case "RG":<span class="cov8" title="1">
                        // Set stroke color RGB
                        if len(stack) &gt;= 3 </span><span class="cov8" title="1">{
                                r := uint8(stack[len(stack)-3] * 255)
                                g := uint8(stack[len(stack)-2] * 255)
                                b := uint8(stack[len(stack)-1] * 255)
                                strokeColor = color.RGBA{R: r, G: g, B: b, A: 255}
                                stack = stack[:len(stack)-3]
                        }</span>

                case "rg":<span class="cov8" title="1">
                        // Set fill color RGB
                        if len(stack) &gt;= 3 </span><span class="cov8" title="1">{
                                r := uint8(stack[len(stack)-3] * 255)
                                g := uint8(stack[len(stack)-2] * 255)
                                b := uint8(stack[len(stack)-1] * 255)
                                fillColor = color.RGBA{R: r, G: g, B: b, A: 255}
                                stack = stack[:len(stack)-3]
                        }</span>

                case "G":<span class="cov8" title="1">
                        // Set stroke gray
                        if len(stack) &gt;= 1 </span><span class="cov8" title="1">{
                                g := uint8(stack[len(stack)-1] * 255)
                                strokeColor = color.RGBA{R: g, G: g, B: g, A: 255}
                                stack = stack[:len(stack)-1]
                        }</span>

                case "g":<span class="cov8" title="1">
                        // Set fill gray
                        if len(stack) &gt;= 1 </span><span class="cov8" title="1">{
                                g := uint8(stack[len(stack)-1] * 255)
                                fillColor = color.RGBA{R: g, G: g, B: g, A: 255}
                                stack = stack[:len(stack)-1]
                        }</span>

                case "Do":<span class="cov8" title="1">
                        // Draw XObject (image)
                        if i &gt;= 1 &amp;&amp; strings.HasPrefix(tokens[i-1], "/") </span><span class="cov8" title="1">{
                                name := tokens[i-1]
                                renderXObject(img, parser, page, name, ctmA, ctmD, ctmE, ctmF, scale, pageH)
                        }</span>

                case "S", "s":<span class="cov8" title="1">
                        // Stroke path â€” already handled inline
                        stack = stack[:0]</span>

                case "f", "F", "f*":<span class="cov8" title="1">
                        // Fill path
                        stack = stack[:0]</span>

                case "B", "B*", "b", "b*":<span class="cov8" title="1">
                        // Fill and stroke
                        stack = stack[:0]</span>

                case "n":<span class="cov8" title="1">
                        // End path without fill/stroke
                        stack = stack[:0]</span>

                case "q":<span class="cov8" title="1"></span>
                        // Save graphics state
                case "Q":<span class="cov8" title="1">
                        // Restore graphics state
                        ctmA, ctmD = 1, 1
                        ctmE, ctmF = 0, 0</span>

                case "W", "W*":<span class="cov8" title="1"></span>
                        // Clipping â€” ignore for basic rendering

                default:<span class="cov8" title="1">
                        if !strings.HasPrefix(tok, "/") </span><span class="cov8" title="1">{
                                stack = stack[:0]
                        }</span>
                }
        }
}

// drawRectOnImage draws a rectangle outline on the image.
func drawRectOnImage(img *image.RGBA, x, y, w, h, scale float64, c color.RGBA) <span class="cov8" title="1">{
        ix := int(x * scale)
        iy := int(y * scale)
        iw := int(w * scale)
        ih := int(h * scale)

        bounds := img.Bounds()

        // Draw horizontal lines
        for px := ix; px &lt;= ix+iw &amp;&amp; px &lt; bounds.Max.X; px++ </span><span class="cov8" title="1">{
                if px &gt;= 0 </span><span class="cov8" title="1">{
                        if iy &gt;= 0 &amp;&amp; iy &lt; bounds.Max.Y </span><span class="cov8" title="1">{
                                img.SetRGBA(px, iy, c)
                        }</span>
                        <span class="cov8" title="1">if iy+ih &gt;= 0 &amp;&amp; iy+ih &lt; bounds.Max.Y </span><span class="cov8" title="1">{
                                img.SetRGBA(px, iy+ih, c)
                        }</span>
                }
        }
        // Draw vertical lines
        <span class="cov8" title="1">for py := iy; py &lt;= iy+ih &amp;&amp; py &lt; bounds.Max.Y; py++ </span><span class="cov8" title="1">{
                if py &gt;= 0 </span><span class="cov8" title="1">{
                        if ix &gt;= 0 &amp;&amp; ix &lt; bounds.Max.X </span><span class="cov8" title="1">{
                                img.SetRGBA(ix, py, c)
                        }</span>
                        <span class="cov8" title="1">if ix+iw &gt;= 0 &amp;&amp; ix+iw &lt; bounds.Max.X </span><span class="cov8" title="1">{
                                img.SetRGBA(ix+iw, py, c)
                        }</span>
                }
        }
}

// renderXObject renders an image XObject onto the target image.
func renderXObject(img *image.RGBA, parser *rawPDFParser, page rawPDFPage, name string,
        ctmA, ctmD, ctmE, ctmF, scale, pageH float64) <span class="cov8" title="1">{

        objNum, ok := page.resources.xobjs[name]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">obj, ok := parser.objects[objNum]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !strings.Contains(obj.dict, "/Subtype /Image") &amp;&amp;
                !strings.Contains(obj.dict, "/Subtype/Image") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">filter := extractFilterValue(obj.dict)
        if obj.stream == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var srcImg image.Image
        var err error

        switch filter </span>{
        case "DCTDecode":<span class="cov8" title="1">
                srcImg, _, err = image.Decode(strings.NewReader(string(obj.stream)))</span>
        default:<span class="cov8" title="1">
                // Try generic decode
                srcImg, _, err = image.Decode(strings.NewReader(string(obj.stream)))</span>
        }
        <span class="cov8" title="1">if err != nil || srcImg == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Calculate destination rectangle
        <span class="cov8" title="1">dstX := int(ctmE * scale)
        dstY := int((pageH - ctmF - ctmD) * scale)
        dstW := int(ctmA * scale)
        dstH := int(ctmD * scale)

        if dstW &lt;= 0 || dstH &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Simple nearest-neighbor scaling
        <span class="cov8" title="1">srcBounds := srcImg.Bounds()
        srcW := srcBounds.Dx()
        srcH := srcBounds.Dy()

        for py := 0; py &lt; dstH; py++ </span><span class="cov8" title="1">{
                for px := 0; px &lt; dstW; px++ </span><span class="cov8" title="1">{
                        sx := srcBounds.Min.X + px*srcW/dstW
                        sy := srcBounds.Min.Y + py*srcH/dstH
                        if sx &gt;= srcBounds.Max.X </span><span class="cov0" title="0">{
                                sx = srcBounds.Max.X - 1
                        }</span>
                        <span class="cov8" title="1">if sy &gt;= srcBounds.Max.Y </span><span class="cov0" title="0">{
                                sy = srcBounds.Max.Y - 1
                        }</span>
                        <span class="cov8" title="1">dx := dstX + px
                        dy := dstY + py
                        if dx &gt;= 0 &amp;&amp; dx &lt; img.Bounds().Max.X &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; img.Bounds().Max.Y </span><span class="cov8" title="1">{
                                img.Set(dx, dy, srcImg.At(sx, sy))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// ProcSetObj is a PDF procSet object.
type ProcSetObj struct {
        //Font
        Relates             RelateFonts
        RelateColorSpaces   RelateColorSpaces
        RelateXobjs         RelateXobjects
        ExtGStates          []ExtGS
        ImportedTemplateIds map[string]int
        getRoot             func() *GoPdf
}

func (pr *ProcSetObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        pr.getRoot = funcGetRoot
        pr.ImportedTemplateIds = make(map[string]int, 0)
        pr.ExtGStates = make([]ExtGS, 0)
}</span>

func (pr *ProcSetObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        content := "&lt;&lt;\n"
        content += "\t/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\n"

        fonts := "\t/Font &lt;&lt;\n"
        for _, relate := range pr.Relates </span><span class="cov8" title="1">{
                fonts += fmt.Sprintf("\t\t/F%d %d 0 R\n", relate.CountOfFont+1, relate.IndexOfObj+1)
        }</span>
        <span class="cov8" title="1">fonts += "\t&gt;&gt;\n"

        content += fonts

        colorSpaces := "\t/ColorSpace &lt;&lt;\n"
        for _, relate := range pr.RelateColorSpaces </span><span class="cov8" title="1">{
                colorSpaces += fmt.Sprintf("\t\t/CS%d %d 0 R\n", relate.CountOfColorSpace+1, relate.IndexOfObj+1)
        }</span>
        <span class="cov8" title="1">colorSpaces += "\t&gt;&gt;\n"

        content += colorSpaces

        xobjects := "\t/XObject &lt;&lt;\n"
        for _, XObject := range pr.RelateXobjs </span><span class="cov8" title="1">{
                xobjects += fmt.Sprintf("\t\t/I%d %d 0 R\n", XObject.IndexOfObj+1, XObject.IndexOfObj+1)
        }</span>
        // Write imported template name and their ids
        <span class="cov8" title="1">for tplName, objID := range pr.ImportedTemplateIds </span><span class="cov8" title="1">{
                xobjects += fmt.Sprintf("\t\t%s %d 0 R\n", tplName, objID)
        }</span>
        <span class="cov8" title="1">xobjects += "\t&gt;&gt;\n"

        content += xobjects

        extGStates := "\t/ExtGState &lt;&lt;\n"
        for _, extGState := range pr.ExtGStates </span><span class="cov8" title="1">{
                extGStates += fmt.Sprintf("\t\t/GS%d %d 0 R\n", extGState.Index+1, extGState.Index+1)
        }</span>
        <span class="cov8" title="1">extGStates += "\t&gt;&gt;\n"

        content += extGStates

        content += "&gt;&gt;\n"

        if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (pr *ProcSetObj) getType() string <span class="cov8" title="1">{
        return "ProcSet"
}</span>

// RelateFonts is a slice of RelateFont.
type RelateFonts []RelateFont

// IsContainsFamily checks if font family exists.
func (re *RelateFonts) IsContainsFamily(family string) bool <span class="cov8" title="1">{
        for _, rf := range *re </span><span class="cov8" title="1">{
                if rf.Family == family </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsContainsFamilyAndStyle checks if font with same name and style already exists .
func (re *RelateFonts) IsContainsFamilyAndStyle(family string, style int) bool <span class="cov8" title="1">{
        for _, rf := range *re </span><span class="cov8" title="1">{
                if rf.Family == family &amp;&amp; rf.Style == style </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RelateFont is a metadata index for fonts?
type RelateFont struct {
        Family string
        //etc /F1
        CountOfFont int
        //etc  5 0 R
        IndexOfObj int
        Style      int // Regular|Bold|Italic
}

type RelateColorSpaces []RelateColorSpace

type RelateColorSpace struct {
        Name string
        //etc /CS1
        CountOfColorSpace int
        //etc  5 0 R
        IndexOfObj int
}

// RelateXobjects is a slice of RelateXobject.
type RelateXobjects []RelateXobject

// RelateXobject is an index for ???
type RelateXobject struct {
        IndexOfObj int
}

// ExtGS is ???
type ExtGS struct {
        Index int
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package gopdf

// Rect defines a rectangle.
type Rect struct {
        W            float64
        H            float64
        unitOverride defaultUnitConfig
}

// PointsToUnits converts the rectangles width and height to Units. When this is called it is assumed the values of the rectangle are in Points
func (rect *Rect) PointsToUnits(t int) (r *Rect) <span class="cov8" title="1">{
        if rect == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">unitCfg := defaultUnitConfig{Unit: t}
        if rect.unitOverride.getUnit() != UnitUnset </span><span class="cov8" title="1">{
                unitCfg = rect.unitOverride
        }</span>

        <span class="cov8" title="1">r = &amp;Rect{W: rect.W, H: rect.H}
        pointsToUnitsVar(unitCfg, &amp;r.W, &amp;r.H)
        return</span>
}

// UnitsToPoints converts the rectanlges width and height to Points. When this is called it is assumed the values of the rectangle are in Units
func (rect *Rect) UnitsToPoints(t int) (r *Rect) <span class="cov8" title="1">{
        if rect == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">unitCfg := defaultUnitConfig{Unit: t}
        if rect.unitOverride.getUnit() != UnitUnset </span><span class="cov8" title="1">{
                unitCfg = rect.unitOverride
        }</span>

        <span class="cov8" title="1">r = &amp;Rect{W: rect.W, H: rect.H}
        unitsToPointsVar(unitCfg, &amp;r.W, &amp;r.H)
        return</span>
}

func (rect *Rect) unitsToPoints(unitCfg unitConfigurator) (r *Rect) <span class="cov8" title="1">{
        if rect == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if rect.unitOverride.getUnit() != UnitUnset </span><span class="cov8" title="1">{
                unitCfg = rect.unitOverride
        }</span>
        <span class="cov8" title="1">r = &amp;Rect{W: rect.W, H: rect.H}
        unitsToPointsVar(unitCfg, &amp;r.W, &amp;r.H)
        return</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package gopdf

// ScrubOption controls which sensitive data to remove from the PDF.
type ScrubOption struct {
        // Metadata removes standard PDF metadata (/Info dictionary).
        Metadata bool
        // XMLMetadata removes XMP metadata stream.
        XMLMetadata bool
        // EmbeddedFiles removes all embedded file attachments.
        EmbeddedFiles bool
        // PageLabels removes page label definitions.
        PageLabels bool
}

// DefaultScrubOption returns a ScrubOption with all options enabled.
func DefaultScrubOption() ScrubOption <span class="cov8" title="1">{
        return ScrubOption{
                Metadata:      true,
                XMLMetadata:   true,
                EmbeddedFiles: true,
                PageLabels:    true,
        }
}</span>

// Scrub removes potentially sensitive data from the PDF document.
// This is inspired by PyMuPDF's Document.scrub() method.
//
// By default (with DefaultScrubOption), it removes:
//   - Standard PDF metadata (author, title, subject, etc.)
//   - XMP metadata streams
//   - Embedded file attachments
//   - Page label definitions
//
// After scrubbing, call GarbageCollect(GCCompact) and save with a new
// filename to ensure removed data is physically purged.
//
// Example:
//
//        pdf.Scrub(gopdf.DefaultScrubOption())
//        pdf.GarbageCollect(gopdf.GCCompact)
//        pdf.WritePdf("scrubbed.pdf")
func (gp *GoPdf) Scrub(opt ScrubOption) <span class="cov8" title="1">{
        if opt.Metadata </span><span class="cov8" title="1">{
                gp.isUseInfo = false
                gp.info = nil
        }</span>

        <span class="cov8" title="1">if opt.XMLMetadata </span><span class="cov8" title="1">{
                gp.xmpMetadata = nil
        }</span>

        <span class="cov8" title="1">if opt.EmbeddedFiles </span><span class="cov8" title="1">{
                gp.embeddedFiles = nil
        }</span>

        <span class="cov8" title="1">if opt.PageLabels </span><span class="cov8" title="1">{
                gp.pageLabels = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package gopdf

import (
        "bytes"
        "io"

        "github.com/phpdave11/gofpdi"
)

// SelectPages rearranges the document to contain only the specified pages
// in the given order. Pages are 1-based and may be repeated.
//
// This works by exporting the current document to bytes, then re-importing
// only the selected pages in the specified order.
//
// Example:
//
//        // Reverse a 3-page document
//        newPdf, err := pdf.SelectPages([]int{3, 2, 1})
//
//        // Duplicate page 1 three times
//        newPdf, err := pdf.SelectPages([]int{1, 1, 1})
func (gp *GoPdf) SelectPages(pages []int) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">numPages := gp.GetNumberOfPages()
        for _, p := range pages </span><span class="cov8" title="1">{
                if p &lt; 1 || p &gt; numPages </span><span class="cov8" title="1">{
                        return nil, ErrPageOutOfRange
                }</span>
        }

        // Export current document to bytes.
        <span class="cov8" title="1">data, err := gp.GetBytesPdfReturnErr()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return selectPagesFromBytes(data, pages, nil)</span>
}

// SelectPagesFromFile creates a new GoPdf with pages from a PDF file
// rearranged in the specified order. Pages are 1-based and may be repeated.
//
// Example:
//
//        newPdf, err := gopdf.SelectPagesFromFile("input.pdf", []int{3, 1, 2}, nil)
//        newPdf.WritePdf("reordered.pdf")
func SelectPagesFromFile(pdfPath string, pages []int, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>

        <span class="cov8" title="1">data, err := readFileBytes(pdfPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return selectPagesFromBytes(data, pages, opt)</span>
}

// SelectPagesFromBytes creates a new GoPdf with pages from PDF bytes
// rearranged in the specified order.
func SelectPagesFromBytes(pdfData []byte, pages []int, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNoPages
        }</span>
        <span class="cov8" title="1">return selectPagesFromBytes(pdfData, pages, opt)</span>
}

func selectPagesFromBytes(pdfData []byte, pages []int, opt *OpenPDFOption) (*GoPdf, error) <span class="cov8" title="1">{
        box := "/MediaBox"
        if opt != nil &amp;&amp; opt.Box != "" </span><span class="cov8" title="1">{
                box = opt.Box
        }</span>

        // Probe page count and sizes.
        <span class="cov8" title="1">probe := gofpdi.NewImporter()
        probeRS := io.ReadSeeker(bytes.NewReader(pdfData))
        probe.SetSourceStream(&amp;probeRS)
        numPages := probe.GetNumPages()
        sizes := probe.GetPageSizes()

        for _, p := range pages </span><span class="cov8" title="1">{
                if p &lt; 1 || p &gt; numPages </span><span class="cov0" title="0">{
                        return nil, ErrPageOutOfRange
                }</span>
        }

        // Use first selected page's size for config.
        <span class="cov8" title="1">firstSize, ok := sizes[pages[0]][box]
        if !ok </span><span class="cov0" title="0">{
                firstSize, ok = sizes[pages[0]]["/MediaBox"]
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrNoPages
                }</span>
        }

        <span class="cov8" title="1">result := &amp;GoPdf{}
        config := Config{
                PageSize: Rect{W: firstSize["w"], H: firstSize["h"]},
        }
        if opt != nil &amp;&amp; opt.Protection != nil </span><span class="cov0" title="0">{
                config.Protection = *opt.Protection
        }</span>
        <span class="cov8" title="1">result.Start(config)

        for _, pageNo := range pages </span><span class="cov8" title="1">{
                pageSize, ok := sizes[pageNo][box]
                if !ok </span><span class="cov0" title="0">{
                        pageSize = sizes[pageNo]["/MediaBox"]
                }</span>
                <span class="cov8" title="1">w := pageSize["w"]
                h := pageSize["h"]

                rs := io.ReadSeeker(bytes.NewReader(pdfData))
                result.fpdi.SetSourceStream(&amp;rs)

                result.AddPageWithOption(PageOption{
                        PageSize: &amp;Rect{W: w, H: h},
                })

                startObjID := result.GetNextObjectID()
                result.fpdi.SetNextObjectID(startObjID)

                tpl := result.fpdi.ImportPage(pageNo, box)

                tplObjIDs := result.fpdi.PutFormXobjects()
                result.ImportTemplates(tplObjIDs)

                imported := result.fpdi.GetImportedObjects()
                result.ImportObjects(imported, startObjID)

                result.UseImportedTemplate(tpl, 0, 0, w, h)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "io"
        "strings"
)

// signatureValueObj is the PDF signature value dictionary (/Type /Sig).
// It writes a placeholder for /Contents that gets patched after signing.
type signatureValueObj struct {
        cfg          *SignatureConfig
        contentsSize int // size in bytes (hex will be 2x this)

        // contentsPlaceholder is the hex placeholder string used to locate
        // the /Contents value in the final PDF for patching.
        contentsPlaceholder string
}

func (s *signatureValueObj) init(fn func() *GoPdf) {<span class="cov0" title="0">}</span>

func (s *signatureValueObj) getType() string <span class="cov8" title="1">{
        return "Sig"
}</span>

func (s *signatureValueObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /Sig\n")
        io.WriteString(w, "/Filter /Adobe.PPKLite\n")
        io.WriteString(w, "/SubFilter /adbe.pkcs7.detached\n")

        // Contents placeholder â€” hex-encoded PKCS#7 signature, patched later.
        placeholder := strings.Repeat("0", s.contentsSize*2)
        s.contentsPlaceholder = placeholder
        fmt.Fprintf(w, "/Contents &lt;%s&gt;\n", placeholder)

        // ByteRange placeholder â€” patched after PDF is rendered.
        fmt.Fprintf(w, "/ByteRange %s\n", s.byteRangePlaceholder())

        if s.cfg != nil </span><span class="cov8" title="1">{
                if s.cfg.Name != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Name (%s)\n", escapeAnnotString(s.cfg.Name))
                }</span>
                <span class="cov8" title="1">if s.cfg.Reason != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Reason (%s)\n", escapeAnnotString(s.cfg.Reason))
                }</span>
                <span class="cov8" title="1">if s.cfg.Location != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/Location (%s)\n", escapeAnnotString(s.cfg.Location))
                }</span>
                <span class="cov8" title="1">if s.cfg.ContactInfo != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/ContactInfo (%s)\n", escapeAnnotString(s.cfg.ContactInfo))
                }</span>
                <span class="cov8" title="1">if !s.cfg.SignTime.IsZero() </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "/M (%s)\n", infodate(s.cfg.SignTime))
                }</span>
        }

        <span class="cov8" title="1">io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}

// byteRangePlaceholder returns the fixed-width placeholder for /ByteRange.
func (s *signatureValueObj) byteRangePlaceholder() string <span class="cov8" title="1">{
        // Fixed-width placeholder that will be replaced with actual values.
        placeholder := "[0 0000000000 0000000000 0000000000]"
        // Pad to signatureByteRangeSize
        for len(placeholder) &lt; signatureByteRangeSize </span><span class="cov8" title="1">{
                placeholder += " "
        }</span>
        <span class="cov8" title="1">return placeholder</span>
}

// findContentsPlaceholder locates the /Contents &lt;hex&gt; value in the PDF bytes.
// Returns the byte offset of '&lt;' and the byte after '&gt;'.
func (s *signatureValueObj) findContentsPlaceholder(pdfBytes []byte) (start, end int, err error) <span class="cov8" title="1">{
        placeholder := []byte(s.contentsPlaceholder)
        idx := bytes.Index(pdfBytes, placeholder)
        if idx &lt; 0 </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("signature contents placeholder not found in PDF output")
        }</span>
        // '&lt;' is one byte before the placeholder hex
        <span class="cov8" title="1">start = idx - 1
        // '&gt;' is one byte after the placeholder hex
        end = idx + len(placeholder) + 1
        return start, end, nil</span>
}

// signatureFieldObj is the PDF signature field widget annotation.
type signatureFieldObj struct {
        cfg         *SignatureConfig
        sigValueRef int // 1-based object ID of the signature value object
        getRoot     func() *GoPdf
}

func (s *signatureFieldObj) init(fn func() *GoPdf) {<span class="cov0" title="0">}</span>

func (s *signatureFieldObj) getType() string <span class="cov8" title="1">{
        return "FormField"
}</span>

func (s *signatureFieldObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /Annot\n")
        io.WriteString(w, "/Subtype /Widget\n")
        io.WriteString(w, "/FT /Sig\n")
        fmt.Fprintf(w, "/T (%s)\n", escapeAnnotString(s.cfg.SignatureFieldName))
        fmt.Fprintf(w, "/V %d 0 R\n", s.sigValueRef)

        if s.cfg.Visible </span><span class="cov8" title="1">{
                gp := s.getRoot()
                pageH := gp.config.PageSize.H
                x1 := s.cfg.X
                y1 := pageH - s.cfg.Y - s.cfg.H
                x2 := s.cfg.X + s.cfg.W
                y2 := pageH - s.cfg.Y
                fmt.Fprintf(w, "/Rect [%.2f %.2f %.2f %.2f]\n", x1, y1, x2, y2)
        }</span> else<span class="cov8" title="1"> {
                io.WriteString(w, "/Rect [0 0 0 0]\n")
        }</span>

        // Find the page object reference for /P
        <span class="cov8" title="1">if s.cfg.Visible </span><span class="cov8" title="1">{
                gp := s.getRoot()
                count := 0
                for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                        if _, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                                count++
                                if count == s.cfg.PageNo </span><span class="cov8" title="1">{
                                        fmt.Fprintf(w, "/P %d 0 R\n", i+1)
                                        break</span>
                                }
                        }
                }
        }

        // Flags: locked, print
        <span class="cov8" title="1">io.WriteString(w, "/F 132\n") // Print + Locked
        io.WriteString(w, "/Ff 1\n")  // ReadOnly

        io.WriteString(w, "&gt;&gt;\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "sync"
)

type SMaskSubtypes string

const (
        SMaskAlphaSubtype      = "/Alpha"
        SMaskLuminositySubtype = "/Luminosity"
)

// SMask smask
type SMask struct {
        imgInfo
        data []byte
        //getRoot func() *GoPdf
        pdfProtection                 *PDFProtection
        Index                         int
        TransparencyXObjectGroupIndex int
        S                             string
}

type SMaskOptions struct {
        TransparencyXObjectGroupIndex int
        Subtype                       SMaskSubtypes
}

func (smask SMaskOptions) GetId() string <span class="cov8" title="1">{
        id := fmt.Sprintf("S_%s;G_%d_0_R", smask.Subtype, smask.TransparencyXObjectGroupIndex)

        return id
}</span>

func GetCachedMask(opts SMaskOptions, gp *GoPdf) SMask <span class="cov8" title="1">{
        smask, ok := gp.curr.sMasksMap.Find(opts)
        if !ok </span><span class="cov8" title="1">{
                smask = SMask{
                        S:                             string(opts.Subtype),
                        TransparencyXObjectGroupIndex: opts.TransparencyXObjectGroupIndex,
                }
                smask.Index = gp.addObj(smask)

                gp.curr.sMasksMap.Save(opts.GetId(), smask)
        }</span>

        <span class="cov8" title="1">return smask</span>
}

func (s SMask) init(func() *GoPdf) {<span class="cov0" title="0">}</span>

func (s *SMask) setProtection(p *PDFProtection) <span class="cov8" title="1">{
        s.pdfProtection = p
}</span>

func (s SMask) protection() *PDFProtection <span class="cov8" title="1">{
        return s.pdfProtection
}</span>

func (s SMask) getType() string <span class="cov8" title="1">{
        return "Mask"
}</span>

func (s SMask) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        if s.TransparencyXObjectGroupIndex != 0 </span><span class="cov8" title="1">{
                content := "&lt;&lt;\n"
                content += "\t/Type /Mask\n"
                content += fmt.Sprintf("\t/S %s\n", s.S)
                content += fmt.Sprintf("\t/G %d 0 R\n", s.TransparencyXObjectGroupIndex+1)
                content += "&gt;&gt;\n"

                if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                err := writeImgProps(w, s.imgInfo, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">fmt.Fprintf(w, "/Length %d\n&gt;&gt;\n", len(s.data)) // /Length 62303&gt;&gt;\n
                io.WriteString(w, "stream\n")
                if s.protection() != nil </span><span class="cov8" title="1">{
                        tmp, err := rc4Cip(s.protection().objectkey(objID), s.data)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">w.Write(tmp)
                        io.WriteString(w, "\n")</span>
                } else<span class="cov8" title="1"> {
                        w.Write(s.data)
                }</span>
                <span class="cov8" title="1">io.WriteString(w, "\nendstream\n")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type SMaskMap struct {
        syncer sync.Mutex
        table  map[string]SMask
}

func NewSMaskMap() SMaskMap <span class="cov8" title="1">{
        return SMaskMap{
                syncer: sync.Mutex{},
                table:  make(map[string]SMask),
        }
}</span>

func (smask *SMaskMap) Find(sMask SMaskOptions) (SMask, bool) <span class="cov8" title="1">{
        key := sMask.GetId()

        smask.syncer.Lock()
        defer smask.syncer.Unlock()

        t, ok := smask.table[key]
        if !ok </span><span class="cov8" title="1">{
                return SMask{}, false
        }</span>

        <span class="cov8" title="1">return t, ok</span>

}

func (smask *SMaskMap) Save(id string, sMask SMask) SMask <span class="cov8" title="1">{
        smask.syncer.Lock()
        defer smask.syncer.Unlock()

        smask.table[id] = sMask

        return sMask
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package gopdf

import (
        "math/big"
        "strings"
)

// StrHelperGetStringWidth get string width
func StrHelperGetStringWidth(str string, fontSize int, ifont IFont) float64 <span class="cov8" title="1">{
        return StrHelperGetStringWidthPrecise(str, float64(fontSize), ifont)
}</span>

// StrHelperGetStringWidthPrecise get string width with real number fontSize
func StrHelperGetStringWidthPrecise(str string, fontSize float64, ifont IFont) float64 <span class="cov8" title="1">{

        w := 0
        bs := []byte(str)
        i := 0
        max := len(bs)
        for i &lt; max </span><span class="cov8" title="1">{
                w += ifont.GetCw()[bs[i]]
                i++
        }</span>
        <span class="cov8" title="1">return float64(w) * (float64(fontSize) / 1000.0)</span>
}

// CreateEmbeddedFontSubsetName create Embedded font (subset font) name
func CreateEmbeddedFontSubsetName(name string) string <span class="cov8" title="1">{
        name = strings.Replace(name, " ", "+", -1)
        name = strings.Replace(name, "/", "+", -1)
        return name
}</span>

// ReadShortFromByte read short from byte array
func ReadShortFromByte(data []byte, offset int) (int64, int) <span class="cov8" title="1">{
        buff := data[offset : offset+2]
        num := big.NewInt(0)
        num.SetBytes(buff)
        u := num.Uint64()
        var v int64
        if u &gt;= 0x8000 </span><span class="cov8" title="1">{
                v = int64(u) - 65536
        }</span> else<span class="cov8" title="1"> {
                v = int64(u)
        }</span>
        <span class="cov8" title="1">return v, 2</span>
}

// ReadUShortFromByte read ushort from byte array
func ReadUShortFromByte(data []byte, offset int) (uint64, int) <span class="cov8" title="1">{
        buff := data[offset : offset+2]
        num := big.NewInt(0)
        num.SetBytes(buff)
        return num.Uint64(), 2
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package gopdf

type PaintStyle string

const (
        DrawPaintStyle     PaintStyle = "S"
        FillPaintStyle     PaintStyle = "f"
        DrawFillPaintStyle PaintStyle = "B"
)

func parseStyle(style string) PaintStyle <span class="cov8" title="1">{
        op := DrawPaintStyle
        if style == "F" </span><span class="cov8" title="1">{
                op = FillPaintStyle
        }</span> else<span class="cov8" title="1"> if style == "FD" || style == "DF" </span><span class="cov8" title="1">{
                op = DrawFillPaintStyle
        }</span>

        <span class="cov8" title="1">return op</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package gopdf

import (
        "fmt"
        "io"

        "github.com/VantageDataChat/GoPDF2/fontmaker/core"
)

// SubfontDescriptorObj pdf subfont descriptorObj object
type SubfontDescriptorObj struct {
        PtrToSubsetFontObj    *SubsetFontObj
        indexObjPdfDictionary int
}

func (s *SubfontDescriptorObj) init(func() *GoPdf) {<span class="cov8" title="1">}</span>

func (s *SubfontDescriptorObj) getType() string <span class="cov8" title="1">{
        return "SubFontDescriptor"
}</span>

func (s *SubfontDescriptorObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        ttfp := s.PtrToSubsetFontObj.GetTTFParser()
        //fmt.Printf("--&gt;%d\n", ttfp.UnitsPerEm())
        io.WriteString(w, "&lt;&lt;\n")
        io.WriteString(w, "/Type /FontDescriptor\n")
        fmt.Fprintf(w, "/Ascent %d\n", DesignUnitsToPdf(ttfp.Ascender(), ttfp.UnitsPerEm()))
        fmt.Fprintf(w, "/CapHeight %d\n", DesignUnitsToPdf(ttfp.CapHeight(), ttfp.UnitsPerEm()))
        fmt.Fprintf(w, "/Descent %d\n", DesignUnitsToPdf(ttfp.Descender(), ttfp.UnitsPerEm()))
        fmt.Fprintf(w, "/Flags %d\n", ttfp.Flag())
        fmt.Fprintf(w, "/FontBBox [%d %d %d %d]\n",
                DesignUnitsToPdf(ttfp.XMin(), ttfp.UnitsPerEm()),
                DesignUnitsToPdf(ttfp.YMin(), ttfp.UnitsPerEm()),
                DesignUnitsToPdf(ttfp.XMax(), ttfp.UnitsPerEm()),
                DesignUnitsToPdf(ttfp.YMax(), ttfp.UnitsPerEm()),
        )
        fmt.Fprintf(w, "/FontFile2 %d 0 R\n", s.indexObjPdfDictionary+1)
        fmt.Fprintf(w, "/FontName /%s\n", CreateEmbeddedFontSubsetName(s.PtrToSubsetFontObj.GetFamily()))
        fmt.Fprintf(w, "/ItalicAngle %d\n", ttfp.ItalicAngle())
        io.WriteString(w, "/StemV 0\n")
        fmt.Fprintf(w, "/XHeight %d\n", DesignUnitsToPdf(ttfp.XHeight(), ttfp.UnitsPerEm()))
        io.WriteString(w, "&gt;&gt;\n")
        return nil
}</span>

// SetIndexObjPdfDictionary set PdfDictionary pointer
func (s *SubfontDescriptorObj) SetIndexObjPdfDictionary(index int) <span class="cov8" title="1">{
        s.indexObjPdfDictionary = index
}</span>

// SetPtrToSubsetFontObj set SubsetFont pointer
func (s *SubfontDescriptorObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) <span class="cov8" title="1">{
        s.PtrToSubsetFontObj = ptr
}</span>

// DesignUnitsToPdf convert unit
func DesignUnitsToPdf(val int, unitsPerEm uint) int <span class="cov8" title="1">{
        return core.Round(float64(float64(val) * 1000.00 / float64(unitsPerEm)))
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package gopdf

import (
        "errors"
        "fmt"
        "io"

        "github.com/VantageDataChat/GoPDF2/fontmaker/core"
)

// ErrCharNotFound char not found
var ErrCharNotFound = errors.New("char not found")

// ErrGlyphNotFound font file not contain glyph
var ErrGlyphNotFound = errors.New("glyph not found")

// SubsetFontObj pdf subsetFont object
type SubsetFontObj struct {
        ttfp                  core.TTFParser
        Family                string
        CharacterToGlyphIndex *MapOfCharacterToGlyphIndex
        CountOfFont           int
        indexObjCIDFont       int
        indexObjUnicodeMap    int
        ttfFontOption         TtfOption
        funcKernOverride      FuncKernOverride
        funcGetRoot           func() *GoPdf
        addCharsBuff          []rune
}

func (s *SubsetFontObj) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        s.CharacterToGlyphIndex = NewMapOfCharacterToGlyphIndex() //make(map[rune]uint)
        s.funcKernOverride = nil
        s.funcGetRoot = funcGetRoot

}</span>

func (s *SubsetFontObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        //me.AddChars("à¸ˆ")
        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/BaseFont /%s\n", CreateEmbeddedFontSubsetName(s.Family))
        fmt.Fprintf(w, "/DescendantFonts [%d 0 R]\n", s.indexObjCIDFont+1)
        io.WriteString(w, "/Encoding /Identity-H\n")
        io.WriteString(w, "/Subtype /Type0\n")
        fmt.Fprintf(w, "/ToUnicode %d 0 R\n", s.indexObjUnicodeMap+1)
        io.WriteString(w, "/Type /Font\n")
        io.WriteString(w, "&gt;&gt;\n")
        return nil
}</span>

// SetIndexObjCIDFont set IndexObjCIDFont
func (s *SubsetFontObj) SetIndexObjCIDFont(index int) <span class="cov8" title="1">{
        s.indexObjCIDFont = index
}</span>

// SetIndexObjUnicodeMap set IndexObjUnicodeMap
func (s *SubsetFontObj) SetIndexObjUnicodeMap(index int) <span class="cov8" title="1">{
        s.indexObjUnicodeMap = index
}</span>

// SetFamily set font family name
func (s *SubsetFontObj) SetFamily(familyname string) <span class="cov8" title="1">{
        s.Family = familyname
}</span>

// GetFamily get font family name
func (s *SubsetFontObj) GetFamily() string <span class="cov8" title="1">{
        return s.Family
}</span>

// SetTtfFontOption set TtfOption must set before SetTTFByPath
func (s *SubsetFontObj) SetTtfFontOption(option TtfOption) <span class="cov8" title="1">{
        if option.OnGlyphNotFoundSubstitute == nil </span><span class="cov8" title="1">{
                option.OnGlyphNotFoundSubstitute = DefaultOnGlyphNotFoundSubstitute
        }</span>
        <span class="cov8" title="1">s.ttfFontOption = option</span>
}

// GetTtfFontOption get TtfOption must set before SetTTFByPath
func (s *SubsetFontObj) GetTtfFontOption() TtfOption <span class="cov8" title="1">{
        return s.ttfFontOption
}</span>

// KernValueByLeft find kern value from kern table by left
func (s *SubsetFontObj) KernValueByLeft(left uint) (bool, *core.KernValue) <span class="cov8" title="1">{

        if !s.ttfFontOption.UseKerning </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">k := s.ttfp.Kern()
        if k == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if kval, ok := k.Kerning[left]; ok </span><span class="cov8" title="1">{
                return true, &amp;kval
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

// SetTTFByPath set ttf
func (s *SubsetFontObj) SetTTFByPath(ttfpath string) error <span class="cov8" title="1">{
        useKerning := s.ttfFontOption.UseKerning
        s.ttfp.SetUseKerning(useKerning)
        err := s.ttfp.Parse(ttfpath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetTTFByReader set ttf
func (s *SubsetFontObj) SetTTFByReader(rd io.Reader) error <span class="cov8" title="1">{
        useKerning := s.ttfFontOption.UseKerning
        s.ttfp.SetUseKerning(useKerning)
        err := s.ttfp.ParseByReader(rd)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetTTFData set ttf
func (s *SubsetFontObj) SetTTFData(data []byte) error <span class="cov8" title="1">{
        useKerning := s.ttfFontOption.UseKerning
        s.ttfp.SetUseKerning(useKerning)
        err := s.ttfp.ParseFontData(data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddChars add char to map CharacterToGlyphIndex
func (s *SubsetFontObj) AddChars(txt string) (string, error) <span class="cov8" title="1">{
        s.addCharsBuff = s.addCharsBuff[:0]
        for _, runeValue := range txt </span><span class="cov8" title="1">{
                if s.CharacterToGlyphIndex.KeyExists(runeValue) </span><span class="cov8" title="1">{
                        s.addCharsBuff = append(s.addCharsBuff, runeValue)
                        continue</span>
                }
                <span class="cov8" title="1">glyphIndex, err := s.CharCodeToGlyphIndex(runeValue)
                if err == ErrGlyphNotFound </span><span class="cov8" title="1">{
                        //never return error on this, just call function OnGlyphNotFound
                        if s.ttfFontOption.OnGlyphNotFound != nil </span><span class="cov8" title="1">{
                                s.ttfFontOption.OnGlyphNotFound(runeValue)
                        }</span>
                        //start: try to find rune for replace
                        <span class="cov8" title="1">alreadyExists, runeValueReplace, glyphIndexReplace := s.replaceGlyphThatNotFound(runeValue)
                        if !alreadyExists </span><span class="cov8" title="1">{
                                s.CharacterToGlyphIndex.Set(runeValueReplace, glyphIndexReplace) // [runeValue] = glyphIndex
                        }</span>
                        //end: try to find rune for replace
                        <span class="cov8" title="1">s.addCharsBuff = append(s.addCharsBuff, runeValueReplace)
                        continue</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">s.CharacterToGlyphIndex.Set(runeValue, glyphIndex) // [runeValue] = glyphIndex
                s.addCharsBuff = append(s.addCharsBuff, runeValue)</span>
        }
        <span class="cov8" title="1">return string(s.addCharsBuff), nil</span>
}

/*
//AddChars add char to map CharacterToGlyphIndex
func (s *SubsetFontObj) AddChars(txt string) error {

        for _, runeValue := range txt {
                if s.CharacterToGlyphIndex.KeyExists(runeValue) {
                        continue
                }
                glyphIndex, err := s.CharCodeToGlyphIndex(runeValue)
                if err == ErrGlyphNotFound {
                        //never return error on this, just call function OnGlyphNotFound
                        if s.ttfFontOption.OnGlyphNotFound != nil {
                                s.ttfFontOption.OnGlyphNotFound(runeValue)
                        }
                        //start: try to find rune for replace
                        runeValueReplace, glyphIndexReplace, ok := s.replaceGlyphThatNotFound(runeValue)
                        if ok {
                                s.CharacterToGlyphIndex.Set(runeValueReplace, glyphIndexReplace) // [runeValue] = glyphIndex
                        }
                        //end: try to find rune for replace
                        continue
                } else if err != nil {
                        return err
                }
                s.CharacterToGlyphIndex.Set(runeValue, glyphIndex) // [runeValue] = glyphIndex
        }
        return nil
}
*/

// replaceGlyphThatNotFound find glyph to replaced
// it returns
// - true if rune already add to CharacterToGlyphIndex
// - rune for replace
// - rune for replace is found or not
// - glyph index for replace
func (s *SubsetFontObj) replaceGlyphThatNotFound(runeNotFound rune) (bool, rune, uint) <span class="cov8" title="1">{
        if s.ttfFontOption.OnGlyphNotFoundSubstitute != nil </span><span class="cov8" title="1">{
                runeForReplace := s.ttfFontOption.OnGlyphNotFoundSubstitute(runeNotFound)
                if s.CharacterToGlyphIndex.KeyExists(runeForReplace) </span><span class="cov8" title="1">{
                        return true, runeForReplace, 0
                }</span>
                <span class="cov8" title="1">glyphIndexForReplace, err := s.CharCodeToGlyphIndex(runeForReplace)
                if err != nil </span><span class="cov8" title="1">{
                        return false, runeForReplace, 0
                }</span>
                <span class="cov8" title="1">return false, runeForReplace, glyphIndexForReplace</span>
        }
        <span class="cov8" title="1">return false, runeNotFound, 0</span>
}

// CharIndex index of char in glyph table
func (s *SubsetFontObj) CharIndex(r rune) (uint, error) <span class="cov8" title="1">{
        glyIndex, ok := s.CharacterToGlyphIndex.Val(r)
        if ok </span><span class="cov8" title="1">{
                return glyIndex, nil
        }</span>
        <span class="cov8" title="1">return 0, ErrCharNotFound</span>
}

// CharWidth with of char
func (s *SubsetFontObj) CharWidth(r rune) (uint, error) <span class="cov8" title="1">{
        glyIndex, ok := s.CharacterToGlyphIndex.Val(r)
        if ok </span><span class="cov8" title="1">{
                return s.GlyphIndexToPdfWidth(glyIndex), nil
        }</span>
        <span class="cov8" title="1">return 0, ErrCharNotFound</span>
}

func (s *SubsetFontObj) getType() string <span class="cov8" title="1">{
        return "SubsetFont"
}</span>

func (s *SubsetFontObj) charCodeToGlyphIndexFormat12(r rune) (uint, error) <span class="cov8" title="1">{

        value := uint(r)
        gTbs := s.ttfp.GroupingTables()
        for _, gTb := range gTbs </span><span class="cov0" title="0">{
                if value &gt;= gTb.StartCharCode &amp;&amp; value &lt;= gTb.EndCharCode </span><span class="cov0" title="0">{
                        gIndex := (value - gTb.StartCharCode) + gTb.GlyphID
                        return gIndex, nil
                }</span>
        }

        <span class="cov8" title="1">return uint(0), ErrGlyphNotFound</span>
}

func (s *SubsetFontObj) charCodeToGlyphIndexFormat4(r rune) (uint, error) <span class="cov8" title="1">{
        value := uint(r)
        seg := uint(0)
        segCount := s.ttfp.SegCount
        for seg &lt; segCount </span><span class="cov8" title="1">{
                if value &lt;= s.ttfp.EndCount[seg] </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">seg++</span>
        }
        //fmt.Printf("\ncccc---&gt;%#v\n", me.ttfp.Chars())
        <span class="cov8" title="1">if value &lt; s.ttfp.StartCount[seg] </span><span class="cov8" title="1">{
                return 0, ErrGlyphNotFound
        }</span>

        <span class="cov8" title="1">if s.ttfp.IdRangeOffset[seg] == 0 </span><span class="cov8" title="1">{

                return (value + s.ttfp.IdDelta[seg]) &amp; 0xFFFF, nil
        }</span>
        //fmt.Printf("IdRangeOffset=%d\n", me.ttfp.IdRangeOffset[seg])
        <span class="cov0" title="0">idx := s.ttfp.IdRangeOffset[seg]/2 + (value - s.ttfp.StartCount[seg]) - (segCount - seg)

        if s.ttfp.GlyphIdArray[int(idx)] == uint(0) </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">return (s.ttfp.GlyphIdArray[int(idx)] + s.ttfp.IdDelta[seg]) &amp; 0xFFFF, nil</span>
}

// CharCodeToGlyphIndex gets glyph index from char code.
func (s *SubsetFontObj) CharCodeToGlyphIndex(r rune) (uint, error) <span class="cov8" title="1">{
        value := uint64(r)
        if value &lt;= 0xFFFF </span><span class="cov8" title="1">{
                gIndex, err := s.charCodeToGlyphIndexFormat4(r)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return gIndex, nil</span>
        }
        <span class="cov8" title="1">gIndex, err := s.charCodeToGlyphIndexFormat12(r)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return gIndex, nil</span>
}

// GlyphIndexToPdfWidth gets width from glyphIndex.
func (s *SubsetFontObj) GlyphIndexToPdfWidth(glyphIndex uint) uint <span class="cov8" title="1">{

        numberOfHMetrics := s.ttfp.NumberOfHMetrics()
        unitsPerEm := s.ttfp.UnitsPerEm()
        if glyphIndex &gt;= numberOfHMetrics </span><span class="cov8" title="1">{
                glyphIndex = numberOfHMetrics - 1
        }</span>

        <span class="cov8" title="1">width := s.ttfp.Widths()[glyphIndex]
        if unitsPerEm == 1000 </span><span class="cov8" title="1">{
                return width
        }</span>
        <span class="cov8" title="1">return width * 1000 / unitsPerEm</span>
}

// GetTTFParser gets TTFParser.
func (s *SubsetFontObj) GetTTFParser() *core.TTFParser <span class="cov8" title="1">{
        return &amp;s.ttfp
}</span>

// GetUnderlineThickness underlineThickness.
func (s *SubsetFontObj) GetUnderlineThickness() int <span class="cov8" title="1">{
        return s.ttfp.UnderlineThickness()
}</span>

func (s *SubsetFontObj) GetUnderlineThicknessPx(fontSize float64) float64 <span class="cov8" title="1">{
        return (float64(s.ttfp.UnderlineThickness()) / float64(s.ttfp.UnitsPerEm())) * fontSize
}</span>

// GetUnderlinePosition underline position.
func (s *SubsetFontObj) GetUnderlinePosition() int <span class="cov8" title="1">{
        return s.ttfp.UnderlinePosition()
}</span>

func (s *SubsetFontObj) GetUnderlinePositionPx(fontSize float64) float64 <span class="cov8" title="1">{
        return (float64(s.ttfp.UnderlinePosition()) / float64(s.ttfp.UnitsPerEm())) * fontSize
}</span>

func (s *SubsetFontObj) GetAscender() int <span class="cov8" title="1">{
        return s.ttfp.Ascender()
}</span>

func (s *SubsetFontObj) GetAscenderPx(fontSize float64) float64 <span class="cov8" title="1">{
        return (float64(s.ttfp.Ascender()) / float64(s.ttfp.UnitsPerEm())) * fontSize
}</span>

func (s *SubsetFontObj) GetDescender() int <span class="cov8" title="1">{
        return s.ttfp.Descender()
}</span>

func (s *SubsetFontObj) GetDescenderPx(fontSize float64) float64 <span class="cov8" title="1">{
        return (float64(s.ttfp.Descender()) / float64(s.ttfp.UnitsPerEm())) * fontSize
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package gopdf

import (
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "strconv"
        "strings"
)

// SVGOption configures how an SVG is rendered into the PDF.
type SVGOption struct {
        // X is the left position in page units.
        X float64
        // Y is the top position in page units.
        Y float64
        // Width is the target width. If 0, uses the SVG's native width.
        Width float64
        // Height is the target height. If 0, uses the SVG's native height.
        Height float64
}

var (
        ErrSVGParseFailed = errors.New("failed to parse SVG")
        ErrSVGEmpty       = errors.New("SVG contains no renderable elements")
)

// ImageSVG inserts an SVG image from a file path into the current page.
// The SVG is converted to native PDF drawing commands (lines, curves,
// rectangles, circles, paths) â€” no rasterization is needed.
//
// Supported SVG elements: rect, circle, ellipse, line, polyline,
// polygon, path (M, L, C, Q, Z commands), text (basic).
//
// Example:
//
//        pdf.AddPage()
//        err := pdf.ImageSVG("icon.svg", SVGOption{X: 50, Y: 50, Width: 200, Height: 200})
func (gp *GoPdf) ImageSVG(svgPath string, opt SVGOption) error <span class="cov8" title="1">{
        data, err := os.ReadFile(svgPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("read SVG file: %w", err)
        }</span>
        <span class="cov8" title="1">return gp.ImageSVGFromBytes(data, opt)</span>
}

// ImageSVGFromBytes inserts an SVG from raw bytes into the current page.
func (gp *GoPdf) ImageSVGFromBytes(svgData []byte, opt SVGOption) error <span class="cov8" title="1">{
        svg, err := parseSVG(svgData)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %v", ErrSVGParseFailed, err)
        }</span>
        <span class="cov8" title="1">if len(svg.elements) == 0 </span><span class="cov8" title="1">{
                return ErrSVGEmpty
        }</span>

        <span class="cov8" title="1">gp.UnitsToPointsVar(&amp;opt.X, &amp;opt.Y)
        if opt.Width &gt; 0 </span><span class="cov8" title="1">{
                opt.Width = gp.UnitsToPoints(opt.Width)
        }</span>
        <span class="cov8" title="1">if opt.Height &gt; 0 </span><span class="cov8" title="1">{
                opt.Height = gp.UnitsToPoints(opt.Height)
        }</span>

        // Calculate scale
        <span class="cov8" title="1">scaleX := 1.0
        scaleY := 1.0
        if opt.Width &gt; 0 &amp;&amp; svg.width &gt; 0 </span><span class="cov8" title="1">{
                scaleX = opt.Width / svg.width
        }</span>
        <span class="cov8" title="1">if opt.Height &gt; 0 &amp;&amp; svg.height &gt; 0 </span><span class="cov8" title="1">{
                scaleY = opt.Height / svg.height
        }</span>
        <span class="cov8" title="1">if opt.Width &gt; 0 &amp;&amp; opt.Height == 0 </span><span class="cov8" title="1">{
                scaleY = scaleX
        }</span> else<span class="cov8" title="1"> if opt.Height &gt; 0 &amp;&amp; opt.Width == 0 </span><span class="cov8" title="1">{
                scaleX = scaleY
        }</span>

        <span class="cov8" title="1">gp.SaveGraphicsState()
        defer gp.RestoreGraphicsState()

        // Render each SVG element
        for _, elem := range svg.elements </span><span class="cov8" title="1">{
                gp.renderSVGElement(elem, opt.X, opt.Y, scaleX, scaleY)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ImageSVGFromReader inserts an SVG from an io.Reader into the current page.
func (gp *GoPdf) ImageSVGFromReader(r io.Reader, opt SVGOption) error <span class="cov8" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return gp.ImageSVGFromBytes(data, opt)</span>
}

// ---- SVG parsing ----

type svgDoc struct {
        width    float64
        height   float64
        viewBox  [4]float64
        elements []svgElement
}

type svgElementType int

const (
        svgRect svgElementType = iota
        svgCircle
        svgEllipse
        svgLine
        svgPolyline
        svgPolygon
        svgPath
)

type svgElement struct {
        typ    svgElementType
        // Common style
        fill       [3]uint8
        hasFill    bool
        stroke     [3]uint8
        hasStroke  bool
        strokeW    float64
        opacity    float64
        // Geometry
        x, y, w, h    float64 // rect
        cx, cy, r     float64 // circle
        rx, ry         float64 // ellipse / rect corner radius
        x1, y1, x2, y2 float64 // line
        points         []Point // polyline, polygon
        pathData       string  // path d attribute
}

type xmlSVG struct {
        XMLName  xml.Name     `xml:"svg"`
        Width    string       `xml:"width,attr"`
        Height   string       `xml:"height,attr"`
        ViewBox  string       `xml:"viewBox,attr"`
        Elements []xmlElement `xml:",any"`
}

type xmlElement struct {
        XMLName xml.Name
        Attrs   []xml.Attr   `xml:",any,attr"`
        Content []xmlElement `xml:",any"`
}

func parseSVG(data []byte) (*svgDoc, error) <span class="cov8" title="1">{
        var raw xmlSVG
        if err := xml.Unmarshal(data, &amp;raw); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">doc := &amp;svgDoc{
                width:  parseSVGLength(raw.Width),
                height: parseSVGLength(raw.Height),
        }

        if raw.ViewBox != "" </span><span class="cov8" title="1">{
                parts := strings.Fields(raw.ViewBox)
                if len(parts) == 4 </span><span class="cov8" title="1">{
                        doc.viewBox[0], _ = strconv.ParseFloat(parts[0], 64)
                        doc.viewBox[1], _ = strconv.ParseFloat(parts[1], 64)
                        doc.viewBox[2], _ = strconv.ParseFloat(parts[2], 64)
                        doc.viewBox[3], _ = strconv.ParseFloat(parts[3], 64)
                }</span>
                <span class="cov8" title="1">if doc.width == 0 </span><span class="cov8" title="1">{
                        doc.width = doc.viewBox[2]
                }</span>
                <span class="cov8" title="1">if doc.height == 0 </span><span class="cov8" title="1">{
                        doc.height = doc.viewBox[3]
                }</span>
        }

        <span class="cov8" title="1">for _, el := range raw.Elements </span><span class="cov8" title="1">{
                if elem, ok := parseSVGElement(el); ok </span><span class="cov8" title="1">{
                        doc.elements = append(doc.elements, elem)
                }</span>
                // Recurse into groups
                <span class="cov8" title="1">for _, child := range el.Content </span><span class="cov8" title="1">{
                        if elem, ok := parseSVGElement(child); ok </span><span class="cov8" title="1">{
                                doc.elements = append(doc.elements, elem)
                        }</span>
                }
        }

        <span class="cov8" title="1">return doc, nil</span>
}

func parseSVGElement(el xmlElement) (svgElement, bool) <span class="cov8" title="1">{
        attrs := make(map[string]string)
        for _, a := range el.Attrs </span><span class="cov8" title="1">{
                attrs[a.Name.Local] = a.Value
        }</span>

        <span class="cov8" title="1">var elem svgElement
        elem.opacity = 1.0
        elem.strokeW = 1.0
        parseSVGStyle(&amp;elem, attrs)

        switch el.XMLName.Local </span>{
        case "rect":<span class="cov8" title="1">
                elem.typ = svgRect
                elem.x = atof(attrs["x"])
                elem.y = atof(attrs["y"])
                elem.w = atof(attrs["width"])
                elem.h = atof(attrs["height"])
                elem.rx = atof(attrs["rx"])
                elem.ry = atof(attrs["ry"])
                return elem, true</span>
        case "circle":<span class="cov8" title="1">
                elem.typ = svgCircle
                elem.cx = atof(attrs["cx"])
                elem.cy = atof(attrs["cy"])
                elem.r = atof(attrs["r"])
                return elem, true</span>
        case "ellipse":<span class="cov8" title="1">
                elem.typ = svgEllipse
                elem.cx = atof(attrs["cx"])
                elem.cy = atof(attrs["cy"])
                elem.rx = atof(attrs["rx"])
                elem.ry = atof(attrs["ry"])
                return elem, true</span>
        case "line":<span class="cov8" title="1">
                elem.typ = svgLine
                elem.x1 = atof(attrs["x1"])
                elem.y1 = atof(attrs["y1"])
                elem.x2 = atof(attrs["x2"])
                elem.y2 = atof(attrs["y2"])
                return elem, true</span>
        case "polyline":<span class="cov8" title="1">
                elem.typ = svgPolyline
                elem.points = parseSVGPoints(attrs["points"])
                return elem, len(elem.points) &gt; 0</span>
        case "polygon":<span class="cov8" title="1">
                elem.typ = svgPolygon
                elem.points = parseSVGPoints(attrs["points"])
                return elem, len(elem.points) &gt; 0</span>
        case "path":<span class="cov8" title="1">
                elem.typ = svgPath
                elem.pathData = attrs["d"]
                return elem, elem.pathData != ""</span>
        }
        <span class="cov8" title="1">return elem, false</span>
}

func parseSVGStyle(elem *svgElement, attrs map[string]string) <span class="cov8" title="1">{
        if v, ok := attrs["fill"]; ok &amp;&amp; v != "none" </span><span class="cov8" title="1">{
                if c, ok := parseSVGColor(v); ok </span><span class="cov8" title="1">{
                        elem.fill = c
                        elem.hasFill = true
                }</span>
        }
        <span class="cov8" title="1">if v, ok := attrs["stroke"]; ok &amp;&amp; v != "none" </span><span class="cov8" title="1">{
                if c, ok := parseSVGColor(v); ok </span><span class="cov8" title="1">{
                        elem.stroke = c
                        elem.hasStroke = true
                }</span>
        }
        <span class="cov8" title="1">if v, ok := attrs["stroke-width"]; ok </span><span class="cov8" title="1">{
                elem.strokeW = atof(v)
        }</span>
        <span class="cov8" title="1">if v, ok := attrs["opacity"]; ok </span><span class="cov8" title="1">{
                elem.opacity = atof(v)
        }</span>
        <span class="cov8" title="1">if style, ok := attrs["style"]; ok </span><span class="cov8" title="1">{
                for _, decl := range strings.Split(style, ";") </span><span class="cov8" title="1">{
                        decl = strings.TrimSpace(decl)
                        parts := strings.SplitN(decl, ":", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">prop := strings.TrimSpace(parts[0])
                        val := strings.TrimSpace(parts[1])
                        switch prop </span>{
                        case "fill":<span class="cov8" title="1">
                                if val != "none" </span><span class="cov8" title="1">{
                                        if c, ok := parseSVGColor(val); ok </span><span class="cov8" title="1">{
                                                elem.fill = c
                                                elem.hasFill = true
                                        }</span>
                                }
                        case "stroke":<span class="cov8" title="1">
                                if val != "none" </span><span class="cov8" title="1">{
                                        if c, ok := parseSVGColor(val); ok </span><span class="cov8" title="1">{
                                                elem.stroke = c
                                                elem.hasStroke = true
                                        }</span>
                                }
                        case "stroke-width":<span class="cov8" title="1">
                                elem.strokeW = atof(val)</span>
                        case "opacity":<span class="cov8" title="1">
                                elem.opacity = atof(val)</span>
                        }
                }
        }
}

func parseSVGColor(s string) ([3]uint8, bool) <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        if strings.HasPrefix(s, "#") </span><span class="cov8" title="1">{
                hex := s[1:]
                if len(hex) == 3 </span><span class="cov8" title="1">{
                        hex = string([]byte{hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]})
                }</span>
                <span class="cov8" title="1">if len(hex) == 6 </span><span class="cov8" title="1">{
                        r, _ := strconv.ParseUint(hex[0:2], 16, 8)
                        g, _ := strconv.ParseUint(hex[2:4], 16, 8)
                        b, _ := strconv.ParseUint(hex[4:6], 16, 8)
                        return [3]uint8{uint8(r), uint8(g), uint8(b)}, true
                }</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(s, "rgb(") </span><span class="cov8" title="1">{
                s = strings.TrimPrefix(s, "rgb(")
                s = strings.TrimSuffix(s, ")")
                parts := strings.Split(s, ",")
                if len(parts) == 3 </span><span class="cov8" title="1">{
                        r, _ := strconv.Atoi(strings.TrimSpace(parts[0]))
                        g, _ := strconv.Atoi(strings.TrimSpace(parts[1]))
                        b, _ := strconv.Atoi(strings.TrimSpace(parts[2]))
                        return [3]uint8{uint8(r), uint8(g), uint8(b)}, true
                }</span>
        }
        // Named colors (common subset)
        <span class="cov8" title="1">switch strings.ToLower(s) </span>{
        case "black":<span class="cov8" title="1">
                return [3]uint8{0, 0, 0}, true</span>
        case "white":<span class="cov8" title="1">
                return [3]uint8{255, 255, 255}, true</span>
        case "red":<span class="cov8" title="1">
                return [3]uint8{255, 0, 0}, true</span>
        case "green":<span class="cov8" title="1">
                return [3]uint8{0, 128, 0}, true</span>
        case "blue":<span class="cov8" title="1">
                return [3]uint8{0, 0, 255}, true</span>
        case "yellow":<span class="cov8" title="1">
                return [3]uint8{255, 255, 0}, true</span>
        case "cyan":<span class="cov8" title="1">
                return [3]uint8{0, 255, 255}, true</span>
        case "magenta":<span class="cov8" title="1">
                return [3]uint8{255, 0, 255}, true</span>
        case "gray", "grey":<span class="cov8" title="1">
                return [3]uint8{128, 128, 128}, true</span>
        case "orange":<span class="cov8" title="1">
                return [3]uint8{255, 165, 0}, true</span>
        case "purple":<span class="cov8" title="1">
                return [3]uint8{128, 0, 128}, true</span>
        }
        <span class="cov8" title="1">return [3]uint8{}, false</span>
}

func parseSVGPoints(s string) []Point <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, ",", " ")
        fields := strings.Fields(s)
        var points []Point
        for i := 0; i+1 &lt; len(fields); i += 2 </span><span class="cov8" title="1">{
                x, _ := strconv.ParseFloat(fields[i], 64)
                y, _ := strconv.ParseFloat(fields[i+1], 64)
                points = append(points, Point{X: x, Y: y})
        }</span>
        <span class="cov8" title="1">return points</span>
}

func parseSVGLength(s string) float64 <span class="cov8" title="1">{
        s = strings.TrimSpace(s)
        s = strings.TrimSuffix(s, "px")
        s = strings.TrimSuffix(s, "pt")
        s = strings.TrimSuffix(s, "mm")
        s = strings.TrimSuffix(s, "cm")
        v, _ := strconv.ParseFloat(s, 64)
        return v
}</span>

func atof(s string) float64 <span class="cov8" title="1">{
        v, _ := strconv.ParseFloat(strings.TrimSpace(s), 64)
        return v
}</span>

// ---- SVG rendering to PDF ----

func (gp *GoPdf) renderSVGElement(elem svgElement, offX, offY, scaleX, scaleY float64) <span class="cov8" title="1">{
        // Apply style
        if elem.hasStroke </span><span class="cov8" title="1">{
                gp.SetStrokeColor(elem.stroke[0], elem.stroke[1], elem.stroke[2])
                gp.SetLineWidth(elem.strokeW * scaleX)
        }</span>
        <span class="cov8" title="1">if elem.hasFill </span><span class="cov8" title="1">{
                gp.SetFillColor(elem.fill[0], elem.fill[1], elem.fill[2])
        }</span>

        <span class="cov8" title="1">switch elem.typ </span>{
        case svgRect:<span class="cov8" title="1">
                x := offX + elem.x*scaleX
                y := offY + elem.y*scaleY
                w := elem.w * scaleX
                h := elem.h * scaleY
                style := svgPaintStyle(elem)
                rx := elem.rx * scaleX
                if rx &gt; 0 </span><span class="cov8" title="1">{
                        gp.Rectangle(x, y, x+w, y+h, style, rx, 12)
                }</span> else<span class="cov8" title="1"> {
                        gp.Rectangle(x, y, x+w, y+h, style, 0, 0)
                }</span>

        case svgCircle:<span class="cov8" title="1">
                cx := offX + elem.cx*scaleX
                cy := offY + elem.cy*scaleY
                r := elem.r * scaleX
                gp.Oval(cx-r, cy-r, cx+r, cy+r)</span>

        case svgEllipse:<span class="cov8" title="1">
                cx := offX + elem.cx*scaleX
                cy := offY + elem.cy*scaleY
                rx := elem.rx * scaleX
                ry := elem.ry * scaleY
                gp.Oval(cx-rx, cy-ry, cx+rx, cy+ry)</span>

        case svgLine:<span class="cov8" title="1">
                x1 := offX + elem.x1*scaleX
                y1 := offY + elem.y1*scaleY
                x2 := offX + elem.x2*scaleX
                y2 := offY + elem.y2*scaleY
                gp.Line(x1, y1, x2, y2)</span>

        case svgPolyline:<span class="cov8" title="1">
                scaled := scaleSVGPoints(elem.points, offX, offY, scaleX, scaleY)
                if len(scaled) &gt;= 2 </span><span class="cov8" title="1">{
                        gp.Polyline(scaled)
                }</span>

        case svgPolygon:<span class="cov8" title="1">
                scaled := scaleSVGPoints(elem.points, offX, offY, scaleX, scaleY)
                if len(scaled) &gt;= 3 </span><span class="cov8" title="1">{
                        style := svgPaintStyle(elem)
                        gp.Polygon(scaled, style)
                }</span>

        case svgPath:<span class="cov8" title="1">
                gp.renderSVGPath(elem.pathData, offX, offY, scaleX, scaleY, elem)</span>
        }
}

func svgPaintStyle(elem svgElement) string <span class="cov8" title="1">{
        if elem.hasFill &amp;&amp; elem.hasStroke </span><span class="cov8" title="1">{
                return "FD"
        }</span>
        <span class="cov8" title="1">if elem.hasFill </span><span class="cov8" title="1">{
                return "F"
        }</span>
        <span class="cov8" title="1">return "D"</span>
}

func scaleSVGPoints(pts []Point, offX, offY, scaleX, scaleY float64) []Point <span class="cov8" title="1">{
        out := make([]Point, len(pts))
        for i, p := range pts </span><span class="cov8" title="1">{
                out[i] = Point{X: offX + p.X*scaleX, Y: offY + p.Y*scaleY}
        }</span>
        <span class="cov8" title="1">return out</span>
}

// renderSVGPath renders an SVG path "d" attribute using PDF drawing commands.
// Supports: M/m, L/l, H/h, V/v, C/c, Q/q, Z/z commands.
func (gp *GoPdf) renderSVGPath(d string, offX, offY, scaleX, scaleY float64, elem svgElement) <span class="cov8" title="1">{
        cmds := tokenizeSVGPath(d)
        if len(cmds) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var curX, curY float64
        var startX, startY float64
        i := 0

        for i &lt; len(cmds) </span><span class="cov8" title="1">{
                cmd := cmds[i]
                i++

                switch cmd </span>{
                case "M":<span class="cov8" title="1">
                        if i+1 &lt; len(cmds) </span><span class="cov8" title="1">{
                                curX = atof(cmds[i])
                                curY = atof(cmds[i+1])
                                i += 2
                                startX, startY = curX, curY
                        }</span>
                case "m":<span class="cov8" title="1">
                        if i+1 &lt; len(cmds) </span><span class="cov8" title="1">{
                                curX += atof(cmds[i])
                                curY += atof(cmds[i+1])
                                i += 2
                                startX, startY = curX, curY
                        }</span>
                case "L":<span class="cov8" title="1">
                        for i+1 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                nx := atof(cmds[i])
                                ny := atof(cmds[i+1])
                                gp.Line(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+nx*scaleX, offY+ny*scaleY,
                                )
                                curX, curY = nx, ny
                                i += 2
                        }</span>
                case "l":<span class="cov8" title="1">
                        for i+1 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                dx := atof(cmds[i])
                                dy := atof(cmds[i+1])
                                nx, ny := curX+dx, curY+dy
                                gp.Line(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+nx*scaleX, offY+ny*scaleY,
                                )
                                curX, curY = nx, ny
                                i += 2
                        }</span>
                case "H":<span class="cov8" title="1">
                        if i &lt; len(cmds) </span><span class="cov8" title="1">{
                                nx := atof(cmds[i])
                                i++
                                gp.Line(offX+curX*scaleX, offY+curY*scaleY, offX+nx*scaleX, offY+curY*scaleY)
                                curX = nx
                        }</span>
                case "h":<span class="cov8" title="1">
                        if i &lt; len(cmds) </span><span class="cov8" title="1">{
                                dx := atof(cmds[i])
                                i++
                                nx := curX + dx
                                gp.Line(offX+curX*scaleX, offY+curY*scaleY, offX+nx*scaleX, offY+curY*scaleY)
                                curX = nx
                        }</span>
                case "V":<span class="cov8" title="1">
                        if i &lt; len(cmds) </span><span class="cov8" title="1">{
                                ny := atof(cmds[i])
                                i++
                                gp.Line(offX+curX*scaleX, offY+curY*scaleY, offX+curX*scaleX, offY+ny*scaleY)
                                curY = ny
                        }</span>
                case "v":<span class="cov8" title="1">
                        if i &lt; len(cmds) </span><span class="cov8" title="1">{
                                dy := atof(cmds[i])
                                i++
                                ny := curY + dy
                                gp.Line(offX+curX*scaleX, offY+curY*scaleY, offX+curX*scaleX, offY+ny*scaleY)
                                curY = ny
                        }</span>
                case "C":<span class="cov8" title="1">
                        for i+5 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                x1 := atof(cmds[i])
                                y1 := atof(cmds[i+1])
                                x2 := atof(cmds[i+2])
                                y2 := atof(cmds[i+3])
                                x3 := atof(cmds[i+4])
                                y3 := atof(cmds[i+5])
                                gp.Curve(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+x1*scaleX, offY+y1*scaleY,
                                        offX+x2*scaleX, offY+y2*scaleY,
                                        offX+x3*scaleX, offY+y3*scaleY,
                                        "D",
                                )
                                curX, curY = x3, y3
                                i += 6
                        }</span>
                case "c":<span class="cov8" title="1">
                        for i+5 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                dx1 := atof(cmds[i])
                                dy1 := atof(cmds[i+1])
                                dx2 := atof(cmds[i+2])
                                dy2 := atof(cmds[i+3])
                                dx3 := atof(cmds[i+4])
                                dy3 := atof(cmds[i+5])
                                gp.Curve(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+(curX+dx1)*scaleX, offY+(curY+dy1)*scaleY,
                                        offX+(curX+dx2)*scaleX, offY+(curY+dy2)*scaleY,
                                        offX+(curX+dx3)*scaleX, offY+(curY+dy3)*scaleY,
                                        "D",
                                )
                                curX += dx3
                                curY += dy3
                                i += 6
                        }</span>
                case "Q":<span class="cov8" title="1">
                        // Quadratic BÃ©zier â€” convert to cubic
                        for i+3 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                qx := atof(cmds[i])
                                qy := atof(cmds[i+1])
                                ex := atof(cmds[i+2])
                                ey := atof(cmds[i+3])
                                // Convert quadratic to cubic control points
                                c1x := curX + 2.0/3.0*(qx-curX)
                                c1y := curY + 2.0/3.0*(qy-curY)
                                c2x := ex + 2.0/3.0*(qx-ex)
                                c2y := ey + 2.0/3.0*(qy-ey)
                                gp.Curve(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+c1x*scaleX, offY+c1y*scaleY,
                                        offX+c2x*scaleX, offY+c2y*scaleY,
                                        offX+ex*scaleX, offY+ey*scaleY,
                                        "D",
                                )
                                curX, curY = ex, ey
                                i += 4
                        }</span>
                case "q":<span class="cov8" title="1">
                        for i+3 &lt; len(cmds) &amp;&amp; !isSVGCommand(cmds[i]) </span><span class="cov8" title="1">{
                                dqx := atof(cmds[i])
                                dqy := atof(cmds[i+1])
                                dex := atof(cmds[i+2])
                                dey := atof(cmds[i+3])
                                qx := curX + dqx
                                qy := curY + dqy
                                ex := curX + dex
                                ey := curY + dey
                                c1x := curX + 2.0/3.0*(qx-curX)
                                c1y := curY + 2.0/3.0*(qy-curY)
                                c2x := ex + 2.0/3.0*(qx-ex)
                                c2y := ey + 2.0/3.0*(qy-ey)
                                gp.Curve(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+c1x*scaleX, offY+c1y*scaleY,
                                        offX+c2x*scaleX, offY+c2y*scaleY,
                                        offX+ex*scaleX, offY+ey*scaleY,
                                        "D",
                                )
                                curX, curY = ex, ey
                                i += 4
                        }</span>
                case "Z", "z":<span class="cov8" title="1">
                        if curX != startX || curY != startY </span><span class="cov8" title="1">{
                                gp.Line(
                                        offX+curX*scaleX, offY+curY*scaleY,
                                        offX+startX*scaleX, offY+startY*scaleY,
                                )
                                curX, curY = startX, startY
                        }</span>
                }
        }
}

// tokenizeSVGPath splits an SVG path "d" attribute into commands and numbers.
func tokenizeSVGPath(d string) []string <span class="cov8" title="1">{
        var tokens []string
        var current strings.Builder

        flush := func() </span><span class="cov8" title="1">{
                s := strings.TrimSpace(current.String())
                if s != "" </span><span class="cov8" title="1">{
                        tokens = append(tokens, s)
                }</span>
                <span class="cov8" title="1">current.Reset()</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(d); i++ </span><span class="cov8" title="1">{
                ch := d[i]
                switch </span>{
                case ch == ',' || ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r':<span class="cov8" title="1">
                        flush()</span>
                case isSVGCommandByte(ch):<span class="cov8" title="1">
                        flush()
                        tokens = append(tokens, string(ch))</span>
                case ch == '-' &amp;&amp; current.Len() &gt; 0:<span class="cov8" title="1">
                        // Negative number starts a new token
                        flush()
                        current.WriteByte(ch)</span>
                default:<span class="cov8" title="1">
                        current.WriteByte(ch)</span>
                }
        }
        <span class="cov8" title="1">flush()
        return tokens</span>
}

func isSVGCommand(s string) bool <span class="cov8" title="1">{
        if len(s) != 1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return isSVGCommandByte(s[0])</span>
}

func isSVGCommandByte(ch byte) bool <span class="cov8" title="1">{
        switch ch </span>{
        case 'M', 'm', 'L', 'l', 'H', 'h', 'V', 'v', 'C', 'c', 'S', 's',
                'Q', 'q', 'T', 't', 'A', 'a', 'Z', 'z':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Ensure math import is used
var _ = math.Pi
</pre>
		
		<pre class="file" id="file114" style="display: none">package gopdf

// Represents an RGB color with red, green, and blue components
type RGBColor struct {
        R uint8 // Red component (0-255)
        G uint8 // Green component (0-255)
        B uint8 // Blue component (0-255)
}

// Defines the border style for a cell or table
type BorderStyle struct {
        Top      bool     // Whether to draw the top border
        Left     bool     // Whether to draw the left border
        Right    bool     // Whether to draw the right border
        Bottom   bool     // Whether to draw the bottom border
        Width    float64  // Width of the border line
        RGBColor RGBColor // Color of the border
}

// Defines the style for a cell, including border, fill, text, and font properties
type CellStyle struct {
        BorderStyle BorderStyle // Border style for the cell
        FillColor   RGBColor    // Background color of the cell
        TextColor   RGBColor    // Color of the text in the cell
        Font        string      // Font name for the cell text
        FontSize    float64     // Font size for the cell text
}

type RowCell struct {
        content      string    // Content (display value) of the cell
        useCellStyle bool      // If true, use cellStyle instead of the style in the tableLayout
        cellStyle    CellStyle // Style of the cell
}

func NewRowCell(content string, cellStyle CellStyle) RowCell <span class="cov8" title="1">{
        return newStyledRowCell(content, true, cellStyle)

}</span>

func newStyledRowCell(content string, useCellStyle bool, cellStyle CellStyle) RowCell <span class="cov8" title="1">{
        return RowCell{
                content:      content,
                useCellStyle: useCellStyle,
                cellStyle:    cellStyle,
        }
}</span>

type TableLayout interface {
        AddColumn(header string, width float64, align string)
        AddRow(row []string)
        AddStyledRow(row []RowCell)
        SetTableStyle(style CellStyle)
        SetHeaderStyle(style CellStyle)
        SetCellStyle(style CellStyle)
        DrawTable() error
}

// Represents the layout of a table
type tableLayout struct {
        pdf       *GoPdf      // Reference to the GoPdf instance
        startX    float64     // Starting X coordinate of the table
        startY    float64     // Starting Y coordinate of the table
        rowHeight float64     // Height of each row in the table
        columns   []column    // Slice of column definitions
        rows      [][]RowCell // Slice of rows, each containing cell contents
        //styledRows   [][]RowCell // Slice of rows, each containing cell contents and styles.
        maxRows     int        // Maximum number of rows in the table
        padding     float64    // Padding inside each cell
        cellOption  CellOption // Options for cell content rendering
        tableStyle  CellStyle  // Style for the entire table
        headerStyle CellStyle  // Style for the header row
        cellStyle   CellStyle  // Style for regular cells
}

var _ TableLayout = (*tableLayout)(nil)

// Represents a column in the table
type column struct {
        header string  // Header text for the column
        width  float64 // Width of the column
        align  string  // Alignment of content within the column
}

// Creates a new table layout with the given parameters
func (gp *GoPdf) NewTableLayout(startX, startY, rowHeight float64, maxRows int) TableLayout <span class="cov8" title="1">{
        return &amp;tableLayout{
                pdf:       gp,
                startX:    startX,
                startY:    startY,
                rowHeight: rowHeight,
                maxRows:   maxRows,
                padding:   2.0,
                cellOption: CellOption{
                        BreakOption: &amp;BreakOption{
                                Mode:           BreakModeIndicatorSensitive,
                                BreakIndicator: ' ',
                        },
                },
                tableStyle: CellStyle{
                        BorderStyle: BorderStyle{
                                Top: true, Left: true, Right: true, Bottom: true,
                                Width:    0.5,
                                RGBColor: RGBColor{R: 0, G: 0, B: 0},
                        },
                },
                headerStyle: CellStyle{
                        BorderStyle: BorderStyle{
                                Top: true, Left: true, Right: true, Bottom: true,
                                Width:    0.5,
                                RGBColor: RGBColor{R: 0, G: 0, B: 0},
                        },
                        FillColor: RGBColor{R: 240, G: 240, B: 240},
                        TextColor: RGBColor{R: 0, G: 0, B: 0},
                },
                cellStyle: CellStyle{
                        BorderStyle: BorderStyle{
                                Top: true, Left: true, Right: true, Bottom: true,
                                Width:    0.5,
                                RGBColor: RGBColor{R: 0, G: 0, B: 0},
                        },
                        TextColor: RGBColor{R: 0, G: 0, B: 0},
                },
        }
}</span>

// Adds a column to the table with the specified header, width, and alignment
func (t *tableLayout) AddColumn(header string, width float64, align string) <span class="cov8" title="1">{
        t.columns = append(t.columns, column{header, width, align})
}</span>

// Adds a row of data to the table
func (t *tableLayout) AddRow(row []string) <span class="cov8" title="1">{
        rowCell := make([]RowCell, len(row))
        for i, cell := range row </span><span class="cov8" title="1">{
                rowCell[i] = newStyledRowCell(cell, false, CellStyle{})
        }</span>
        <span class="cov8" title="1">t.rows = append(t.rows, rowCell)</span>
}

// Adds a row of data to the table with individual styled cells
// Useful for styling individual cells in a row
func (t *tableLayout) AddStyledRow(row []RowCell) <span class="cov8" title="1">{
        t.rows = append(t.rows, row)
}</span>

// Sets the style for the entire table
func (t *tableLayout) SetTableStyle(style CellStyle) <span class="cov8" title="1">{
        t.tableStyle = style
}</span>

// Sets the style for the header row
func (t *tableLayout) SetHeaderStyle(style CellStyle) <span class="cov8" title="1">{
        t.headerStyle = style
}</span>

// Sets the style for regular cells
func (t *tableLayout) SetCellStyle(style CellStyle) <span class="cov8" title="1">{
        t.cellStyle = style
}</span>

// DrawTable the entire table on the PDF
func (t *tableLayout) DrawTable() error <span class="cov8" title="1">{
        x := t.startX
        y := t.startY

        // Draw the header row
        for _, col := range t.columns </span><span class="cov8" title="1">{
                if err := t.drawCell(
                        x,
                        y,
                        col.width,
                        t.rowHeight,
                        col.header,
                        "center",
                        true, /*isHeader*/
                        t.headerStyle,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">x += col.width</span>
        }
        <span class="cov8" title="1">y += t.rowHeight

        // Draw the data rows
        for _, row := range t.rows </span><span class="cov8" title="1">{
                x = t.startX
                for i, cell := range row </span><span class="cov8" title="1">{
                        cellStyle := t.cellStyle
                        if cell.useCellStyle </span><span class="cov8" title="1">{
                                cellStyle = cell.cellStyle
                        }</span>
                        <span class="cov8" title="1">if err := t.drawCell(
                                x,
                                y,
                                t.columns[i].width,
                                t.rowHeight,
                                cell.content,
                                t.columns[i].align,
                                false, /*isHeader*/
                                cellStyle,
                        ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">x += t.columns[i].width</span>
                }
                <span class="cov8" title="1">y += t.rowHeight</span>
        }

        // Fill any remaining rows with empty cells
        <span class="cov8" title="1">for i := len(t.rows); i &lt; t.maxRows; i++ </span><span class="cov8" title="1">{
                x = t.startX
                for _, col := range t.columns </span><span class="cov8" title="1">{
                        if err := t.drawCell(
                                x,
                                y,
                                col.width,
                                t.rowHeight,
                                "",
                                col.align,
                                false, /*isHeader*/
                                t.cellStyle,
                        ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">x += col.width</span>
                }
                <span class="cov8" title="1">y += t.rowHeight</span>
        }

        // Draw the outer border of the table and header
        <span class="cov8" title="1">if err := t.drawTableAndHeaderBorder(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Draws the outer border of the table and header
func (t *tableLayout) drawTableAndHeaderBorder() error <span class="cov8" title="1">{
        x1 := t.startX
        y1 := t.startY
        x2 := t.startX
        y2 := t.startY + float64(t.maxRows+1)*t.rowHeight

        for _, col := range t.columns </span><span class="cov8" title="1">{
                x2 += col.width
        }</span>

        // Draw borders of the table
        <span class="cov8" title="1">err := t.drawBorder(x1, y1, x2, y2, t.tableStyle.BorderStyle)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Draw borders of the header
        <span class="cov8" title="1">return t.drawBorder(x1, y1, x2, y1+t.rowHeight, t.headerStyle.BorderStyle)</span>
}

// Draws a single cell of the table
func (t *tableLayout) drawCell(
        x float64,
        y float64,
        width float64,
        height float64,
        content string,
        align string,
        isHeader bool,
        style CellStyle,
) error <span class="cov8" title="1">{
        // Fill the cell background if a fill color is specified
        if style.FillColor != (RGBColor{}) </span><span class="cov8" title="1">{
                t.pdf.SetFillColor(style.FillColor.R, style.FillColor.G, style.FillColor.B)
                t.pdf.RectFromUpperLeftWithStyle(x, y, width, height, "F")
        }</span>

        <span class="cov8" title="1">if !isHeader </span><span class="cov8" title="1">{
                // Draw the cell border
                if err := t.drawBorder(x, y, x+width, y+height, style.BorderStyle); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Calculate the text area within the cell
        <span class="cov8" title="1">textX := x + t.padding
        textY := y + t.padding
        textWidth := width - (2 * t.padding)
        textHeight := height - (2 * t.padding)

        t.pdf.SetXY(textX, textY)

        // Set the text alignment
        var textOption = t.cellOption
        if align == "right" </span><span class="cov8" title="1">{
                textOption.Align = Right | Middle
        }</span> else<span class="cov8" title="1"> if align == "center" </span><span class="cov8" title="1">{
                textOption.Align = Center | Middle
        }</span> else<span class="cov8" title="1"> {
                textOption.Align = Left | Middle
        }</span>

        // Set the text color and font
        <span class="cov8" title="1">t.pdf.SetTextColor(style.TextColor.R, style.TextColor.G, style.TextColor.B)
        if style.Font != "" </span><span class="cov8" title="1">{
                t.pdf.SetFont(style.Font, "", style.FontSize)
        }</span>

        // Draw the cell content
        <span class="cov8" title="1">err := t.pdf.MultiCellWithOption(&amp;Rect{W: textWidth, H: textHeight}, content, textOption)
        if err != nil &amp;&amp; err.Error() == "empty string" </span><span class="cov8" title="1">{
                err = nil
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Draws a border around a rectangular area
func (t *tableLayout) drawBorder(x1, y1, x2, y2 float64, borderStyle BorderStyle) error <span class="cov8" title="1">{
        if borderStyle.Width &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">t.pdf.SetLineWidth(borderStyle.Width)
        t.pdf.SetStrokeColor(borderStyle.RGBColor.R, borderStyle.RGBColor.G, borderStyle.RGBColor.B)
        half := borderStyle.Width / 2.0

        // Draw each side of the border if specified
        if borderStyle.Top </span><span class="cov8" title="1">{
                t.pdf.Line(x1-half, y1, x2+half, y1)
        }</span>
        <span class="cov8" title="1">if borderStyle.Bottom </span><span class="cov8" title="1">{
                t.pdf.Line(x1-half, y2, x2+half, y2)
        }</span>
        <span class="cov8" title="1">if borderStyle.Left </span><span class="cov8" title="1">{
                t.pdf.Line(x1, y1-half, x1, y2+half)
        }</span>
        <span class="cov8" title="1">if borderStyle.Right </span><span class="cov8" title="1">{
                t.pdf.Line(x2, y1-half, x2, y2+half)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package gopdf

import (
        "bytes"
        "fmt"
        "math"
        "regexp"
        "strconv"
        "strings"
        "unicode/utf16"
)

// Pre-compiled regexes for text extraction â€” avoids recompilation per call.
var (
        reExtractHexPairs = regexp.MustCompile(`&lt;([0-9a-fA-F]+)&gt;`)
        reBfChar          = regexp.MustCompile(`(?s)beginbfchar\s*(.*?)\s*endbfchar`)
        reBfRange         = regexp.MustCompile(`(?s)beginbfrange\s*(.*?)\s*endbfrange`)
)

// ============================================================
// Text extraction from existing PDF files
// ============================================================

// ExtractTextFromPage extracts text from a specific page (0-based) of
// the given PDF data. Returns a list of ExtractedText items with
// position, font, and text content.
//
// This is a pure-Go PDF content stream parser that handles the most
// common text operators: BT/ET, Tf, Td, TD, Tm, T*, Tj, TJ, ', ".
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        texts, _ := gopdf.ExtractTextFromPage(data, 0)
//        for _, t := range texts {
//            fmt.Printf("(%0.f,%0.f) %s\n", t.X, t.Y, t.Text)
//        }
func ExtractTextFromPage(pdfData []byte, pageIndex int) ([]ExtractedText, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if pageIndex &lt; 0 || pageIndex &gt;= len(parser.pages) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("page index %d out of range (0..%d)", pageIndex, len(parser.pages)-1)
        }</span>
        <span class="cov8" title="1">stream := parser.getPageContentStream(pageIndex)
        if len(stream) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">page := parser.pages[pageIndex]
        fonts := buildFontMap(parser, page)
        return parseTextOperators(stream, fonts, page.mediaBox), nil</span>
}

// ExtractTextFromAllPages extracts text from all pages.
func ExtractTextFromAllPages(pdfData []byte) (map[int][]ExtractedText, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := make(map[int][]ExtractedText, len(parser.pages))
        for i := range parser.pages </span><span class="cov8" title="1">{
                stream := parser.getPageContentStream(i)
                if len(stream) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">page := parser.pages[i]
                fonts := buildFontMap(parser, page)
                texts := parseTextOperators(stream, fonts, page.mediaBox)
                if len(texts) &gt; 0 </span><span class="cov8" title="1">{
                        result[i] = texts
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// ExtractPageText extracts all text from a page as a single string.
// Convenience wrapper around ExtractTextFromPage.
func ExtractPageText(pdfData []byte, pageIndex int) (string, error) <span class="cov8" title="1">{
        texts, err := ExtractTextFromPage(pdfData, pageIndex)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">var sb strings.Builder
        lastY := math.MaxFloat64
        for _, t := range texts </span><span class="cov8" title="1">{
                if math.Abs(t.Y-lastY) &gt; 2 &amp;&amp; lastY != math.MaxFloat64 </span><span class="cov8" title="1">{
                        sb.WriteByte('\n')
                }</span> else<span class="cov8" title="1"> if sb.Len() &gt; 0 &amp;&amp; lastY != math.MaxFloat64 </span><span class="cov0" title="0">{
                        sb.WriteByte(' ')
                }</span>
                <span class="cov8" title="1">sb.WriteString(t.Text)
                lastY = t.Y</span>
        }
        <span class="cov8" title="1">return sb.String(), nil</span>
}

// fontInfo holds decoded font information for text extraction.
type fontInfo struct {
        name     string // resource name like /F1
        baseFont string
        encoding string
        toUni    map[uint16]rune // CMap: character code -&gt; unicode
        isType0  bool
}

func buildFontMap(parser *rawPDFParser, page rawPDFPage) map[string]*fontInfo <span class="cov8" title="1">{
        fonts := make(map[string]*fontInfo, len(page.resources.fonts))
        for name, objNum := range page.resources.fonts </span><span class="cov8" title="1">{
                fi := &amp;fontInfo{name: name}
                obj, ok := parser.objects[objNum]
                if ok </span><span class="cov8" title="1">{
                        fi.baseFont = extractName(obj.dict, "/BaseFont")
                        fi.encoding = extractName(obj.dict, "/Encoding")
                        fi.isType0 = strings.Contains(obj.dict, "/Type0") ||
                                strings.Contains(obj.dict, "/Identity-H") ||
                                strings.Contains(obj.dict, "/Identity-V")
                        // Try to parse /ToUnicode CMap
                        toUniRef := extractRef(obj.dict, "/ToUnicode")
                        if toUniRef &gt; 0 </span><span class="cov8" title="1">{
                                if cmapObj, ok2 := parser.objects[toUniRef]; ok2 &amp;&amp; cmapObj.stream != nil </span><span class="cov8" title="1">{
                                        fi.toUni = parseCMap(cmapObj.stream)
                                }</span>
                        }
                }
                <span class="cov8" title="1">fonts[name] = fi</span>
        }
        <span class="cov8" title="1">return fonts</span>
}

// extractName extracts a /Name value from a dict string.
// Uses string search instead of regex for performance.
func extractName(dict, key string) string <span class="cov8" title="1">{
        idx := strings.Index(dict, key)
        if idx &lt; 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">rest := dict[idx+len(key):]
        // Skip whitespace
        i := 0
        for i &lt; len(rest) &amp;&amp; (rest[i] == ' ' || rest[i] == '\t' || rest[i] == '\r' || rest[i] == '\n') </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">if i &gt;= len(rest) || rest[i] != '/' </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">i++ // skip '/'
        start := i
        for i &lt; len(rest) &amp;&amp; rest[i] != ' ' &amp;&amp; rest[i] != '\t' &amp;&amp; rest[i] != '\r' &amp;&amp;
                rest[i] != '\n' &amp;&amp; rest[i] != '/' &amp;&amp; rest[i] != '&gt;' &amp;&amp; rest[i] != '[' </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">if i &gt; start </span><span class="cov8" title="1">{
                return rest[start:i]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// parseCMap parses a ToUnicode CMap stream to build a code-&gt;rune mapping.
func parseCMap(data []byte) map[uint16]rune <span class="cov8" title="1">{
        m := make(map[uint16]rune, 64)
        s := string(data)

        // Parse beginbfchar ... endbfchar sections
        for _, match := range reBfChar.FindAllStringSubmatch(s, -1) </span><span class="cov8" title="1">{
                lines := strings.Split(strings.TrimSpace(match[1]), "\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        parts := extractHexPairs(line)
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                code := parseHex16(parts[0])
                                uni := parseHex16(parts[1])
                                m[code] = rune(uni)
                        }</span>
                }
        }

        // Parse beginbfrange ... endbfrange sections
        <span class="cov8" title="1">for _, match := range reBfRange.FindAllStringSubmatch(s, -1) </span><span class="cov8" title="1">{
                lines := strings.Split(strings.TrimSpace(match[1]), "\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        parts := extractHexPairs(line)
                        if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                start := parseHex16(parts[0])
                                end := parseHex16(parts[1])
                                uniStart := parseHex16(parts[2])
                                for code := start; code &lt;= end; code++ </span><span class="cov8" title="1">{
                                        m[code] = rune(uniStart + (code - start))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return m</span>
}

func extractHexPairs(line string) []string <span class="cov8" title="1">{
        matches := reExtractHexPairs.FindAllStringSubmatch(line, -1)
        result := make([]string, 0, len(matches))
        for _, m := range matches </span><span class="cov8" title="1">{
                result = append(result, m[1])
        }</span>
        <span class="cov8" title="1">return result</span>
}

func parseHex16(s string) uint16 <span class="cov8" title="1">{
        v, _ := strconv.ParseUint(s, 16, 32)
        return uint16(v)
}</span>

// parseTextOperators parses PDF content stream text operators.
func parseTextOperators(stream []byte, fonts map[string]*fontInfo, mediaBox [4]float64) []ExtractedText <span class="cov8" title="1">{
        tokens := tokenize(stream)
        // Pre-allocate with estimated capacity based on stream size.
        results := make([]ExtractedText, 0, len(stream)/100+16)

        // Text state
        var (
                inText   bool
                curFont  *fontInfo
                fontSize float64
                // Text matrix components
                tmX, tmY     float64
                // Line matrix
                tlmX, tlmY   float64
                // CTM (simplified â€” only tracking translation)
                ctmA, ctmD   float64 = 1, 1
                ctmE, ctmF   float64
                tl            float64 // text leading
        )
        pageHeight := mediaBox[3] - mediaBox[1]

        stack := make([]float64, 0, 64)
        pushNum := func(s string) </span><span class="cov8" title="1">{
                v, err := strconv.ParseFloat(s, 64)
                if err == nil </span><span class="cov8" title="1">{
                        stack = append(stack, v)
                }</span>
        }
        <span class="cov8" title="1">popN := func(n int) []float64 </span><span class="cov8" title="1">{
                if len(stack) &lt; n </span><span class="cov8" title="1">{
                        r := make([]float64, n)
                        stack = stack[:0]
                        return r
                }</span>
                <span class="cov8" title="1">r := make([]float64, n)
                copy(r, stack[len(stack)-n:])
                stack = stack[:len(stack)-n]
                return r</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(tokens); i++ </span><span class="cov8" title="1">{
                tok := tokens[i]

                // Try to parse as number
                if _, err := strconv.ParseFloat(tok, 64); err == nil </span><span class="cov8" title="1">{
                        pushNum(tok)
                        continue</span>
                }

                <span class="cov8" title="1">switch tok </span>{
                case "BT":<span class="cov8" title="1">
                        inText = true
                        tmX, tmY = 0, 0
                        tlmX, tlmY = 0, 0</span>
                case "ET":<span class="cov8" title="1">
                        inText = false
                        stack = stack[:0]</span>
                case "Tf":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">args := popN(1)
                        fontSize = args[0]
                        // font name is the token before the size number
                        // We need to look back in the original tokens
                        if i &gt;= 2 </span><span class="cov8" title="1">{
                                fname := tokens[i-2]
                                if strings.HasPrefix(fname, "/") </span><span class="cov8" title="1">{
                                        if f, ok := fonts[fname]; ok </span><span class="cov8" title="1">{
                                                curFont = f
                                        }</span>
                                }
                        }
                case "Td":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">args := popN(2)
                        tlmX += args[0]
                        tlmY += args[1]
                        tmX, tmY = tlmX, tlmY</span>
                case "TD":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">args := popN(2)
                        tl = -args[1]
                        tlmX += args[0]
                        tlmY += args[1]
                        tmX, tmY = tlmX, tlmY</span>
                case "Tm":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">args := popN(6)
                        // args = [a b c d e f]
                        tmX = args[4]
                        tmY = args[5]
                        tlmX, tlmY = tmX, tmY
                        if args[0] != 0 </span><span class="cov8" title="1">{
                                fontSize = math.Abs(args[0])
                        }</span>
                case "T*":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">tlmX += 0
                        tlmY -= tl
                        tmX, tmY = tlmX, tlmY</span>
                case "TL":<span class="cov8" title="1">
                        args := popN(1)
                        tl = args[0]</span>
                case "Tj":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // String is the previous token (in parentheses or hex)
                        <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                                raw := findStringBefore(tokens, i)
                                text := decodeTextString(raw, curFont)
                                if text != "" </span><span class="cov8" title="1">{
                                        x := ctmA*tmX + ctmE
                                        y := pageHeight - (ctmD*tmY + ctmF)
                                        results = append(results, ExtractedText{
                                                Text:     text,
                                                X:        x,
                                                Y:        y,
                                                FontName: fontDisplayName(curFont),
                                                FontSize: fontSize,
                                        })
                                }</span>
                        }
                case "TJ":<span class="cov8" title="1">
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // TJ takes an array: [(string) num (string) ...]
                        <span class="cov8" title="1">arr := findArrayBefore(tokens, i)
                        var combined strings.Builder
                        for _, item := range arr </span><span class="cov8" title="1">{
                                if isStringToken(item) </span><span class="cov8" title="1">{
                                        combined.WriteString(decodeTextString(item, curFont))
                                }</span>
                        }
                        <span class="cov8" title="1">text := combined.String()
                        if text != "" </span><span class="cov8" title="1">{
                                x := ctmA*tmX + ctmE
                                y := pageHeight - (ctmD*tmY + ctmF)
                                results = append(results, ExtractedText{
                                        Text:     text,
                                        X:        x,
                                        Y:        y,
                                        FontName: fontDisplayName(curFont),
                                        FontSize: fontSize,
                                })
                        }</span>
                case "'":<span class="cov8" title="1">
                        // Move to next line and show string
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">tlmY -= tl
                        tmX, tmY = tlmX, tlmY
                        if i &gt;= 1 </span><span class="cov8" title="1">{
                                raw := findStringBefore(tokens, i)
                                text := decodeTextString(raw, curFont)
                                if text != "" </span><span class="cov8" title="1">{
                                        x := ctmA*tmX + ctmE
                                        y := pageHeight - (ctmD*tmY + ctmF)
                                        results = append(results, ExtractedText{
                                                Text: text, X: x, Y: y,
                                                FontName: fontDisplayName(curFont), FontSize: fontSize,
                                        })
                                }</span>
                        }
                case "\"":<span class="cov8" title="1">
                        // aw ac string " â€” set word/char spacing, move to next line, show
                        if !inText </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">popN(2) // aw, ac
                        tlmY -= tl
                        tmX, tmY = tlmX, tlmY
                        if i &gt;= 1 </span><span class="cov8" title="1">{
                                raw := findStringBefore(tokens, i)
                                text := decodeTextString(raw, curFont)
                                if text != "" </span><span class="cov8" title="1">{
                                        x := ctmA*tmX + ctmE
                                        y := pageHeight - (ctmD*tmY + ctmF)
                                        results = append(results, ExtractedText{
                                                Text: text, X: x, Y: y,
                                                FontName: fontDisplayName(curFont), FontSize: fontSize,
                                        })
                                }</span>
                        }
                case "cm":<span class="cov8" title="1">
                        args := popN(6)
                        ctmA = args[0]
                        ctmD = args[3]
                        ctmE = args[4]
                        ctmF = args[5]</span>
                }
        }
        <span class="cov8" title="1">return results</span>
}

// tokenize splits a PDF content stream into tokens.
func tokenize(data []byte) []string <span class="cov8" title="1">{
        // Pre-allocate with estimated capacity.
        tokens := make([]string, 0, len(data)/4+16)
        i := 0
        n := len(data)
        for i &lt; n </span><span class="cov8" title="1">{
                // skip whitespace
                if data[i] == ' ' || data[i] == '\t' || data[i] == '\r' || data[i] == '\n' </span><span class="cov8" title="1">{
                        i++
                        continue</span>
                }
                // comment
                <span class="cov8" title="1">if data[i] == '%' </span><span class="cov8" title="1">{
                        for i &lt; n &amp;&amp; data[i] != '\n' &amp;&amp; data[i] != '\r' </span><span class="cov8" title="1">{
                                i++
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                // string literal (...)
                <span class="cov8" title="1">if data[i] == '(' </span><span class="cov8" title="1">{
                        depth := 1
                        start := i
                        i++
                        for i &lt; n &amp;&amp; depth &gt; 0 </span><span class="cov8" title="1">{
                                if data[i] == '\\' </span><span class="cov8" title="1">{
                                        i += 2
                                        continue</span>
                                }
                                <span class="cov8" title="1">if data[i] == '(' </span><span class="cov8" title="1">{
                                        depth++
                                }</span> else<span class="cov8" title="1"> if data[i] == ')' </span><span class="cov8" title="1">{
                                        depth--
                                }</span>
                                <span class="cov8" title="1">i++</span>
                        }
                        <span class="cov8" title="1">tokens = append(tokens, string(data[start:i]))
                        continue</span>
                }
                // hex string &lt;...&gt;
                <span class="cov8" title="1">if data[i] == '&lt;' &amp;&amp; (i+1 &gt;= n || data[i+1] != '&lt;') </span><span class="cov8" title="1">{
                        start := i
                        i++
                        for i &lt; n &amp;&amp; data[i] != '&gt;' </span><span class="cov8" title="1">{
                                i++
                        }</span>
                        <span class="cov8" title="1">if i &lt; n </span><span class="cov8" title="1">{
                                i++ // skip &gt;
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(data[start:i]))
                        continue</span>
                }
                // dict &lt;&lt; &gt;&gt;
                <span class="cov8" title="1">if data[i] == '&lt;' &amp;&amp; i+1 &lt; n &amp;&amp; data[i+1] == '&lt;' </span><span class="cov8" title="1">{
                        tokens = append(tokens, "&lt;&lt;")
                        i += 2
                        continue</span>
                }
                <span class="cov8" title="1">if data[i] == '&gt;' &amp;&amp; i+1 &lt; n &amp;&amp; data[i+1] == '&gt;' </span><span class="cov8" title="1">{
                        tokens = append(tokens, "&gt;&gt;")
                        i += 2
                        continue</span>
                }
                // array delimiters
                <span class="cov8" title="1">if data[i] == '[' </span><span class="cov8" title="1">{
                        tokens = append(tokens, "[")
                        i++
                        continue</span>
                }
                <span class="cov8" title="1">if data[i] == ']' </span><span class="cov8" title="1">{
                        tokens = append(tokens, "]")
                        i++
                        continue</span>
                }
                // regular token (name, number, operator)
                <span class="cov8" title="1">start := i
                for i &lt; n &amp;&amp; data[i] != ' ' &amp;&amp; data[i] != '\t' &amp;&amp; data[i] != '\r' &amp;&amp;
                        data[i] != '\n' &amp;&amp; data[i] != '(' &amp;&amp; data[i] != ')' &amp;&amp;
                        data[i] != '&lt;' &amp;&amp; data[i] != '&gt;' &amp;&amp; data[i] != '[' &amp;&amp;
                        data[i] != ']' &amp;&amp; data[i] != '%' </span><span class="cov8" title="1">{
                        i++
                }</span>
                <span class="cov8" title="1">if i &gt; start </span><span class="cov8" title="1">{
                        tokens = append(tokens, string(data[start:i]))
                }</span>
        }
        <span class="cov8" title="1">return tokens</span>
}

func isStringToken(s string) bool <span class="cov8" title="1">{
        return (strings.HasPrefix(s, "(") &amp;&amp; strings.HasSuffix(s, ")")) ||
                (strings.HasPrefix(s, "&lt;") &amp;&amp; strings.HasSuffix(s, "&gt;") &amp;&amp; !strings.HasPrefix(s, "&lt;&lt;"))
}</span>

func findStringBefore(tokens []string, opIdx int) string <span class="cov8" title="1">{
        for j := opIdx - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if isStringToken(tokens[j]) </span><span class="cov8" title="1">{
                        return tokens[j]
                }</span>
                // stop if we hit another operator
                <span class="cov8" title="1">if _, err := strconv.ParseFloat(tokens[j], 64); err != nil &amp;&amp; tokens[j] != "[" &amp;&amp; tokens[j] != "]" </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func findArrayBefore(tokens []string, opIdx int) []string <span class="cov8" title="1">{
        // Walk backwards to find matching [ ... ]
        end := -1
        start := -1
        for j := opIdx - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if tokens[j] == "]" </span><span class="cov8" title="1">{
                        end = j
                }</span>
                <span class="cov8" title="1">if tokens[j] == "[" </span><span class="cov8" title="1">{
                        start = j
                        break</span>
                }
        }
        <span class="cov8" title="1">if start &gt;= 0 &amp;&amp; end &gt; start </span><span class="cov8" title="1">{
                return tokens[start+1 : end]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func fontDisplayName(fi *fontInfo) string <span class="cov8" title="1">{
        if fi == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if fi.baseFont != "" </span><span class="cov8" title="1">{
                return fi.baseFont
        }</span>
        <span class="cov8" title="1">return fi.name</span>
}

// decodeTextString decodes a PDF string token to a Go string.
func decodeTextString(raw string, fi *fontInfo) string <span class="cov8" title="1">{
        if raw == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(raw, "&lt;") &amp;&amp; strings.HasSuffix(raw, "&gt;") </span><span class="cov8" title="1">{
                // Hex string
                hex := raw[1 : len(raw)-1]
                hex = strings.ReplaceAll(hex, " ", "")
                hex = strings.ReplaceAll(hex, "\n", "")
                hex = strings.ReplaceAll(hex, "\r", "")
                if fi != nil &amp;&amp; fi.toUni != nil </span><span class="cov8" title="1">{
                        return decodeHexWithCMap(hex, fi.toUni)
                }</span>
                <span class="cov8" title="1">if fi != nil &amp;&amp; fi.isType0 </span><span class="cov8" title="1">{
                        return decodeHexUTF16BE(hex)
                }</span>
                <span class="cov8" title="1">return decodeHexLatin(hex)</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(raw, "(") &amp;&amp; strings.HasSuffix(raw, ")") </span><span class="cov8" title="1">{
                inner := raw[1 : len(raw)-1]
                inner = unescapePDFString(inner)
                // Check for UTF-16BE BOM
                if len(inner) &gt;= 2 &amp;&amp; inner[0] == '\xfe' &amp;&amp; inner[1] == '\xff' </span><span class="cov8" title="1">{
                        return decodeUTF16BE([]byte(inner[2:]))
                }</span>
                <span class="cov8" title="1">if fi != nil &amp;&amp; fi.toUni != nil </span><span class="cov8" title="1">{
                        // Try CMap mapping byte by byte
                        var sb strings.Builder
                        for j := 0; j &lt; len(inner); j++ </span><span class="cov8" title="1">{
                                code := uint16(inner[j])
                                if r, ok := fi.toUni[code]; ok </span><span class="cov8" title="1">{
                                        sb.WriteRune(r)
                                }</span> else<span class="cov0" title="0"> {
                                        sb.WriteByte(inner[j])
                                }</span>
                        }
                        <span class="cov8" title="1">return sb.String()</span>
                }
                <span class="cov8" title="1">return inner</span>
        }
        <span class="cov8" title="1">return raw</span>
}

func decodeHexWithCMap(hex string, cmap map[uint16]rune) string <span class="cov8" title="1">{
        var sb strings.Builder
        // Try 4-digit codes first (CID fonts), fall back to 2-digit
        if len(hex)%4 == 0 </span><span class="cov8" title="1">{
                for i := 0; i+3 &lt; len(hex); i += 4 </span><span class="cov8" title="1">{
                        code := parseHex16(hex[i : i+4])
                        if r, ok := cmap[code]; ok </span><span class="cov8" title="1">{
                                sb.WriteRune(r)
                        }</span> else<span class="cov8" title="1"> if code &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteRune(rune(code))
                        }</span>
                }
                <span class="cov8" title="1">return sb.String()</span>
        }
        <span class="cov8" title="1">for i := 0; i+1 &lt; len(hex); i += 2 </span><span class="cov8" title="1">{
                code := parseHex16(hex[i : i+2])
                if r, ok := cmap[code]; ok </span><span class="cov8" title="1">{
                        sb.WriteRune(r)
                }</span> else<span class="cov8" title="1"> {
                        sb.WriteByte(byte(code))
                }</span>
        }
        <span class="cov8" title="1">return sb.String()</span>
}

func decodeHexUTF16BE(hex string) string <span class="cov8" title="1">{
        if len(hex)%4 != 0 </span><span class="cov8" title="1">{
                // fall back to latin
                return decodeHexLatin(hex)
        }</span>
        <span class="cov8" title="1">codes := make([]uint16, 0, len(hex)/4)
        for i := 0; i+3 &lt; len(hex); i += 4 </span><span class="cov8" title="1">{
                codes = append(codes, parseHex16(hex[i:i+4]))
        }</span>
        <span class="cov8" title="1">return string(utf16.Decode(codes))</span>
}

func decodeHexLatin(hex string) string <span class="cov8" title="1">{
        var sb strings.Builder
        for i := 0; i+1 &lt; len(hex); i += 2 </span><span class="cov8" title="1">{
                b := parseHex16(hex[i : i+2])
                sb.WriteByte(byte(b))
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}

func decodeUTF16BE(data []byte) string <span class="cov8" title="1">{
        if len(data)%2 != 0 </span><span class="cov8" title="1">{
                data = append(data, 0)
        }</span>
        <span class="cov8" title="1">codes := make([]uint16, 0, len(data)/2)
        for i := 0; i+1 &lt; len(data); i += 2 </span><span class="cov8" title="1">{
                codes = append(codes, uint16(data[i])&lt;&lt;8|uint16(data[i+1]))
        }</span>
        <span class="cov8" title="1">return string(utf16.Decode(codes))</span>
}

func unescapePDFString(s string) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        i := 0
        for i &lt; len(s) </span><span class="cov8" title="1">{
                if s[i] == '\\' &amp;&amp; i+1 &lt; len(s) </span><span class="cov8" title="1">{
                        i++
                        switch s[i] </span>{
                        case 'n':<span class="cov8" title="1">
                                buf.WriteByte('\n')</span>
                        case 'r':<span class="cov8" title="1">
                                buf.WriteByte('\r')</span>
                        case 't':<span class="cov8" title="1">
                                buf.WriteByte('\t')</span>
                        case 'b':<span class="cov8" title="1">
                                buf.WriteByte('\b')</span>
                        case 'f':<span class="cov8" title="1">
                                buf.WriteByte('\f')</span>
                        case '(':<span class="cov8" title="1">
                                buf.WriteByte('(')</span>
                        case ')':<span class="cov8" title="1">
                                buf.WriteByte(')')</span>
                        case '\\':<span class="cov8" title="1">
                                buf.WriteByte('\\')</span>
                        default:<span class="cov8" title="1">
                                // octal
                                if s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '7' </span><span class="cov8" title="1">{
                                        oct := string(s[i])
                                        i++
                                        for j := 0; j &lt; 2 &amp;&amp; i &lt; len(s) &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '7'; j++ </span><span class="cov8" title="1">{
                                                oct += string(s[i])
                                                i++
                                        }</span>
                                        <span class="cov8" title="1">v, _ := strconv.ParseUint(oct, 8, 8)
                                        buf.WriteByte(byte(v))
                                        continue</span>
                                }
                                <span class="cov8" title="1">buf.WriteByte(s[i])</span>
                        }
                } else<span class="cov8" title="1"> {
                        buf.WriteByte(s[i])
                }</span>
                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package gopdf

import (
        "math"
        "strings"
)

// TextSearchResult represents a single text search match on a page.
type TextSearchResult struct {
        // PageIndex is the 0-based page index where the match was found.
        PageIndex int
        // X is the X coordinate of the match.
        X float64
        // Y is the Y coordinate of the match.
        Y float64
        // Width is the approximate width of the matched text.
        Width float64
        // Height is the approximate height of the matched text.
        Height float64
        // Text is the matched text.
        Text string
        // Context is the surrounding text for context.
        Context string
}

// SearchText searches for text across all pages of the given PDF data.
// Returns all matches with their positions. The search is case-sensitive
// unless caseInsensitive is true.
//
// Example:
//
//        data, _ := os.ReadFile("input.pdf")
//        results, _ := gopdf.SearchText(data, "hello", true)
//        for _, r := range results {
//            fmt.Printf("Page %d at (%.0f, %.0f): %s\n", r.PageIndex, r.X, r.Y, r.Text)
//        }
func SearchText(pdfData []byte, query string, caseInsensitive bool) ([]TextSearchResult, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var results []TextSearchResult
        for i := range parser.pages </span><span class="cov8" title="1">{
                pageResults, err := searchTextOnPage(parser, i, query, caseInsensitive)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">results = append(results, pageResults...)</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}

// SearchTextOnPage searches for text on a specific page (0-based).
func SearchTextOnPage(pdfData []byte, pageIndex int, query string, caseInsensitive bool) ([]TextSearchResult, error) <span class="cov8" title="1">{
        parser, err := newRawPDFParser(pdfData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return searchTextOnPage(parser, pageIndex, query, caseInsensitive)</span>
}

func searchTextOnPage(parser *rawPDFParser, pageIndex int, query string, caseInsensitive bool) ([]TextSearchResult, error) <span class="cov8" title="1">{
        if pageIndex &lt; 0 || pageIndex &gt;= len(parser.pages) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">stream := parser.getPageContentStream(pageIndex)
        if len(stream) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">page := parser.pages[pageIndex]
        fonts := buildFontMap(parser, page)
        texts := parseTextOperators(stream, fonts, page.mediaBox)

        if len(texts) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var results []TextSearchResult

        // Build a full-text string with position mapping.
        searchQuery := query
        if caseInsensitive </span><span class="cov8" title="1">{
                searchQuery = strings.ToLower(query)
        }</span>

        // Search within individual text items first.
        <span class="cov8" title="1">for _, t := range texts </span><span class="cov8" title="1">{
                textToSearch := t.Text
                if caseInsensitive </span><span class="cov8" title="1">{
                        textToSearch = strings.ToLower(textToSearch)
                }</span>

                <span class="cov8" title="1">idx := 0
                for </span><span class="cov8" title="1">{
                        pos := strings.Index(textToSearch[idx:], searchQuery)
                        if pos &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">matchStart := idx + pos
                        matchText := t.Text[matchStart : matchStart+len(query)]

                        results = append(results, TextSearchResult{
                                PageIndex: pageIndex,
                                X:         t.X,
                                Y:         t.Y,
                                Width:     t.FontSize * float64(len(matchText)) * 0.5,
                                Height:    t.FontSize,
                                Text:      matchText,
                                Context:   t.Text,
                        })
                        idx = matchStart + len(query)</span>
                }
        }

        // Also search across adjacent text items on the same line.
        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov8" title="1">{
                results = append(results, searchAcrossItems(texts, pageIndex, query, caseInsensitive)...)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// searchAcrossItems searches for text that spans multiple text items on the same line.
func searchAcrossItems(texts []ExtractedText, pageIndex int, query string, caseInsensitive bool) []TextSearchResult <span class="cov8" title="1">{
        var results []TextSearchResult

        // Group texts by approximate Y position (same line).
        type lineGroup struct {
                y     float64
                texts []ExtractedText
        }
        var lines []lineGroup

        for _, t := range texts </span><span class="cov8" title="1">{
                found := false
                for i := range lines </span><span class="cov8" title="1">{
                        if math.Abs(lines[i].y-t.Y) &lt; 2 </span><span class="cov8" title="1">{
                                lines[i].texts = append(lines[i].texts, t)
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        lines = append(lines, lineGroup{y: t.Y, texts: []ExtractedText{t}})
                }</span>
        }

        <span class="cov8" title="1">searchQuery := query
        if caseInsensitive </span><span class="cov8" title="1">{
                searchQuery = strings.ToLower(query)
        }</span>

        <span class="cov8" title="1">for _, line := range lines </span><span class="cov8" title="1">{
                // Concatenate all text on this line.
                var combined strings.Builder
                for i, t := range line.texts </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                combined.WriteByte(' ')
                        }</span>
                        <span class="cov8" title="1">combined.WriteString(t.Text)</span>
                }
                <span class="cov8" title="1">lineText := combined.String()
                searchLine := lineText
                if caseInsensitive </span><span class="cov8" title="1">{
                        searchLine = strings.ToLower(lineText)
                }</span>

                <span class="cov8" title="1">idx := 0
                for </span><span class="cov8" title="1">{
                        pos := strings.Index(searchLine[idx:], searchQuery)
                        if pos &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">matchStart := idx + pos
                        matchText := lineText[matchStart : matchStart+len(query)]

                        x := line.texts[0].X
                        fontSize := line.texts[0].FontSize

                        results = append(results, TextSearchResult{
                                PageIndex: pageIndex,
                                X:         x,
                                Y:         line.y,
                                Width:     fontSize * float64(len(matchText)) * 0.5,
                                Height:    fontSize,
                                Text:      matchText,
                                Context:   lineText,
                        })
                        idx = matchStart + len(query)</span>
                }
        }

        <span class="cov8" title="1">return results</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package gopdf

// TOCItem represents a single entry in the table of contents.
type TOCItem struct {
        // Level is the hierarchy level (1 = top level).
        Level int
        // Title is the bookmark title text.
        Title string
        // PageNo is the 1-based target page number.
        PageNo int
        // Y is the vertical position on the target page (in points from top).
        Y float64
}

// GetTOC returns the table of contents (outline/bookmark tree) as a flat list.
// Each item includes its hierarchy level, title, target page, and Y position.
//
// This reads the outlines that were added via AddOutline/AddOutlineWithPosition.
// For imported PDFs, outlines from the source are not preserved by gofpdi,
// so this returns only outlines added programmatically.
//
// Example:
//
//        toc := pdf.GetTOC()
//        for _, item := range toc {
//            fmt.Printf("L%d: %s -&gt; page %d\n", item.Level, item.Title, item.PageNo)
//        }
func (gp *GoPdf) GetTOC() []TOCItem <span class="cov8" title="1">{
        if gp.outlines == nil || gp.outlines.Count() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var items []TOCItem

        // Walk through pdfObjs to find OutlineObj instances and reconstruct the tree.
        // Since the current outline system is a flat linked list under OutlinesObj,
        // we traverse the linked list via first/next pointers.
        firstObjID := gp.outlines.first
        if firstObjID &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build a map of objID -&gt; OutlineObj for traversal.
        <span class="cov8" title="1">outlineMap := make(map[int]*OutlineObj)
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if o, ok := obj.(*OutlineObj); ok </span><span class="cov8" title="1">{
                        outlineMap[i+1] = o
                }</span>
        }

        // Map dest (page obj ID) -&gt; page number.
        <span class="cov8" title="1">pageObjIDs := make(map[int]int) // objID -&gt; 1-based page number
        pageCount := 0
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if _, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        pageCount++
                        pageObjIDs[i+1] = pageCount
                }</span>
        }

        // Traverse the linked list starting from first.
        <span class="cov8" title="1">visited := make(map[int]bool)
        gp.collectTOCItems(outlineMap, pageObjIDs, firstObjID, 1, &amp;items, visited)

        return items</span>
}

// collectTOCItems recursively collects TOC items from the outline tree.
func (gp *GoPdf) collectTOCItems(
        outlineMap map[int]*OutlineObj,
        pageObjIDs map[int]int,
        objID int,
        level int,
        items *[]TOCItem,
        visited map[int]bool,
) <span class="cov8" title="1">{
        if objID &lt;= 0 || visited[objID] </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">visited[objID] = true

        o, ok := outlineMap[objID]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pageNo := pageObjIDs[o.dest]
        if pageNo == 0 </span><span class="cov0" title="0">{
                pageNo = -1
        }</span>

        <span class="cov8" title="1">*items = append(*items, TOCItem{
                Level:  level,
                Title:  o.title,
                PageNo: pageNo,
                Y:      o.height,
        })

        // Recurse into children.
        if o.first &gt; 0 </span><span class="cov8" title="1">{
                gp.collectTOCItems(outlineMap, pageObjIDs, o.first, level+1, items, visited)
        }</span>

        // Continue to next sibling.
        <span class="cov8" title="1">if o.next &gt; 0 </span><span class="cov8" title="1">{
                gp.collectTOCItems(outlineMap, pageObjIDs, o.next, level, items, visited)
        }</span>
}

// SetTOC replaces the entire outline tree with the provided TOC items.
// Each item's Level must be &gt;= 1. The first item must have Level 1.
// Levels may increase by at most 1 from one item to the next.
//
// Example:
//
//        pdf.SetTOC([]gopdf.TOCItem{
//            {Level: 1, Title: "Chapter 1", PageNo: 1},
//            {Level: 2, Title: "Section 1.1", PageNo: 1, Y: 200},
//            {Level: 2, Title: "Section 1.2", PageNo: 2},
//            {Level: 1, Title: "Chapter 2", PageNo: 3},
//        })
func (gp *GoPdf) SetTOC(items []TOCItem) error <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov8" title="1">{
                // Clear outlines.
                gp.outlines = &amp;OutlinesObj{}
                gp.outlines.init(func() *GoPdf </span><span class="cov0" title="0">{ return gp }</span>)
                <span class="cov8" title="1">gp.outlines.SetIndexObjOutlines(gp.indexOfOutlinesObj + 1)
                return nil</span>
        }

        // Validate levels.
        <span class="cov8" title="1">if items[0].Level != 1 </span><span class="cov8" title="1">{
                return ErrInvalidTOCLevel
        }</span>
        <span class="cov8" title="1">for i := 1; i &lt; len(items); i++ </span><span class="cov8" title="1">{
                if items[i].Level &lt; 1 </span><span class="cov8" title="1">{
                        return ErrInvalidTOCLevel
                }</span>
                <span class="cov8" title="1">if items[i].Level &gt; items[i-1].Level+1 </span><span class="cov8" title="1">{
                        return ErrInvalidTOCLevel
                }</span>
        }

        // Build page number -&gt; page obj ID map.
        <span class="cov8" title="1">pageObjIDByNo := make(map[int]int) // 1-based page number -&gt; obj ID
        pageCount := 0
        for i, obj := range gp.pdfObjs </span><span class="cov8" title="1">{
                if _, ok := obj.(*PageObj); ok </span><span class="cov8" title="1">{
                        pageCount++
                        pageObjIDByNo[pageCount] = i + 1
                }</span>
        }

        // Reset outlines.
        <span class="cov8" title="1">gp.outlines = &amp;OutlinesObj{}
        gp.outlines.init(func() *GoPdf </span><span class="cov8" title="1">{ return gp }</span>)
        <span class="cov8" title="1">gp.outlines.SetIndexObjOutlines(gp.indexOfOutlinesObj + 1)

        // For a flat (level-1 only) TOC, use the simple AddOutline approach.
        // For hierarchical TOC, we need to build the tree structure.
        allFlat := true
        for _, item := range items </span><span class="cov8" title="1">{
                if item.Level &gt; 1 </span><span class="cov8" title="1">{
                        allFlat = false
                        break</span>
                }
        }

        <span class="cov8" title="1">if allFlat </span><span class="cov8" title="1">{
                for _, item := range items </span><span class="cov8" title="1">{
                        dest := pageObjIDByNo[item.PageNo]
                        if dest == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if item.Y &gt; 0 </span><span class="cov8" title="1">{
                                gp.outlines.AddOutlinesWithPosition(dest, item.Title, item.Y)
                        }</span> else<span class="cov8" title="1"> {
                                gp.outlines.AddOutline(dest, item.Title)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Build hierarchical outline tree using OutlineNodes.
        <span class="cov8" title="1">type nodeInfo struct {
                node  *OutlineNode
                level int
        }

        var roots []*OutlineNode
        var stack []nodeInfo

        for _, item := range items </span><span class="cov8" title="1">{
                dest := pageObjIDByNo[item.PageNo]
                if dest == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">oo := gp.outlines.AddOutlinesWithPosition(dest, item.Title, item.Y)
                node := &amp;OutlineNode{Obj: oo}

                // Pop stack until we find the parent level.
                for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1].level &gt;= item.Level </span><span class="cov8" title="1">{
                        stack = stack[:len(stack)-1]
                }</span>

                <span class="cov8" title="1">if len(stack) == 0 </span><span class="cov8" title="1">{
                        roots = append(roots, node)
                }</span> else<span class="cov8" title="1"> {
                        parent := stack[len(stack)-1].node
                        parent.Children = append(parent.Children, node)
                }</span>

                <span class="cov8" title="1">stack = append(stack, nodeInfo{node: node, level: item.Level})</span>
        }

        // Parse the tree to set prev/next/first/last/parent pointers.
        <span class="cov8" title="1">OutlineNodes(roots).Parse()

        // Update outlines first/last from roots.
        if len(roots) &gt; 0 </span><span class="cov8" title="1">{
                gp.outlines.first = roots[0].Obj.GetIndex()
                gp.outlines.last = roots[len(roots)-1].Obj.GetIndex()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ErrInvalidTOCLevel is returned when TOC items have invalid hierarchy levels.
var ErrInvalidTOCLevel = errorf("invalid TOC level: first item must be level 1, and levels may increase by at most 1")

func errorf(msg string) error <span class="cov8" title="1">{
        return &amp;tocError{msg: msg}
}</span>

type tocError struct {
        msg string
}

func (e *tocError) Error() string <span class="cov8" title="1">{
        return e.msg
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">package gopdf

import (
        "fmt"
        "sync"

        "errors"
)

type BlendModeType string

const (
        Hue             BlendModeType = "/Hue"
        Color           BlendModeType = "/Color"
        NormalBlendMode BlendModeType = "/Normal"
        Darken          BlendModeType = "/Darken"
        Screen          BlendModeType = "/Screen"
        Overlay         BlendModeType = "/Overlay"
        Lighten         BlendModeType = "/Lighten"
        Multiply        BlendModeType = "/Multiply"
        Exclusion       BlendModeType = "/Exclusion"
        ColorBurn       BlendModeType = "/ColorBurn"
        HardLight       BlendModeType = "/HardLight"
        SoftLight       BlendModeType = "/SoftLight"
        Difference      BlendModeType = "/Difference"
        Saturation      BlendModeType = "/Saturation"
        Luminosity      BlendModeType = "/Luminosity"
        ColorDodge      BlendModeType = "/ColorDodge"
)

const DefaultAplhaValue = 1

// Transparency defines an object alpha.
type Transparency struct {
        extGStateIndex int
        Alpha          float64
        BlendModeType  BlendModeType
}

func NewTransparency(alpha float64, blendModeType string) (Transparency, error) <span class="cov8" title="1">{
        if alpha &lt; 0.0 || alpha &gt; 1.0 </span><span class="cov8" title="1">{
                return Transparency{}, fmt.Errorf("alpha value is out of range (0.0 - 1.0): %.3f", alpha)
        }</span>

        <span class="cov8" title="1">bmtType, err := defineBlendModeType(blendModeType)
        if err != nil </span><span class="cov8" title="1">{
                return Transparency{}, err
        }</span>

        <span class="cov8" title="1">return Transparency{
                Alpha:         alpha,
                BlendModeType: bmtType,
        }, nil</span>
}

func (t Transparency) GetId() string <span class="cov8" title="1">{
        keyStr := fmt.Sprintf("%.3f_%s", t.Alpha, t.BlendModeType)

        return keyStr
}</span>

type TransparencyMap struct {
        syncer sync.Mutex
        table  map[string]Transparency
}

func NewTransparencyMap() TransparencyMap <span class="cov8" title="1">{
        return TransparencyMap{
                syncer: sync.Mutex{},
                table:  make(map[string]Transparency),
        }
}</span>

func (tm *TransparencyMap) Find(transparency Transparency) (Transparency, bool) <span class="cov8" title="1">{
        key := transparency.GetId()

        tm.syncer.Lock()
        defer tm.syncer.Unlock()

        t, ok := tm.table[key]
        if !ok </span><span class="cov8" title="1">{
                return Transparency{}, false
        }</span>

        <span class="cov8" title="1">return t, ok</span>

}

func (tm *TransparencyMap) Save(transparency Transparency) Transparency <span class="cov8" title="1">{
        tm.syncer.Lock()
        defer tm.syncer.Unlock()

        key := transparency.GetId()
        tm.table[key] = transparency

        return transparency
}</span>

func defineBlendModeType(bmType string) (BlendModeType, error) <span class="cov8" title="1">{
        switch bmType </span>{
        case string(Hue):<span class="cov8" title="1">
                return Hue, nil</span>
        case string(Color):<span class="cov8" title="1">
                return Color, nil</span>
        case "", string(NormalBlendMode):<span class="cov8" title="1">
                return NormalBlendMode, nil</span>
        case string(Darken):<span class="cov8" title="1">
                return Darken, nil</span>
        case string(Screen):<span class="cov8" title="1">
                return Screen, nil</span>
        case string(Overlay):<span class="cov8" title="1">
                return Overlay, nil</span>
        case string(Lighten):<span class="cov8" title="1">
                return Lighten, nil</span>
        case string(Multiply):<span class="cov8" title="1">
                return Multiply, nil</span>
        case string(Exclusion):<span class="cov8" title="1">
                return Exclusion, nil</span>
        case string(ColorBurn):<span class="cov8" title="1">
                return ColorBurn, nil</span>
        case string(HardLight):<span class="cov8" title="1">
                return HardLight, nil</span>
        case string(SoftLight):<span class="cov8" title="1">
                return SoftLight, nil</span>
        case string(Difference):<span class="cov8" title="1">
                return Difference, nil</span>
        case string(Saturation):<span class="cov8" title="1">
                return Saturation, nil</span>
        case string(Luminosity):<span class="cov8" title="1">
                return Luminosity, nil</span>
        case string(ColorDodge):<span class="cov8" title="1">
                return ColorDodge, nil</span>
        default:<span class="cov8" title="1">
                return "", errors.New("blend mode is unknown")</span>
        }
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

type TransparencyXObjectGroup struct {
        Index            int
        BBox             [4]float64
        Matrix           [6]float64
        ExtGStateIndexes []int
        XObjects         []cacheContentImage

        getRoot       func() *GoPdf
        pdfProtection *PDFProtection
}

type TransparencyXObjectGroupOptions struct {
        Protection       *PDFProtection
        ExtGStateIndexes []int
        BBox             [4]float64
        XObjects         []cacheContentImage
}

func GetCachedTransparencyXObjectGroup(opts TransparencyXObjectGroupOptions, gp *GoPdf) (TransparencyXObjectGroup, error) <span class="cov8" title="1">{
        group := TransparencyXObjectGroup{
                BBox:             opts.BBox,
                XObjects:         opts.XObjects,
                pdfProtection:    opts.Protection,
                ExtGStateIndexes: opts.ExtGStateIndexes,
        }
        group.Index = gp.addObj(group)
        group.init(func() *GoPdf </span><span class="cov0" title="0">{
                return gp
        }</span>)

        <span class="cov8" title="1">return group, nil</span>
}

func (s TransparencyXObjectGroup) init(funcGetRoot func() *GoPdf) <span class="cov8" title="1">{
        s.getRoot = funcGetRoot
}</span>

func (s *TransparencyXObjectGroup) setProtection(p *PDFProtection) <span class="cov8" title="1">{
        s.pdfProtection = p
}</span>

func (s TransparencyXObjectGroup) protection() *PDFProtection <span class="cov8" title="1">{
        return s.pdfProtection
}</span>

func (s TransparencyXObjectGroup) getType() string <span class="cov8" title="1">{
        return "XObject"
}</span>

func (s TransparencyXObjectGroup) write(w io.Writer, objId int) error <span class="cov8" title="1">{
        streamBuff := GetBuffer()
        defer PutBuffer(streamBuff)

        for _, XObject := range s.XObjects </span><span class="cov8" title="1">{
                if err := XObject.write(streamBuff, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">content := "&lt;&lt;\n"
        content += "\t/FormType 1\n"
        content += "\t/Subtype /Form\n"
        content += fmt.Sprintf("\t/Type /%s\n", s.getType())
        content += fmt.Sprintf("\t/Matrix [1 0 0 1 0 0]\n")
        content += fmt.Sprintf("\t/BBox [%.3F %.3F %.3F %.3F]\n", s.BBox[0], s.BBox[1], s.BBox[2], s.BBox[3])
        content += "\t/Group&lt;&lt;/CS /DeviceGray /S /Transparency&gt;&gt;\n"

        content += fmt.Sprintf("\t/Length %d\n", len(streamBuff.Bytes()))
        content += "&gt;&gt;\n"
        content += "stream\n"

        if _, err := io.WriteString(w, content); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := w.Write(streamBuff.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := io.WriteString(w, "endstream\n"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package gopdf

// TtfOption  font option
type TtfOption struct {
        UseKerning                bool
        Style                     int               //Regular|Bold|Italic
        OnGlyphNotFound           func(r rune)      //Called when a glyph cannot be found, just for debugging
        OnGlyphNotFoundSubstitute func(r rune) rune //Called when a glyph cannot be found, we can return a new rune to replace it.
}

func defaultTtfFontOption() TtfOption <span class="cov8" title="1">{
        var defa TtfOption
        defa.UseKerning = false
        defa.Style = Regular
        defa.OnGlyphNotFoundSubstitute = DefaultOnGlyphNotFoundSubstitute
        return defa
}</span>

func DefaultOnGlyphNotFoundSubstitute(r rune) rune <span class="cov8" title="1">{
        return rune('\u0020')
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package gopdf

import (
        "fmt"
        "io"
)

// UnicodeMap unicode map
type UnicodeMap struct {
        PtrToSubsetFontObj *SubsetFontObj
        //getRoot            func() *GoPdf
        pdfProtection *PDFProtection
}

func (u *UnicodeMap) init(funcGetRoot func() *GoPdf) {<span class="cov8" title="1">
        //u.getRoot = funcGetRoot
}</span>

func (u *UnicodeMap) setProtection(p *PDFProtection) <span class="cov8" title="1">{
        u.pdfProtection = p
}</span>

func (u *UnicodeMap) protection() *PDFProtection <span class="cov8" title="1">{
        return u.pdfProtection
}</span>

// SetPtrToSubsetFontObj set pointer to SubsetFontObj
func (u *UnicodeMap) SetPtrToSubsetFontObj(ptr *SubsetFontObj) <span class="cov8" title="1">{
        u.PtrToSubsetFontObj = ptr
}</span>

func (u *UnicodeMap) getType() string <span class="cov8" title="1">{
        return "Unicode"
}</span>

func (u *UnicodeMap) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        //stream
        //characterToGlyphIndex := u.PtrToSubsetFontObj.CharacterToGlyphIndex
        prefix :=
                "/CIDInit /ProcSet findresource begin\n" +
                        "12 dict begin\n" +
                        "begincmap\n" +
                        "/CIDSystemInfo &lt;&lt; /Registry (Adobe)/Ordering (UCS)/Supplement 0&gt;&gt; def\n" +
                        "/CMapName /Adobe-Identity-UCS def /CMapType 2 def\n"
        suffix := "endcmap CMapName currentdict /CMap defineresource pop end end"

        glyphIndexToCharacter := newMapGlyphIndexToCharacter() //make(map[int]rune)
        lowIndex := 65536
        hiIndex := -1

        keys := u.PtrToSubsetFontObj.CharacterToGlyphIndex.AllKeys()
        for _, k := range keys </span><span class="cov8" title="1">{
                v, _ := u.PtrToSubsetFontObj.CharacterToGlyphIndex.Val(k)
                index := int(v)
                if index &lt; lowIndex </span><span class="cov8" title="1">{
                        lowIndex = index
                }</span>
                <span class="cov8" title="1">if index &gt; hiIndex </span><span class="cov8" title="1">{
                        hiIndex = index
                }</span>
                //glyphIndexToCharacter[index] = k
                <span class="cov8" title="1">glyphIndexToCharacter.set(index, k)</span>
        }

        <span class="cov8" title="1">buff := GetBuffer()
        defer PutBuffer(buff)

        buff.WriteString(prefix)
        buff.WriteString("1 begincodespacerange\n")
        fmt.Fprintf(buff, "&lt;%04X&gt;&lt;%04X&gt;\n", lowIndex, hiIndex)
        buff.WriteString("endcodespacerange\n")
        fmt.Fprintf(buff, "%d beginbfrange\n", glyphIndexToCharacter.size())
        indexs := glyphIndexToCharacter.allIndexs()
        for _, k := range indexs </span><span class="cov8" title="1">{
                v, _ := glyphIndexToCharacter.runeByIndex(k)
                fmt.Fprintf(buff, "&lt;%04X&gt;&lt;%04X&gt;&lt;%04X&gt;\n", k, k, v)
        }</span>
        <span class="cov8" title="1">buff.WriteString("endbfrange\n")
        buff.WriteString(suffix)
        buff.WriteString("\n")

        io.WriteString(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/Length %d\n", buff.Len())
        io.WriteString(w, "&gt;&gt;\n")
        io.WriteString(w, "stream\n")
        if u.protection() != nil </span><span class="cov8" title="1">{
                tmp, err := rc4Cip(u.protection().objectkey(objID), buff.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.Write(tmp)</span>
                //streambuff.WriteString("\n")
        } else<span class="cov8" title="1"> {
                buff.WriteTo(w)
        }</span>
        <span class="cov8" title="1">io.WriteString(w, "endstream\n")

        return nil</span>
}

type mapGlyphIndexToCharacter struct {
        runes  []rune
        indexs []int
}

func newMapGlyphIndexToCharacter() *mapGlyphIndexToCharacter <span class="cov8" title="1">{
        var m mapGlyphIndexToCharacter
        return &amp;m
}</span>

func (m *mapGlyphIndexToCharacter) set(index int, r rune) <span class="cov8" title="1">{
        m.runes = append(m.runes, r)
        m.indexs = append(m.indexs, index)
}</span>

func (m *mapGlyphIndexToCharacter) size() int <span class="cov8" title="1">{
        return len(m.indexs)
}</span>

func (m *mapGlyphIndexToCharacter) allIndexs() []int <span class="cov8" title="1">{
        return m.indexs
}</span>

func (m *mapGlyphIndexToCharacter) runeByIndex(index int) (rune, bool) <span class="cov8" title="1">{
        var r rune
        ok := false
        for i, idx := range m.indexs </span><span class="cov8" title="1">{
                if idx == index </span><span class="cov8" title="1">{
                        r = m.runes[i]
                        ok = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return r, ok</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package gopdf

import (
        "math"
)

// WatermarkOption configures how a text watermark is rendered.
type WatermarkOption struct {
        // Text is the watermark string to display.
        Text string

        // FontFamily is the font family to use (must be pre-loaded via AddTTFFont).
        FontFamily string

        // FontSize is the font size in points. Default: 48.
        FontSize float64

        // Angle is the rotation angle in degrees. Default: 45.
        Angle float64

        // Color is the RGB color of the watermark text. Default: light gray (200,200,200).
        Color [3]uint8

        // Opacity is the transparency level (0.0 = invisible, 1.0 = opaque). Default: 0.3.
        Opacity float64

        // Repeat tiles the watermark across the page when true.
        Repeat bool

        // RepeatSpacingX is the horizontal spacing between repeated watermarks. Default: 150.
        RepeatSpacingX float64

        // RepeatSpacingY is the vertical spacing between repeated watermarks. Default: 150.
        RepeatSpacingY float64
}

func (o *WatermarkOption) defaults() <span class="cov8" title="1">{
        if o.FontSize &lt;= 0 </span><span class="cov8" title="1">{
                o.FontSize = 48
        }</span>
        <span class="cov8" title="1">if o.Angle == 0 </span><span class="cov8" title="1">{
                o.Angle = 45
        }</span>
        <span class="cov8" title="1">if o.Color == [3]uint8{0, 0, 0} </span><span class="cov8" title="1">{
                o.Color = [3]uint8{200, 200, 200}
        }</span>
        <span class="cov8" title="1">if o.Opacity &lt;= 0 </span><span class="cov8" title="1">{
                o.Opacity = 0.3
        }</span>
        <span class="cov8" title="1">if o.RepeatSpacingX &lt;= 0 </span><span class="cov8" title="1">{
                o.RepeatSpacingX = 150
        }</span>
        <span class="cov8" title="1">if o.RepeatSpacingY &lt;= 0 </span><span class="cov8" title="1">{
                o.RepeatSpacingY = 150
        }</span>
}

// AddWatermarkText adds a text watermark to the current page.
// The watermark is rendered with the specified font, color, opacity, and rotation.
// If Repeat is true, the watermark is tiled across the entire page.
//
// Example:
//
//        pdf.SetPage(1)
//        pdf.AddWatermarkText(WatermarkOption{
//            Text:       "CONFIDENTIAL",
//            FontFamily: "myfont",
//            FontSize:   48,
//            Opacity:    0.3,
//            Angle:      45,
//        })
func (gp *GoPdf) AddWatermarkText(opt WatermarkOption) error <span class="cov8" title="1">{
        if opt.Text == "" </span><span class="cov8" title="1">{
                return ErrEmptyString
        }</span>
        <span class="cov8" title="1">if opt.FontFamily == "" </span><span class="cov8" title="1">{
                return ErrMissingFontFamily
        }</span>
        <span class="cov8" title="1">opt.defaults()

        // Save current state.
        var origFontFamily string
        origFontSize := gp.curr.FontSize
        origFontStyle := gp.curr.FontStyle
        if gp.curr.FontISubset != nil </span><span class="cov8" title="1">{
                origFontFamily = gp.curr.FontISubset.GetFamily()
        }</span>

        // Set watermark font.
        <span class="cov8" title="1">if err := gp.SetFont(opt.FontFamily, "", opt.FontSize); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Set transparency.
        <span class="cov8" title="1">if err := gp.SetTransparency(Transparency{
                Alpha:         opt.Opacity,
                BlendModeType: "",
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gp.SetTextColor(opt.Color[0], opt.Color[1], opt.Color[2])

        // Measure text width for centering.
        textW, err := gp.MeasureTextWidth(opt.Text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pageW := gp.config.PageSize.W
        pageH := gp.config.PageSize.H

        // Check if current page has custom size.
        if gp.curr.pageSize != nil </span><span class="cov8" title="1">{
                pageW = gp.curr.pageSize.W
                pageH = gp.curr.pageSize.H
        }</span>

        <span class="cov8" title="1">gp.SaveGraphicsState()

        if opt.Repeat </span><span class="cov8" title="1">{
                // Tile watermarks across the page.
                for y := opt.RepeatSpacingY; y &lt; pageH; y += opt.RepeatSpacingY + opt.FontSize </span><span class="cov8" title="1">{
                        for x := opt.RepeatSpacingX / 2; x &lt; pageW; x += opt.RepeatSpacingX + textW </span><span class="cov8" title="1">{
                                gp.Rotate(opt.Angle, x, y)
                                gp.SetXY(x-textW/2, y-opt.FontSize/2)
                                _ = gp.Text(opt.Text)
                                gp.RotateReset()
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Single centered watermark.
                cx := pageW / 2
                cy := pageH / 2
                gp.Rotate(opt.Angle, cx, cy)
                gp.SetXY(cx-textW/2, cy-opt.FontSize/2)
                _ = gp.Text(opt.Text)
                gp.RotateReset()
        }</span>

        <span class="cov8" title="1">gp.RestoreGraphicsState()
        gp.ClearTransparency()

        // Restore original font.
        if origFontFamily != "" </span><span class="cov8" title="1">{
                _ = gp.SetFontWithStyle(origFontFamily, origFontStyle, origFontSize)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AddWatermarkImage adds an image watermark to the current page.
// The image is placed at the center of the page with the specified opacity.
//
// Parameters:
//   - imgPath: path to the image file (JPEG or PNG)
//   - opacity: transparency level (0.0 = invisible, 1.0 = opaque)
//   - imgW, imgH: desired width and height of the watermark image in document units.
//     If both are 0, the image is placed at its natural size.
//   - angle: rotation angle in degrees (0 = no rotation)
func (gp *GoPdf) AddWatermarkImage(imgPath string, opacity float64, imgW, imgH float64, angle float64) error <span class="cov8" title="1">{
        if opacity &lt;= 0 </span><span class="cov8" title="1">{
                opacity = 0.3
        }</span>

        <span class="cov8" title="1">pageW := gp.config.PageSize.W
        pageH := gp.config.PageSize.H
        if gp.curr.pageSize != nil </span><span class="cov8" title="1">{
                pageW = gp.curr.pageSize.W
                pageH = gp.curr.pageSize.H
        }</span>

        // Default image size if not specified.
        <span class="cov8" title="1">if imgW &lt;= 0 </span><span class="cov8" title="1">{
                imgW = pageW / 3
        }</span>
        <span class="cov8" title="1">if imgH &lt;= 0 </span><span class="cov8" title="1">{
                imgH = pageH / 3
        }</span>

        <span class="cov8" title="1">cx := pageW/2 - imgW/2
        cy := pageH/2 - imgH/2

        gp.SaveGraphicsState()

        if err := gp.SetTransparency(Transparency{
                Alpha:         opacity,
                BlendModeType: "",
        }); err != nil </span><span class="cov0" title="0">{
                gp.RestoreGraphicsState()
                return err
        }</span>

        <span class="cov8" title="1">if angle != 0 </span><span class="cov8" title="1">{
                gp.Rotate(angle, pageW/2, pageH/2)
        }</span>

        <span class="cov8" title="1">err := gp.Image(imgPath, cx, cy, &amp;Rect{W: imgW, H: imgH})

        if angle != 0 </span><span class="cov8" title="1">{
                gp.RotateReset()
        }</span>

        <span class="cov8" title="1">gp.RestoreGraphicsState()
        gp.ClearTransparency()

        return err</span>
}

// AddWatermarkTextAllPages adds a text watermark to all pages in the document.
func (gp *GoPdf) AddWatermarkTextAllPages(opt WatermarkOption) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                if err := gp.SetPage(i); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := gp.AddWatermarkText(opt); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddWatermarkImageAllPages adds an image watermark to all pages in the document.
func (gp *GoPdf) AddWatermarkImageAllPages(imgPath string, opacity float64, imgW, imgH float64, angle float64) error <span class="cov8" title="1">{
        numPages := gp.GetNumberOfPages()
        for i := 1; i &lt;= numPages; i++ </span><span class="cov8" title="1">{
                if err := gp.SetPage(i); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := gp.AddWatermarkImage(imgPath, opacity, imgW, imgH, angle); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// diagonalAngle calculates the diagonal angle of a rectangle (useful for watermark rotation).
func diagonalAngle(w, h float64) float64 <span class="cov8" title="1">{
        return math.Atan2(h, w) * 180 / math.Pi
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package gopdf

import (
        "fmt"
        "io"
        "strings"
        "time"
)

// XMPMetadata holds XMP (Extensible Metadata Platform) metadata for the PDF.
// XMP is the standard metadata format for PDF 2.0 and is also supported
// in earlier versions. It provides richer metadata than the traditional
// Document Information Dictionary (PdfInfo).
type XMPMetadata struct {
        // Dublin Core (dc:) properties
        Title       string   // dc:title
        Creator     []string // dc:creator (authors)
        Description string   // dc:description
        Subject     []string // dc:subject (keywords)
        Rights      string   // dc:rights (copyright)
        Language    string   // dc:language (e.g. "en-US")

        // XMP Basic (xmp:) properties
        CreatorTool string    // xmp:CreatorTool (application name)
        CreateDate  time.Time // xmp:CreateDate
        ModifyDate  time.Time // xmp:ModifyDate

        // PDF-specific (pdf:) properties
        Producer string // pdf:Producer
        Keywords string // pdf:Keywords
        Trapped  string // pdf:Trapped ("True", "False", "Unknown")

        // PDF/A conformance (pdfaid:)
        PDFAConformance string // pdfaid:conformance ("A", "B", "U")
        PDFAPart        int    // pdfaid:part (1, 2, 3)

        // Custom properties
        Custom map[string]string
}

// SetXMPMetadata sets the XMP metadata for the document.
// The XMP metadata stream will be embedded in the PDF output.
//
// Example:
//
//        pdf.SetXMPMetadata(gopdf.XMPMetadata{
//            Title:       "Annual Report 2025",
//            Creator:     []string{"John Doe", "Jane Smith"},
//            Description: "Company annual financial report",
//            Subject:     []string{"finance", "annual report"},
//            CreatorTool: "GoPDF2",
//            Producer:    "GoPDF2",
//            CreateDate:  time.Now(),
//            ModifyDate:  time.Now(),
//        })
func (gp *GoPdf) SetXMPMetadata(meta XMPMetadata) <span class="cov8" title="1">{
        gp.xmpMetadata = &amp;meta
}</span>

// GetXMPMetadata returns the current XMP metadata, or nil if not set.
func (gp *GoPdf) GetXMPMetadata() *XMPMetadata <span class="cov8" title="1">{
        return gp.xmpMetadata
}</span>

// xmpMetadataObj is the PDF metadata stream object containing XMP data.
type xmpMetadataObj struct {
        meta *XMPMetadata
}

func (x xmpMetadataObj) init(f func() *GoPdf) {<span class="cov0" title="0">}</span>

func (x xmpMetadataObj) getType() string <span class="cov8" title="1">{
        return "Metadata"
}</span>

func (x xmpMetadataObj) write(w io.Writer, objID int) error <span class="cov8" title="1">{
        xmpData := x.buildXMP()

        fmt.Fprintf(w, "&lt;&lt;\n")
        fmt.Fprintf(w, "/Type /Metadata\n")
        fmt.Fprintf(w, "/Subtype /XML\n")
        fmt.Fprintf(w, "/Length %d\n", len(xmpData))
        fmt.Fprintf(w, "&gt;&gt;\n")
        fmt.Fprintf(w, "stream\n")
        io.WriteString(w, xmpData)
        fmt.Fprintf(w, "\nendstream\n")
        return nil
}</span>

func (x xmpMetadataObj) buildXMP() string <span class="cov8" title="1">{
        m := x.meta
        var b strings.Builder

        b.WriteString(`&lt;?xpacket begin="` + "\xef\xbb\xbf" + `" id="W5M0MpCehiHzreSzNTczkc9d"?&gt;` + "\n")
        b.WriteString(`&lt;x:xmpmeta xmlns:x="adobe:ns:meta/"&gt;` + "\n")
        b.WriteString(`&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;` + "\n")
        b.WriteString(`&lt;rdf:Description rdf:about=""` + "\n")
        b.WriteString(`  xmlns:dc="http://purl.org/dc/elements/1.1/"` + "\n")
        b.WriteString(`  xmlns:xmp="http://ns.adobe.com/xap/1.0/"` + "\n")
        b.WriteString(`  xmlns:pdf="http://ns.adobe.com/pdf/1.3/"` + "\n")
        b.WriteString(`  xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/"` + "\n")
        b.WriteString(`&gt;` + "\n")

        // dc:title
        if m.Title != "" </span><span class="cov8" title="1">{
                b.WriteString(`  &lt;dc:title&gt;&lt;rdf:Alt&gt;&lt;rdf:li xml:lang="x-default"&gt;`)
                b.WriteString(xmlEscape(m.Title))
                b.WriteString(`&lt;/rdf:li&gt;&lt;/rdf:Alt&gt;&lt;/dc:title&gt;` + "\n")
        }</span>

        // dc:creator
        <span class="cov8" title="1">if len(m.Creator) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("  &lt;dc:creator&gt;&lt;rdf:Seq&gt;\n")
                for _, c := range m.Creator </span><span class="cov8" title="1">{
                        b.WriteString("    &lt;rdf:li&gt;")
                        b.WriteString(xmlEscape(c))
                        b.WriteString("&lt;/rdf:li&gt;\n")
                }</span>
                <span class="cov8" title="1">b.WriteString("  &lt;/rdf:Seq&gt;&lt;/dc:creator&gt;\n")</span>
        }

        // dc:description
        <span class="cov8" title="1">if m.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(`  &lt;dc:description&gt;&lt;rdf:Alt&gt;&lt;rdf:li xml:lang="x-default"&gt;`)
                b.WriteString(xmlEscape(m.Description))
                b.WriteString(`&lt;/rdf:li&gt;&lt;/rdf:Alt&gt;&lt;/dc:description&gt;` + "\n")
        }</span>

        // dc:subject
        <span class="cov8" title="1">if len(m.Subject) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("  &lt;dc:subject&gt;&lt;rdf:Bag&gt;\n")
                for _, s := range m.Subject </span><span class="cov8" title="1">{
                        b.WriteString("    &lt;rdf:li&gt;")
                        b.WriteString(xmlEscape(s))
                        b.WriteString("&lt;/rdf:li&gt;\n")
                }</span>
                <span class="cov8" title="1">b.WriteString("  &lt;/rdf:Bag&gt;&lt;/dc:subject&gt;\n")</span>
        }

        // dc:rights
        <span class="cov8" title="1">if m.Rights != "" </span><span class="cov8" title="1">{
                b.WriteString(`  &lt;dc:rights&gt;&lt;rdf:Alt&gt;&lt;rdf:li xml:lang="x-default"&gt;`)
                b.WriteString(xmlEscape(m.Rights))
                b.WriteString(`&lt;/rdf:li&gt;&lt;/rdf:Alt&gt;&lt;/dc:rights&gt;` + "\n")
        }</span>

        // dc:language
        <span class="cov8" title="1">if m.Language != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;dc:language&gt;&lt;rdf:Bag&gt;&lt;rdf:li&gt;")
                b.WriteString(xmlEscape(m.Language))
                b.WriteString("&lt;/rdf:li&gt;&lt;/rdf:Bag&gt;&lt;/dc:language&gt;\n")
        }</span>

        // xmp:CreatorTool
        <span class="cov8" title="1">if m.CreatorTool != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;xmp:CreatorTool&gt;")
                b.WriteString(xmlEscape(m.CreatorTool))
                b.WriteString("&lt;/xmp:CreatorTool&gt;\n")
        }</span>

        // xmp:CreateDate
        <span class="cov8" title="1">if !m.CreateDate.IsZero() </span><span class="cov8" title="1">{
                b.WriteString("  &lt;xmp:CreateDate&gt;")
                b.WriteString(m.CreateDate.UTC().Format("2006-01-02T15:04:05Z"))
                b.WriteString("&lt;/xmp:CreateDate&gt;\n")
        }</span>

        // xmp:ModifyDate
        <span class="cov8" title="1">if !m.ModifyDate.IsZero() </span><span class="cov8" title="1">{
                b.WriteString("  &lt;xmp:ModifyDate&gt;")
                b.WriteString(m.ModifyDate.UTC().Format("2006-01-02T15:04:05Z"))
                b.WriteString("&lt;/xmp:ModifyDate&gt;\n")
        }</span>

        // pdf:Producer
        <span class="cov8" title="1">if m.Producer != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;pdf:Producer&gt;")
                b.WriteString(xmlEscape(m.Producer))
                b.WriteString("&lt;/pdf:Producer&gt;\n")
        }</span>

        // pdf:Keywords
        <span class="cov8" title="1">if m.Keywords != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;pdf:Keywords&gt;")
                b.WriteString(xmlEscape(m.Keywords))
                b.WriteString("&lt;/pdf:Keywords&gt;\n")
        }</span>

        // pdf:Trapped
        <span class="cov8" title="1">if m.Trapped != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;pdf:Trapped&gt;")
                b.WriteString(xmlEscape(m.Trapped))
                b.WriteString("&lt;/pdf:Trapped&gt;\n")
        }</span>

        // pdfaid:part and pdfaid:conformance
        <span class="cov8" title="1">if m.PDFAPart &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;b, "  &lt;pdfaid:part&gt;%d&lt;/pdfaid:part&gt;\n", m.PDFAPart)
        }</span>
        <span class="cov8" title="1">if m.PDFAConformance != "" </span><span class="cov8" title="1">{
                b.WriteString("  &lt;pdfaid:conformance&gt;")
                b.WriteString(xmlEscape(m.PDFAConformance))
                b.WriteString("&lt;/pdfaid:conformance&gt;\n")
        }</span>

        <span class="cov8" title="1">b.WriteString(`&lt;/rdf:Description&gt;` + "\n")
        b.WriteString(`&lt;/rdf:RDF&gt;` + "\n")
        b.WriteString(`&lt;/x:xmpmeta&gt;` + "\n")
        b.WriteString(`&lt;?xpacket end="w"?&gt;`)

        return b.String()</span>
}

// xmlEscape escapes special XML characters.
func xmlEscape(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "&amp;", "&amp;amp;")
        s = strings.ReplaceAll(s, "&lt;", "&amp;lt;")
        s = strings.ReplaceAll(s, "&gt;", "&amp;gt;")
        s = strings.ReplaceAll(s, `"`, "&amp;quot;")
        s = strings.ReplaceAll(s, "'", "&amp;apos;")
        return s
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
